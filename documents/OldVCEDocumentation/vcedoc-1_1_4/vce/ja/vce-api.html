<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../vce.css" type="text/css">
<title> VCE-SDK API リファレンスマニュアル </title>
</head>
<body>
<h1> VCE-SDK API リファレンスマニュアル </h1>
<h2>全カテゴリのリスト</h2>
<!-- make_categoryindexindex -->
<ol>
<li><a href="#analyzer">analyzer</a></li>
<li><a href="#array">array</a></li>
<li><a href="#bin">bin</a></li>
<li><a href="#core">core</a></li>
<li><a href="#err">err</a></li>
<li><a href="#log">log</a></li>
<li><a href="#logwriter">logwriter</a></li>
<li><a href="#monitor">monitor</a></li>
<li><a href="#parser">parser</a></li>
<li><a href="#pcallback">pcallback</a></li>
<li><a href="#profiler">profiler</a></li>
<li><a href="#search">search</a></li>
<li><a href="#task">task</a></li>
<li><a href="#tcp">tcp</a></li>
<li><a href="#text">text</a></li>
<li><a href="#util">util</a></li>
<li><a href="#watcher">watcher</a></li>
</ol>
<h2>名前順の関数もくじ</h2>
<!-- make_nameindex -->
<ol>
<li><a href="#ARRAY_SCAN">ARRAY_SCAN</a></li>
<li><a href="#ARRAY_SCAN_TYPE">ARRAY_SCAN_TYPE</a></li>
<li><a href="#ELEMENTOF">ELEMENTOF</a></li>
<li><a href="#FREE">FREE</a></li>
<li><a href="#GET_16BIT_INT">GET_16BIT_INT</a></li>
<li><a href="#GET_16BIT_NATIVEINT">GET_16BIT_NATIVEINT</a></li>
<li><a href="#GET_32BIT_INT">GET_32BIT_INT</a></li>
<li><a href="#GET_32BIT_NATIVEINT">GET_32BIT_NATIVEINT</a></li>
<li><a href="#GET_64BIT_INT">GET_64BIT_INT</a></li>
<li><a href="#GET_64BIT_NATIVEINT">GET_64BIT_NATIVEINT</a></li>
<li><a href="#GET_8BIT_INT">GET_8BIT_INT</a></li>
<li><a href="#GET_8BIT_NATIVEINT">GET_8BIT_NATIVEINT</a></li>
<li><a href="#MALLOC">MALLOC</a></li>
<li><a href="#MAX">MAX</a></li>
<li><a href="#MIN">MIN</a></li>
<li><a href="#SET_16BIT_INT">SET_16BIT_INT</a></li>
<li><a href="#SET_16BIT_NATIVEINT">SET_16BIT_NATIVEINT</a></li>
<li><a href="#SET_32BIT_INT">SET_32BIT_INT</a></li>
<li><a href="#SET_32BIT_NATIVEINT">SET_32BIT_NATIVEINT</a></li>
<li><a href="#SET_64BIT_INT">SET_64BIT_INT</a></li>
<li><a href="#SET_64BIT_NATIVEINT">SET_64BIT_NATIVEINT</a></li>
<li><a href="#SET_8BIT_INT">SET_8BIT_INT</a></li>
<li><a href="#SET_8BIT_NATIVEINT">SET_8BIT_NATIVEINT</a></li>
<li><a href="#STRERR">STRERR</a></li>
<li><a href="#vce_alloc_array_object">vce_alloc_array_object</a></li>
<li><a href="#vce_analyzer_analyze">vce_analyzer_analyze</a></li>
<li><a href="#vce_analyzer_clear">vce_analyzer_clear</a></li>
<li><a href="#vce_analyzer_get_state_string">vce_analyzer_get_state_string</a></li>
<li><a href="#vce_analyzer_init">vce_analyzer_init</a></li>
<li><a href="#vce_array_object_inuse">vce_array_object_inuse</a></li>
<li><a href="#vce_atoi">vce_atoi</a></li>
<li><a href="#vce_binary_pack">vce_binary_pack</a></li>
<li><a href="#vce_binary_pop_nb_i1">vce_binary_pop_nb_i1</a></li>
<li><a href="#vce_binary_pop_nb_i2">vce_binary_pop_nb_i2</a></li>
<li><a href="#vce_binary_pop_nb_i4">vce_binary_pop_nb_i4</a></li>
<li><a href="#vce_binary_pop_nb_i8">vce_binary_pop_nb_i8</a></li>
<li><a href="#vce_binary_pop_nb_ia1">vce_binary_pop_nb_ia1</a></li>
<li><a href="#vce_binary_pop_nb_ia2">vce_binary_pop_nb_ia2</a></li>
<li><a href="#vce_binary_pop_nb_ia4">vce_binary_pop_nb_ia4</a></li>
<li><a href="#vce_binary_pop_nb_ia8">vce_binary_pop_nb_ia8</a></li>
<li><a href="#vce_binary_pop_nb_stra">vce_binary_pop_nb_stra</a></li>
<li><a href="#vce_binary_push_nb_i1">vce_binary_push_nb_i1</a></li>
<li><a href="#vce_binary_push_nb_i2">vce_binary_push_nb_i2</a></li>
<li><a href="#vce_binary_push_nb_i4">vce_binary_push_nb_i4</a></li>
<li><a href="#vce_binary_push_nb_i8">vce_binary_push_nb_i8</a></li>
<li><a href="#vce_binary_push_nb_ia1">vce_binary_push_nb_ia1</a></li>
<li><a href="#vce_binary_push_nb_ia2">vce_binary_push_nb_ia2</a></li>
<li><a href="#vce_binary_push_nb_ia4">vce_binary_push_nb_ia4</a></li>
<li><a href="#vce_binary_push_nb_ia8">vce_binary_push_nb_ia8</a></li>
<li><a href="#vce_binary_push_nb_stra">vce_binary_push_nb_stra</a></li>
<li><a href="#vce_binary_unpack">vce_binary_unpack</a></li>
<li><a href="#vce_chop_string_destroy">vce_chop_string_destroy</a></li>
<li><a href="#vce_circ_clear">vce_circ_clear</a></li>
<li><a href="#vce_circ_close">vce_circ_close</a></li>
<li><a href="#vce_circ_get_index">vce_circ_get_index</a></li>
<li><a href="#vce_circ_get_parent_conn">vce_circ_get_parent_conn</a></li>
<li><a href="#vce_circ_get_remote_addr_string">vce_circ_get_remote_addr_string</a></li>
<li><a href="#vce_circ_get_remote_ipv4_addr">vce_circ_get_remote_ipv4_addr</a></li>
<li><a href="#vce_circ_get_remote_ipv4_addr_string">vce_circ_get_remote_ipv4_addr_string</a></li>
<li><a href="#vce_circ_get_remote_ipv6_addr">vce_circ_get_remote_ipv6_addr</a></li>
<li><a href="#vce_circ_get_remote_ipv6_addr_string">vce_circ_get_remote_ipv6_addr_string</a></li>
<li><a href="#vce_circ_get_state_buffer">vce_circ_get_state_buffer</a></li>
<li><a href="#vce_circ_get_struct_from_index">vce_circ_get_struct_from_index</a></li>
<li><a href="#vce_circ_get_tcpcontext">vce_circ_get_tcpcontext</a></li>
<li><a href="#vce_circ_is_equal">vce_circ_is_equal</a></li>
<li><a href="#vce_circ_is_valid">vce_circ_is_valid</a></li>
<li><a href="#vce_circ_set_alarmwatcher">vce_circ_set_alarmwatcher</a></li>
<li><a href="#vce_circ_set_timeout">vce_circ_set_timeout</a></li>
<li><a href="#vce_circ_switch">vce_circ_switch</a></li>
<li><a href="#vce_circ_test_sanity">vce_circ_test_sanity</a></li>
<li><a href="#vce_circ_writable">vce_circ_writable</a></li>
<li><a href="#vce_circ_write">vce_circ_write</a></li>
<li><a href="#vce_cleanup_all_search_engine">vce_cleanup_all_search_engine</a></li>
<li><a href="#vce_cleanup_search_engine">vce_cleanup_search_engine</a></li>
<li><a href="#vce_conn_break_heartbeat">vce_conn_break_heartbeat</a></li>
<li><a href="#vce_conn_clear">vce_conn_clear</a></li>
<li><a href="#vce_conn_close">vce_conn_close</a></li>
<li><a href="#vce_conn_close_tcpcontext_all">vce_conn_close_tcpcontext_all</a></li>
<li><a href="#vce_conn_get_buffer">vce_conn_get_buffer</a></li>
<li><a href="#vce_conn_get_child_circ">vce_conn_get_child_circ</a></li>
<li><a href="#vce_conn_get_index">vce_conn_get_index</a></li>
<li><a href="#vce_conn_get_local_addr_string">vce_conn_get_local_addr_string</a></li>
<li><a href="#vce_conn_get_local_ipv4_addr">vce_conn_get_local_ipv4_addr</a></li>
<li><a href="#vce_conn_get_local_ipv4_addr_string">vce_conn_get_local_ipv4_addr_string</a></li>
<li><a href="#vce_conn_get_local_ipv6_addr">vce_conn_get_local_ipv6_addr</a></li>
<li><a href="#vce_conn_get_local_ipv6_addr_string">vce_conn_get_local_ipv6_addr_string</a></li>
<li><a href="#vce_conn_get_remote_addr_string">vce_conn_get_remote_addr_string</a></li>
<li><a href="#vce_conn_get_remote_ipv4_addr">vce_conn_get_remote_ipv4_addr</a></li>
<li><a href="#vce_conn_get_remote_ipv4_addr_string">vce_conn_get_remote_ipv4_addr_string</a></li>
<li><a href="#vce_conn_get_remote_ipv6_addr">vce_conn_get_remote_ipv6_addr</a></li>
<li><a href="#vce_conn_get_remote_ipv6_addr_string">vce_conn_get_remote_ipv6_addr_string</a></li>
<li><a href="#vce_conn_get_stat">vce_conn_get_stat</a></li>
<li><a href="#vce_conn_get_state_buffer">vce_conn_get_state_buffer</a></li>
<li><a href="#vce_conn_get_struct_from_index">vce_conn_get_struct_from_index</a></li>
<li><a href="#vce_conn_get_tcpcontext">vce_conn_get_tcpcontext</a></li>
<li><a href="#vce_conn_is_equal">vce_conn_is_equal</a></li>
<li><a href="#vce_conn_is_valid">vce_conn_is_valid</a></li>
<li><a href="#vce_conn_set_alarmwatcher">vce_conn_set_alarmwatcher</a></li>
<li><a href="#vce_conn_set_delay">vce_conn_set_delay</a></li>
<li><a href="#vce_conn_set_parser">vce_conn_set_parser</a></li>
<li><a href="#vce_conn_set_timeout">vce_conn_set_timeout</a></li>
<li><a href="#vce_conn_show_stat">vce_conn_show_stat</a></li>
<li><a href="#vce_conn_shrink_readbuf">vce_conn_shrink_readbuf</a></li>
<li><a href="#vce_conn_writable">vce_conn_writable</a></li>
<li><a href="#vce_conn_write">vce_conn_write</a></li>
<li><a href="#vce_conn_writed">vce_conn_writed</a></li>
<li><a href="#vce_copy_cstring">vce_copy_cstring</a></li>
<li><a href="#vce_copy_cstring_upto">vce_copy_cstring_upto</a></li>
<li><a href="#vce_decode_buffer_by_blowfish">vce_decode_buffer_by_blowfish</a></li>
<li><a href="#vce_decode_buffer_by_rijndael">vce_decode_buffer_by_rijndael</a></li>
<li><a href="#vce_delete_int2_search">vce_delete_int2_search</a></li>
<li><a href="#vce_delete_int4_search">vce_delete_int4_search</a></li>
<li><a href="#vce_delete_int_search">vce_delete_int_search</a></li>
<li><a href="#vce_delete_string_search">vce_delete_string_search</a></li>
<li><a href="#vce_delete_vstring_search">vce_delete_vstring_search</a></li>
<li><a href="#vce_descape_string">vce_descape_string</a></li>
<li><a href="#vce_dump_buffer">vce_dump_buffer</a></li>
<li><a href="#vce_encode_buffer_by_blowfish">vce_encode_buffer_by_blowfish</a></li>
<li><a href="#vce_encode_buffer_by_rijndael">vce_encode_buffer_by_rijndael</a></li>
<li><a href="#vce_end_all_array">vce_end_all_array</a></li>
<li><a href="#vce_end_array">vce_end_array</a></li>
<li><a href="#vce_errout">vce_errout</a></li>
<li><a href="#vce_errout0">vce_errout0</a></li>
<li><a href="#vce_errout0_v">vce_errout0_v</a></li>
<li><a href="#vce_errout_config">vce_errout_config</a></li>
<li><a href="#vce_errout_set_another">vce_errout_set_another</a></li>
<li><a href="#vce_errout_v">vce_errout_v</a></li>
<li><a href="#vce_escape_string">vce_escape_string</a></li>
<li><a href="#vce_extract_data_from_hex_text">vce_extract_data_from_hex_text</a></li>
<li><a href="#vce_finalize">vce_finalize</a></li>
<li><a href="#vce_free_array_object">vce_free_array_object</a></li>
<li><a href="#vce_free_array_object_all">vce_free_array_object_all</a></li>
<li><a href="#vce_get_array_maxnum">vce_get_array_maxnum</a></li>
<li><a href="#vce_get_array_member_size">vce_get_array_member_size</a></li>
<li><a href="#vce_get_array_object_index">vce_get_array_object_index</a></li>
<li><a href="#vce_get_array_object_last">vce_get_array_object_last</a></li>
<li><a href="#vce_get_array_object_next">vce_get_array_object_next</a></li>
<li><a href="#vce_get_array_object_pointer_by_index">vce_get_array_object_pointer_by_index</a></li>
<li><a href="#vce_get_array_object_pointer_by_index_only_used">vce_get_array_object_pointer_by_index_only_used</a></li>
<li><a href="#vce_get_array_object_top">vce_get_array_object_top</a></li>
<li><a href="#vce_get_array_usenum">vce_get_array_usenum</a></li>
<li><a href="#vce_get_current_utime">vce_get_current_utime</a></li>
<li><a href="#vce_get_int2_or_search">vce_get_int2_or_search</a></li>
<li><a href="#vce_get_int2_search">vce_get_int2_search</a></li>
<li><a href="#vce_get_int4_or_search">vce_get_int4_or_search</a></li>
<li><a href="#vce_get_int4_search">vce_get_int4_search</a></li>
<li><a href="#vce_get_int_search">vce_get_int_search</a></li>
<li><a href="#vce_get_ipv4_addr_by_name">vce_get_ipv4_addr_by_name</a></li>
<li><a href="#vce_get_last_error">vce_get_last_error</a></li>
<li><a href="#vce_get_netstat_string">vce_get_netstat_string</a></li>
<li><a href="#vce_get_search_usenum">vce_get_search_usenum</a></li>
<li><a href="#vce_get_stat">vce_get_stat</a></li>
<li><a href="#vce_get_string_search">vce_get_string_search</a></li>
<li><a href="#vce_get_tcp_packet_read_size">vce_get_tcp_packet_read_size</a></li>
<li><a href="#vce_get_tcp_packet_write_size">vce_get_tcp_packet_write_size</a></li>
<li><a href="#vce_get_version">vce_get_version</a></li>
<li><a href="#vce_get_vstring_search">vce_get_vstring_search</a></li>
<li><a href="#vce_heartbeat">vce_heartbeat</a></li>
<li><a href="#vce_httptext_divide_header_and_content">vce_httptext_divide_header_and_content</a></li>
<li><a href="#vce_httptext_get_header_info">vce_httptext_get_header_info</a></li>
<li><a href="#vce_if_included_in_array">vce_if_included_in_array</a></li>
<li><a href="#vce_init_array">vce_init_array</a></li>
<li><a href="#vce_init_int2_search">vce_init_int2_search</a></li>
<li><a href="#vce_init_int4_search">vce_init_int4_search</a></li>
<li><a href="#vce_init_int_search">vce_init_int_search</a></li>
<li><a href="#vce_init_limit_t">vce_init_limit_t</a></li>
<li><a href="#vce_init_string_search">vce_init_string_search</a></li>
<li><a href="#vce_init_vstring_search">vce_init_vstring_search</a></li>
<li><a href="#vce_initialize">vce_initialize</a></li>
<li><a href="#vce_initialize_limited">vce_initialize_limited</a></li>
<li><a href="#vce_istore_init">vce_istore_init</a></li>
<li><a href="#vce_istore_load">vce_istore_load</a></li>
<li><a href="#vce_istore_save">vce_istore_save</a></li>
<li><a href="#vce_iterate_int2_search">vce_iterate_int2_search</a></li>
<li><a href="#vce_iterate_int4_search">vce_iterate_int4_search</a></li>
<li><a href="#vce_limit_clear">vce_limit_clear</a></li>
<li><a href="#vce_log_add_monitor_command">vce_log_add_monitor_command</a></li>
<li><a href="#vce_log_add_type">vce_log_add_type</a></li>
<li><a href="#vce_log_get_types">vce_log_get_types</a></li>
<li><a href="#vce_log_gettime_long">vce_log_gettime_long</a></li>
<li><a href="#vce_log_gettime_normal">vce_log_gettime_normal</a></li>
<li><a href="#vce_log_gettime_short">vce_log_gettime_short</a></li>
<li><a href="#vce_log_init">vce_log_init</a></li>
<li><a href="#vce_log_parse">vce_log_parse</a></li>
<li><a href="#vce_log_print">vce_log_print</a></li>
<li><a href="#vce_log_set_gettime_func">vce_log_set_gettime_func</a></li>
<li><a href="#vce_log_set_type_mask">vce_log_set_type_mask</a></li>
<li><a href="#vce_log_set_type_mask_by_name">vce_log_set_type_mask_by_name</a></li>
<li><a href="#vce_log_vprint">vce_log_vprint</a></li>
<li><a href="#vce_logwriter_connect">vce_logwriter_connect</a></li>
<li><a href="#vce_logwriter_init">vce_logwriter_init</a></li>
<li><a href="#vce_logwriter_poll">vce_logwriter_poll</a></li>
<li><a href="#vce_logwriter_printf">vce_logwriter_printf</a></li>
<li><a href="#vce_logwriter_vprintf">vce_logwriter_vprintf</a></li>
<li><a href="#vce_mainloop">vce_mainloop</a></li>
<li><a href="#vce_make_binary_array_from_hex">vce_make_binary_array_from_hex</a></li>
<li><a href="#vce_make_binary_array_from_line">vce_make_binary_array_from_line</a></li>
<li><a href="#vce_make_hex_from_binary_array">vce_make_hex_from_binary_array</a></li>
<li><a href="#vce_make_hex_text_from_buffer">vce_make_hex_text_from_buffer</a></li>
<li><a href="#vce_makecstr">vce_makecstr</a></li>
<li><a href="#vce_monitor_client_add">vce_monitor_client_add</a></li>
<li><a href="#vce_monitor_client_call">vce_monitor_client_call</a></li>
<li><a href="#vce_monitor_client_callable">vce_monitor_client_callable</a></li>
<li><a href="#vce_monitor_client_connect">vce_monitor_client_connect</a></li>
<li><a href="#vce_monitor_client_connected">vce_monitor_client_connected</a></li>
<li><a href="#vce_monitor_client_delete">vce_monitor_client_delete</a></li>
<li><a href="#vce_monitor_client_disable">vce_monitor_client_disable</a></li>
<li><a href="#vce_monitor_client_disconnect">vce_monitor_client_disconnect</a></li>
<li><a href="#vce_monitor_client_enable">vce_monitor_client_enable</a></li>
<li><a href="#vce_monitor_client_set_replywatcher">vce_monitor_client_set_replywatcher</a></li>
<li><a href="#vce_monitor_ent_init">vce_monitor_ent_init</a></li>
<li><a href="#vce_monitor_server_add_command">vce_monitor_server_add_command</a></li>
<li><a href="#vce_monitor_server_add_stantdard_commands">vce_monitor_server_add_stantdard_commands</a></li>
<li><a href="#vce_monitor_server_disable">vce_monitor_server_disable</a></li>
<li><a href="#vce_monitor_server_enable">vce_monitor_server_enable</a></li>
<li><a href="#vce_monitor_server_reply">vce_monitor_server_reply</a></li>
<li><a href="#vce_profiler_cleanup">vce_profiler_cleanup</a></li>
<li><a href="#vce_profiler_in">vce_profiler_in</a></li>
<li><a href="#vce_profiler_init">vce_profiler_init</a></li>
<li><a href="#vce_profiler_out">vce_profiler_out</a></li>
<li><a href="#vce_profiler_save_stats">vce_profiler_save_stats</a></li>
<li><a href="#vce_protocol_acceptwatcher_deny">vce_protocol_acceptwatcher_deny</a></li>
<li><a href="#vce_protocol_acceptwatcher_noop">vce_protocol_acceptwatcher_noop</a></li>
<li><a href="#vce_protocol_acceptwatcher_vec0">vce_protocol_acceptwatcher_vec0</a></li>
<li><a href="#vce_protocol_closewatcher_noop">vce_protocol_closewatcher_noop</a></li>
<li><a href="#vce_protocol_closewatcher_vec0">vce_protocol_closewatcher_vec0</a></li>
<li><a href="#vce_protocol_parser_bin16">vce_protocol_parser_bin16</a></li>
<li><a href="#vce_protocol_parser_bin32">vce_protocol_parser_bin32</a></li>
<li><a href="#vce_protocol_parser_text">vce_protocol_parser_text</a></li>
<li><a href="#vce_protocol_parser_through">vce_protocol_parser_through</a></li>
<li><a href="#vce_protocol_parser_vec0">vce_protocol_parser_vec0</a></li>
<li><a href="#vce_protocol_parser_vecmain_client">vce_protocol_parser_vecmain_client</a></li>
<li><a href="#vce_protocol_parser_vecmain_server">vce_protocol_parser_vecmain_server</a></li>
<li><a href="#vce_protocol_pcallback_dump">vce_protocol_pcallback_dump</a></li>
<li><a href="#vce_protocol_pcallback_echo_bin16">vce_protocol_pcallback_echo_bin16</a></li>
<li><a href="#vce_protocol_pcallback_echo_text">vce_protocol_pcallback_echo_text</a></li>
<li><a href="#vce_protocol_pcallback_noop">vce_protocol_pcallback_noop</a></li>
<li><a href="#vce_protocol_unparser_bin16">vce_protocol_unparser_bin16</a></li>
<li><a href="#vce_protocol_unparser_bin32">vce_protocol_unparser_bin32</a></li>
<li><a href="#vce_protocol_unparser_text">vce_protocol_unparser_text</a></li>
<li><a href="#vce_protocol_unparser_through">vce_protocol_unparser_through</a></li>
<li><a href="#vce_read_plain_text_file">vce_read_plain_text_file</a></li>
<li><a href="#vce_read_simple_config_file">vce_read_simple_config_file</a></li>
<li><a href="#vce_replace_malloc_funcs">vce_replace_malloc_funcs</a></li>
<li><a href="#vce_save_statlog">vce_save_statlog</a></li>
<li><a href="#vce_scandir">vce_scandir</a></li>
<li><a href="#vce_set_heartbeat_wait_flag">vce_set_heartbeat_wait_flag</a></li>
<li><a href="#vce_set_internal_timer">vce_set_internal_timer</a></li>
<li><a href="#vce_set_mainloop_callback">vce_set_mainloop_callback</a></li>
<li><a href="#vce_set_read_write_log_mode">vce_set_read_write_log_mode</a></li>
<li><a href="#vce_set_socket_library_ok">vce_set_socket_library_ok</a></li>
<li><a href="#vce_set_verbose_mode">vce_set_verbose_mode</a></li>
<li><a href="#vce_sha1_buffer_checksum">vce_sha1_buffer_checksum</a></li>
<li><a href="#vce_sha1_file_checksum">vce_sha1_file_checksum</a></li>
<li><a href="#vce_show_array_usage">vce_show_array_usage</a></li>
<li><a href="#vce_snprintf">vce_snprintf</a></li>
<li><a href="#vce_strcmptail">vce_strcmptail</a></li>
<li><a href="#vce_strerror">vce_strerror</a></li>
<li><a href="#vce_strerror_close_reason">vce_strerror_close_reason</a></li>
<li><a href="#vce_strlenmax">vce_strlenmax</a></li>
<li><a href="#vce_strncat">vce_strncat</a></li>
<li><a href="#vce_strncpy">vce_strncpy</a></li>
<li><a href="#vce_switchcontext_cleanup">vce_switchcontext_cleanup</a></li>
<li><a href="#vce_switchcontext_create">vce_switchcontext_create</a></li>
<li><a href="#vce_switchtable_read_from_file">vce_switchtable_read_from_file</a></li>
<li><a href="#vce_switchtable_show">vce_switchtable_show</a></li>
<li><a href="#vce_taskcontext_cleanup">vce_taskcontext_cleanup</a></li>
<li><a href="#vce_taskcontext_create">vce_taskcontext_create</a></li>
<li><a href="#vce_taskcontext_get_elapsed_time">vce_taskcontext_get_elapsed_time</a></li>
<li><a href="#vce_taskcontext_get_id">vce_taskcontext_get_id</a></li>
<li><a href="#vce_taskcontext_get_workmem">vce_taskcontext_get_workmem</a></li>
<li><a href="#vce_taskgroup_cleanup">vce_taskgroup_cleanup</a></li>
<li><a href="#vce_taskgroup_create">vce_taskgroup_create</a></li>
<li><a href="#vce_taskgroup_get_stat">vce_taskgroup_get_stat</a></li>
<li><a href="#vce_taskgroup_set_scan_log_mode">vce_taskgroup_set_scan_log_mode</a></li>
<li><a href="#vce_tcpcontext_add_circ_ipv4_filter">vce_tcpcontext_add_circ_ipv4_filter</a></li>
<li><a href="#vce_tcpcontext_add_ipv4_filter">vce_tcpcontext_add_ipv4_filter</a></li>
<li><a href="#vce_tcpcontext_circ_iterate">vce_tcpcontext_circ_iterate</a></li>
<li><a href="#vce_tcpcontext_cleanup">vce_tcpcontext_cleanup</a></li>
<li><a href="#vce_tcpcontext_clear_circ_ipv4_filter">vce_tcpcontext_clear_circ_ipv4_filter</a></li>
<li><a href="#vce_tcpcontext_clear_conn_ipv4_filter">vce_tcpcontext_clear_conn_ipv4_filter</a></li>
<li><a href="#vce_tcpcontext_conn_iterate">vce_tcpcontext_conn_iterate</a></li>
<li><a href="#vce_tcpcontext_connect">vce_tcpcontext_connect</a></li>
<li><a href="#vce_tcpcontext_count_connections">vce_tcpcontext_count_connections</a></li>
<li><a href="#vce_tcpcontext_create">vce_tcpcontext_create</a></li>
<li><a href="#vce_tcpcontext_delete_circ_ipv4_filter">vce_tcpcontext_delete_circ_ipv4_filter</a></li>
<li><a href="#vce_tcpcontext_delete_conn_ipv4_filter">vce_tcpcontext_delete_conn_ipv4_filter</a></li>
<li><a href="#vce_tcpcontext_enable_accept">vce_tcpcontext_enable_accept</a></li>
<li><a href="#vce_tcpcontext_get_all_circuit">vce_tcpcontext_get_all_circuit</a></li>
<li><a href="#vce_tcpcontext_get_all_connection">vce_tcpcontext_get_all_connection</a></li>
<li><a href="#vce_tcpcontext_get_stat">vce_tcpcontext_get_stat</a></li>
<li><a href="#vce_tcpcontext_is_circ_mode">vce_tcpcontext_is_circ_mode</a></li>
<li><a href="#vce_tcpcontext_protocol_set_maxlength">vce_tcpcontext_protocol_set_maxlength</a></li>
<li><a href="#vce_tcpcontext_reset_compress">vce_tcpcontext_reset_compress</a></li>
<li><a href="#vce_tcpcontext_set_accept_max">vce_tcpcontext_set_accept_max</a></li>
<li><a href="#vce_tcpcontext_set_circ_acceptwatcher">vce_tcpcontext_set_circ_acceptwatcher</a></li>
<li><a href="#vce_tcpcontext_set_circ_closewatcher">vce_tcpcontext_set_circ_closewatcher</a></li>
<li><a href="#vce_tcpcontext_set_circ_finalizer">vce_tcpcontext_set_circ_finalizer</a></li>
<li><a href="#vce_tcpcontext_set_circ_hiwater_acceptwatcher">vce_tcpcontext_set_circ_hiwater_acceptwatcher</a></li>
<li><a href="#vce_tcpcontext_set_circ_parser">vce_tcpcontext_set_circ_parser</a></li>
<li><a href="#vce_tcpcontext_set_circ_switchresultwatcher">vce_tcpcontext_set_circ_switchresultwatcher</a></li>
<li><a href="#vce_tcpcontext_set_circ_switchwatcher">vce_tcpcontext_set_circ_switchwatcher</a></li>
<li><a href="#vce_tcpcontext_set_compress">vce_tcpcontext_set_compress</a></li>
<li><a href="#vce_tcpcontext_set_conn_acceptwatcher">vce_tcpcontext_set_conn_acceptwatcher</a></li>
<li><a href="#vce_tcpcontext_set_conn_call_parser_per_heartbeat">vce_tcpcontext_set_conn_call_parser_per_heartbeat</a></li>
<li><a href="#vce_tcpcontext_set_conn_closewatcher">vce_tcpcontext_set_conn_closewatcher</a></li>
<li><a href="#vce_tcpcontext_set_conn_finalizer">vce_tcpcontext_set_conn_finalizer</a></li>
<li><a href="#vce_tcpcontext_set_conn_hiwater_acceptwatcher">vce_tcpcontext_set_conn_hiwater_acceptwatcher</a></li>
<li><a href="#vce_tcpcontext_set_conn_kickip_array">vce_tcpcontext_set_conn_kickip_array</a></li>
<li><a href="#vce_tcpcontext_set_conn_parser">vce_tcpcontext_set_conn_parser</a></li>
<li><a href="#vce_tcpcontext_set_conn_safety_read">vce_tcpcontext_set_conn_safety_read</a></li>
<li><a href="#vce_tcpcontext_set_equal_io_splitrate">vce_tcpcontext_set_equal_io_splitrate</a></li>
<li><a href="#vce_tcpcontext_set_read_delay">vce_tcpcontext_set_read_delay</a></li>
<li><a href="#vce_tcpcontext_timeout_control">vce_tcpcontext_timeout_control</a></li>
<li><a href="#vce_tcpcontext_use_filter_file">vce_tcpcontext_use_filter_file</a></li>
<li><a href="#vce_text_cmpnocase">vce_text_cmpnocase</a></li>
<li><a href="#vce_text_hashpjw">vce_text_hashpjw</a></li>
<li><a href="#vce_text_split_index">vce_text_split_index</a></li>
<li><a href="#vce_text_split_index_get_int">vce_text_split_index_get_int</a></li>
<li><a href="#vce_text_split_index_get_string">vce_text_split_index_get_string</a></li>
<li><a href="#vce_update_int2_search">vce_update_int2_search</a></li>
<li><a href="#vce_update_int4_search">vce_update_int4_search</a></li>
<li><a href="#vce_update_int_search">vce_update_int_search</a></li>
<li><a href="#vce_update_string_search">vce_update_string_search</a></li>
<li><a href="#vce_update_vstring_search">vce_update_vstring_search</a></li>
<li><a href="#vce_utime_diff">vce_utime_diff</a></li>
<li><a href="#vce_vec_init_mainserv">vce_vec_init_mainserv</a></li>
<li><a href="#vce_vec_setup_linkage">vce_vec_setup_linkage</a></li>
<li><a href="#vce_vecprotocol_acceptwatcher_deny">vce_vecprotocol_acceptwatcher_deny</a></li>
<li><a href="#vce_vecprotocol_acceptwatcher_noop">vce_vecprotocol_acceptwatcher_noop</a></li>
<li><a href="#vce_vecprotocol_closewatcher_noop">vce_vecprotocol_closewatcher_noop</a></li>
<li><a href="#vce_vecprotocol_parser_bin16">vce_vecprotocol_parser_bin16</a></li>
<li><a href="#vce_vecprotocol_parser_bin32">vce_vecprotocol_parser_bin32</a></li>
<li><a href="#vce_vecprotocol_parser_text">vce_vecprotocol_parser_text</a></li>
<li><a href="#vce_vecprotocol_parser_through">vce_vecprotocol_parser_through</a></li>
<li><a href="#vce_vecprotocol_pcallback_echo_bin16">vce_vecprotocol_pcallback_echo_bin16</a></li>
<li><a href="#vce_vecprotocol_pcallback_echo_text">vce_vecprotocol_pcallback_echo_text</a></li>
<li><a href="#vce_vecprotocol_unparser_bin16">vce_vecprotocol_unparser_bin16</a></li>
<li><a href="#vce_vecprotocol_unparser_bin32">vce_vecprotocol_unparser_bin32</a></li>
<li><a href="#vce_vecprotocol_unparser_text">vce_vecprotocol_unparser_text</a></li>
<li><a href="#vce_vecprotocol_unparser_through">vce_vecprotocol_unparser_through</a></li>
<li><a href="#vce_verrout">vce_verrout</a></li>
</ol>
<h2>名前順のカテゴリ別もくじ</h2>
<!-- make_categoryindex -->
<a name="analyzer"></a>
<h3>analyzer</h3>
<p>analyzer カテゴリの関数群は，
gen.rbによって生成されたプロトコルの送信、受信部分にラップすることで
各プロトコルの送信したbyte数、回数、送信に失敗したbyte数、回数などをチェックすることが
できる。
</p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_analyzer_analyze">vce_analyzer_analyze</a><BR>
<a href="#vce_analyzer_clear">vce_analyzer_clear</a><BR>
<a href="#vce_analyzer_get_state_string">vce_analyzer_get_state_string</a><BR>
<a href="#vce_analyzer_init">vce_analyzer_init</a><BR>
</td></tr>
</table>
<a name="array"></a>
<h3>array</h3>
<p>VCE内に配列を定義する。
配列は、構造体など任意のサイズのバッファの列として管理される。
arrayカテゴリの関数は、
「配列からの割りあて」「解放」「スキャン」を、
空き要素リストを利用することで高速に行なうために整備されている。
有限個の資源を割りあてたり解放したりを高速に行なうことは、
サーバプログラムに限らず多いが、
その部分を根本的に高速化する事を主眼に置いている。
パケットベクトライザやsearchカテゴリの関数では、
内部的にarrayカテゴリの関数を使っているが、
ユーザアプリケーションにおいても使うことができるように解放する。
</p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#ARRAY_SCAN">ARRAY_SCAN</a><BR>
<a href="#ARRAY_SCAN_TYPE">ARRAY_SCAN_TYPE</a><BR>
<a href="#vce_alloc_array_object">vce_alloc_array_object</a><BR>
<a href="#vce_array_object_inuse">vce_array_object_inuse</a><BR>
<a href="#vce_end_all_array">vce_end_all_array</a><BR>
<a href="#vce_end_array">vce_end_array</a><BR>
<a href="#vce_free_array_object">vce_free_array_object</a><BR>
<a href="#vce_free_array_object_all">vce_free_array_object_all</a><BR>
<a href="#vce_get_array_maxnum">vce_get_array_maxnum</a><BR>
<a href="#vce_get_array_member_size">vce_get_array_member_size</a><BR>
<a href="#vce_get_array_object_index">vce_get_array_object_index</a><BR>
<a href="#vce_get_array_object_last">vce_get_array_object_last</a><BR>
<a href="#vce_get_array_object_next">vce_get_array_object_next</a><BR>
<a href="#vce_get_array_object_pointer_by_index">vce_get_array_object_pointer_by_index</a><BR>
<a href="#vce_get_array_object_pointer_by_index_only_used">vce_get_array_object_pointer_by_index_only_used</a><BR>
<a href="#vce_get_array_object_top">vce_get_array_object_top</a><BR>
<a href="#vce_get_array_usenum">vce_get_array_usenum</a><BR>
<a href="#vce_if_included_in_array">vce_if_included_in_array</a><BR>
<a href="#vce_init_array">vce_init_array</a><BR>
<a href="#vce_show_array_usage">vce_show_array_usage</a><BR>
</td></tr>
</table>
<a name="bin"></a>
<h3>bin</h3>
<p>bin カテゴリの関数群は，データの pack/unpack を実装している．
データストリームに対してバイナリデータやテキストデータを
出力していく．
この関数群は通常，アプリケーションによって使われることは少ないが，
gen.rb スタブジェネレータの出力コードではこの関数群を基本的に使用している．
</p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_binary_pack">vce_binary_pack</a><BR>
<a href="#vce_binary_pop_nb_i1">vce_binary_pop_nb_i1</a><BR>
<a href="#vce_binary_pop_nb_i2">vce_binary_pop_nb_i2</a><BR>
<a href="#vce_binary_pop_nb_i4">vce_binary_pop_nb_i4</a><BR>
<a href="#vce_binary_pop_nb_i8">vce_binary_pop_nb_i8</a><BR>
<a href="#vce_binary_pop_nb_ia1">vce_binary_pop_nb_ia1</a><BR>
<a href="#vce_binary_pop_nb_ia2">vce_binary_pop_nb_ia2</a><BR>
<a href="#vce_binary_pop_nb_ia4">vce_binary_pop_nb_ia4</a><BR>
<a href="#vce_binary_pop_nb_ia8">vce_binary_pop_nb_ia8</a><BR>
<a href="#vce_binary_pop_nb_stra">vce_binary_pop_nb_stra</a><BR>
<a href="#vce_binary_push_nb_i1">vce_binary_push_nb_i1</a><BR>
<a href="#vce_binary_push_nb_i2">vce_binary_push_nb_i2</a><BR>
<a href="#vce_binary_push_nb_i4">vce_binary_push_nb_i4</a><BR>
<a href="#vce_binary_push_nb_i8">vce_binary_push_nb_i8</a><BR>
<a href="#vce_binary_push_nb_ia1">vce_binary_push_nb_ia1</a><BR>
<a href="#vce_binary_push_nb_ia2">vce_binary_push_nb_ia2</a><BR>
<a href="#vce_binary_push_nb_ia4">vce_binary_push_nb_ia4</a><BR>
<a href="#vce_binary_push_nb_ia8">vce_binary_push_nb_ia8</a><BR>
<a href="#vce_binary_push_nb_stra">vce_binary_push_nb_stra</a><BR>
<a href="#vce_binary_unpack">vce_binary_unpack</a><BR>
</td></tr>
</table>
<a name="core"></a>
<h3>core</h3>
<p>coreカテゴリに含まれる関数群は、
VCEのライブラリを駆動するために必要な、
基本的な関数の集まりである。
ループを制御したり、VCE自体の初期化や解放を行なう。
Win32 環境においては、
vce_initialize 関数では、 Winsockの初期化もおこなう。
vce_errout_?? 関数では、VCEアプリケーションのログ出力の操作を行なう。
</p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_conn_set_delay">vce_conn_set_delay</a><BR>
<a href="#vce_errout">vce_errout</a><BR>
<a href="#vce_errout0">vce_errout0</a><BR>
<a href="#vce_errout0_v">vce_errout0_v</a><BR>
<a href="#vce_errout_config">vce_errout_config</a><BR>
<a href="#vce_errout_set_another">vce_errout_set_another</a><BR>
<a href="#vce_errout_v">vce_errout_v</a><BR>
<a href="#vce_finalize">vce_finalize</a><BR>
<a href="#vce_get_version">vce_get_version</a><BR>
<a href="#vce_heartbeat">vce_heartbeat</a><BR>
<a href="#vce_init_limit_t">vce_init_limit_t</a><BR>
<a href="#vce_initialize">vce_initialize</a><BR>
<a href="#vce_initialize_limited">vce_initialize_limited</a><BR>
<a href="#vce_limit_clear">vce_limit_clear</a><BR>
<a href="#vce_mainloop">vce_mainloop</a><BR>
<a href="#vce_set_heartbeat_wait_flag">vce_set_heartbeat_wait_flag</a><BR>
<a href="#vce_set_mainloop_callback">vce_set_mainloop_callback</a><BR>
<a href="#vce_set_read_write_log_mode">vce_set_read_write_log_mode</a><BR>
<a href="#vce_set_socket_library_ok">vce_set_socket_library_ok</a><BR>
<a href="#vce_set_verbose_mode">vce_set_verbose_mode</a><BR>
<a href="#vce_verrout">vce_verrout</a><BR>
</td></tr>
</table>
<a name="err"></a>
<h3>err</h3>
<p>VCE内部のエラーコードに関する処理をする関数群。
基本的に vce_get_last_error してから その返り値を vce_strerror する。
</p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_get_last_error">vce_get_last_error</a><BR>
<a href="#vce_strerror">vce_strerror</a><BR>
<a href="#vce_strerror_close_reason">vce_strerror_close_reason</a><BR>
</td></tr>
</table>
<a name="log"></a>
<h3>log</h3>
<p>logカテゴリに含まれる関数群は、
VCEログフォーマットに基づいたログの出力のための関数の集まりである。
このAPIを使用して出力されたログは、VCE Admin Tool を使用することで
統合的に検索、保存ができる。
VCEログフォーマットについては、<a href="monitor.html">「VCEモニタリング」</a>を参照。
</p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_get_netstat_string">vce_get_netstat_string</a><BR>
<a href="#vce_get_stat">vce_get_stat</a><BR>
<a href="#vce_log_add_monitor_command">vce_log_add_monitor_command</a><BR>
<a href="#vce_log_add_type">vce_log_add_type</a><BR>
<a href="#vce_log_get_types">vce_log_get_types</a><BR>
<a href="#vce_log_gettime_long">vce_log_gettime_long</a><BR>
<a href="#vce_log_gettime_normal">vce_log_gettime_normal</a><BR>
<a href="#vce_log_gettime_short">vce_log_gettime_short</a><BR>
<a href="#vce_log_init">vce_log_init</a><BR>
<a href="#vce_log_parse">vce_log_parse</a><BR>
<a href="#vce_log_print">vce_log_print</a><BR>
<a href="#vce_log_set_gettime_func">vce_log_set_gettime_func</a><BR>
<a href="#vce_log_set_type_mask">vce_log_set_type_mask</a><BR>
<a href="#vce_log_set_type_mask_by_name">vce_log_set_type_mask_by_name</a><BR>
<a href="#vce_log_vprint">vce_log_vprint</a><BR>
<a href="#vce_save_statlog">vce_save_statlog</a><BR>
</td></tr>
</table>
<a name="logwriter"></a>
<h3>logwriter</h3>
<p>logwriter カテゴリに含まれる関数群は、
ログを収集するリモートサーバ(rsv)にログを転送するための関数の集まりである。
転送するログは、VCEログフォーマットに基いている。
モニター機能やログフォーマットに関する詳細については、
<a href="monitor.html">「VCEモニタリング」</a>を参照。
</p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_logwriter_connect">vce_logwriter_connect</a><BR>
<a href="#vce_logwriter_init">vce_logwriter_init</a><BR>
<a href="#vce_logwriter_poll">vce_logwriter_poll</a><BR>
<a href="#vce_logwriter_printf">vce_logwriter_printf</a><BR>
<a href="#vce_logwriter_vprintf">vce_logwriter_vprintf</a><BR>
</td></tr>
</table>
<a name="monitor"></a>
<h3>monitor</h3>
<p>monitor カテゴリの関数群は，
常時稼働するサーバープロセスをリモートから監視，
操作するための単純なAPIを提供する．
モニター用関数群は大きくわけてサーバー用APIとクライアント用APIに
わかれていて，
監視されるプロセスではサーバー側(vce_monitor_server_???)関数を用い，
監視するプロセスではクライアント側(vce_monitor_client_???)関数
を用いることになる．
つまり，監視する側から監視される側に対してTCPのセッションを張って
情報を取得する構造をもっている．
監視や操作はセキュリティを保つことが必要であるため，
暗号化はもちろん，パスワードによる認証もサポートしている．
機能や文字列フォーマットに関する詳細については，
<a href="monitor.html">「VCEモニタリング」</a>を参照．
</p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_monitor_client_add">vce_monitor_client_add</a><BR>
<a href="#vce_monitor_client_call">vce_monitor_client_call</a><BR>
<a href="#vce_monitor_client_callable">vce_monitor_client_callable</a><BR>
<a href="#vce_monitor_client_connect">vce_monitor_client_connect</a><BR>
<a href="#vce_monitor_client_connected">vce_monitor_client_connected</a><BR>
<a href="#vce_monitor_client_delete">vce_monitor_client_delete</a><BR>
<a href="#vce_monitor_client_disable">vce_monitor_client_disable</a><BR>
<a href="#vce_monitor_client_disconnect">vce_monitor_client_disconnect</a><BR>
<a href="#vce_monitor_client_enable">vce_monitor_client_enable</a><BR>
<a href="#vce_monitor_client_set_replywatcher">vce_monitor_client_set_replywatcher</a><BR>
<a href="#vce_monitor_ent_init">vce_monitor_ent_init</a><BR>
<a href="#vce_monitor_server_add_command">vce_monitor_server_add_command</a><BR>
<a href="#vce_monitor_server_add_stantdard_commands">vce_monitor_server_add_stantdard_commands</a><BR>
<a href="#vce_monitor_server_disable">vce_monitor_server_disable</a><BR>
<a href="#vce_monitor_server_enable">vce_monitor_server_enable</a><BR>
<a href="#vce_monitor_server_reply">vce_monitor_server_reply</a><BR>
</td></tr>
</table>
<a name="parser"></a>
<h3>parser</h3>
<p>parserカテゴリに属する関数群は、
conn_t コネクションまたは circ_t コネクションからの入力を
レコード単位に分割し、分割されたレコードごとにコールバック関数を呼びだす。
VCE ではこのようにレコード単位のプロトコル処理を基本としている。
</p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_protocol_parser_bin16">vce_protocol_parser_bin16</a><BR>
<a href="#vce_protocol_parser_bin32">vce_protocol_parser_bin32</a><BR>
<a href="#vce_protocol_parser_text">vce_protocol_parser_text</a><BR>
<a href="#vce_protocol_parser_through">vce_protocol_parser_through</a><BR>
<a href="#vce_protocol_parser_vec0">vce_protocol_parser_vec0</a><BR>
<a href="#vce_protocol_parser_vecmain_client">vce_protocol_parser_vecmain_client</a><BR>
<a href="#vce_protocol_parser_vecmain_server">vce_protocol_parser_vecmain_server</a><BR>
<a href="#vce_protocol_unparser_bin16">vce_protocol_unparser_bin16</a><BR>
<a href="#vce_protocol_unparser_bin32">vce_protocol_unparser_bin32</a><BR>
<a href="#vce_protocol_unparser_text">vce_protocol_unparser_text</a><BR>
<a href="#vce_protocol_unparser_through">vce_protocol_unparser_through</a><BR>
<a href="#vce_vecprotocol_parser_bin16">vce_vecprotocol_parser_bin16</a><BR>
<a href="#vce_vecprotocol_parser_bin32">vce_vecprotocol_parser_bin32</a><BR>
<a href="#vce_vecprotocol_parser_text">vce_vecprotocol_parser_text</a><BR>
<a href="#vce_vecprotocol_parser_through">vce_vecprotocol_parser_through</a><BR>
<a href="#vce_vecprotocol_unparser_bin16">vce_vecprotocol_unparser_bin16</a><BR>
<a href="#vce_vecprotocol_unparser_bin32">vce_vecprotocol_unparser_bin32</a><BR>
<a href="#vce_vecprotocol_unparser_text">vce_vecprotocol_unparser_text</a><BR>
<a href="#vce_vecprotocol_unparser_through">vce_vecprotocol_unparser_through</a><BR>
</td></tr>
</table>
<a name="pcallback"></a>
<h3>pcallback</h3>
<p>pcallback カテゴリに属する関数群は、
parser によってレコード単位に分割されたデータを処理するためのコールバック
関数である。通常のアプリケーションでは、
このコールバック関数の内容はアプリケーション開発者によって定義されるが、
エコーやダンプなど基本的な内容のコールバック関数はあらかじめ VCE
に内蔵されているため、デバッグの目的に使用することができる。
pcallback 関数には、 conn_t コネクション用のものと circ_t コネクション用
のものとがある。
</p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_protocol_pcallback_dump">vce_protocol_pcallback_dump</a><BR>
<a href="#vce_protocol_pcallback_echo_bin16">vce_protocol_pcallback_echo_bin16</a><BR>
<a href="#vce_protocol_pcallback_echo_text">vce_protocol_pcallback_echo_text</a><BR>
<a href="#vce_protocol_pcallback_noop">vce_protocol_pcallback_noop</a><BR>
<a href="#vce_vecprotocol_pcallback_echo_bin16">vce_vecprotocol_pcallback_echo_bin16</a><BR>
<a href="#vce_vecprotocol_pcallback_echo_text">vce_vecprotocol_pcallback_echo_text</a><BR>
</td></tr>
</table>
<a name="profiler"></a>
<h3>profiler</h3>
<p>profiler カテゴリの関数群は，動的に動作設定と状態取得が可能な，
プロファイリング(動作性能検査)ツールを提供する．
マイクロ秒単位のタイマを必要とするため，
現在では linux でのみサポートされている．
内部的に gettimeofday を使用するため，プログラムの動作速度は，
若干低下する．
</p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_profiler_cleanup">vce_profiler_cleanup</a><BR>
<a href="#vce_profiler_in">vce_profiler_in</a><BR>
<a href="#vce_profiler_init">vce_profiler_init</a><BR>
<a href="#vce_profiler_out">vce_profiler_out</a><BR>
<a href="#vce_profiler_save_stats">vce_profiler_save_stats</a><BR>
</td></tr>
</table>
<a name="search"></a>
<h3>search</h3>
<p>searchカテゴリの関数群は、「オンメモリの超高速検索」を実装している。
すべて、「キー」から「値へのポインタ」を引きだすという感じで使う。
キーには 32bit int, 2個の32bit int, 16文字までのstring の3種類を
指定することができる。<BR>
searchカテゴリの関数は汎用性のかわりに高速性が必要な場合に使うべきである。
設定次第では100万エントリの中からの検索を数マイクロ秒で実行することができる。
VCEの内部では、パケットベクトライザのIPアドレスからソケット番号への変換
(sockhash)ルーチン内部で使用している。
search関数群の性能が最大になるのは、数万の要素の中から検索する時である。<BR>
値へのポインタは、配列の要素へのポインタとするのが最も使いやすいだろう。
配列の要素へのポインタは、array カテゴリの関数を用いれば簡単に作ることが
できるので、 arrayと search はよく併用される。
<BR><BR>
検索のアルゴリズムは、
「有限数のハッシュテーブル」を用いて検索のスキャンループの回数を減らす
方式である。
単純に考えると、N要素の値を保存している場合、
普通にキーから見つけだすには最大N回のループが必要だが、
M要素のハッシュテーブルがあれば、ループ回数がM分の1となり検索が高速化される。
よってたとえば100万個の値が保存されているデータベースの場合は、
10万程度のハッシュサイズにしておくと平均ループ回数が10となり、
性能は10万倍に向上する(ハッシュのサイズ倍になるとしてよい。)
<BR><BR>
またvce_init_*_search 関数はインデクスを再利用する．
つまり，検索エンジンの生成と解放を繰りかえすと，
同じindexが振られることがある．
</p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_cleanup_all_search_engine">vce_cleanup_all_search_engine</a><BR>
<a href="#vce_cleanup_search_engine">vce_cleanup_search_engine</a><BR>
<a href="#vce_delete_int2_search">vce_delete_int2_search</a><BR>
<a href="#vce_delete_int4_search">vce_delete_int4_search</a><BR>
<a href="#vce_delete_int_search">vce_delete_int_search</a><BR>
<a href="#vce_delete_string_search">vce_delete_string_search</a><BR>
<a href="#vce_delete_vstring_search">vce_delete_vstring_search</a><BR>
<a href="#vce_get_int2_or_search">vce_get_int2_or_search</a><BR>
<a href="#vce_get_int2_search">vce_get_int2_search</a><BR>
<a href="#vce_get_int4_or_search">vce_get_int4_or_search</a><BR>
<a href="#vce_get_int4_search">vce_get_int4_search</a><BR>
<a href="#vce_get_int_search">vce_get_int_search</a><BR>
<a href="#vce_get_search_usenum">vce_get_search_usenum</a><BR>
<a href="#vce_get_string_search">vce_get_string_search</a><BR>
<a href="#vce_get_vstring_search">vce_get_vstring_search</a><BR>
<a href="#vce_init_int2_search">vce_init_int2_search</a><BR>
<a href="#vce_init_int4_search">vce_init_int4_search</a><BR>
<a href="#vce_init_int_search">vce_init_int_search</a><BR>
<a href="#vce_init_string_search">vce_init_string_search</a><BR>
<a href="#vce_init_vstring_search">vce_init_vstring_search</a><BR>
<a href="#vce_iterate_int2_search">vce_iterate_int2_search</a><BR>
<a href="#vce_iterate_int4_search">vce_iterate_int4_search</a><BR>
<a href="#vce_update_int2_search">vce_update_int2_search</a><BR>
<a href="#vce_update_int4_search">vce_update_int4_search</a><BR>
<a href="#vce_update_int_search">vce_update_int_search</a><BR>
<a href="#vce_update_string_search">vce_update_string_search</a><BR>
<a href="#vce_update_vstring_search">vce_update_vstring_search</a><BR>
</td></tr>
</table>
<a name="task"></a>
<h3>task</h3>
<p>task カテゴリの関数群は、コールバックを基本に動作する、
プロセス内の擬似タスクを実現する。マイクロ秒(実際には vce_heartbeat の
呼びだし頻度に影響される)単位のインターバルと、
タイマーのチェック解像度を調節してサーバの負荷を自由にチューニングできる。
VCE 自体によっても使われる他、アプリケーションからも、
NPC を一定間隔で移動させたり、
タイマー的な処理を繰りかえさせたりといった処理に使うことができる。
コーディングは、まず vce_taskgroup_create を呼びだしてタスクグループを
作成する。次に vce_taskcontext_create 関数により、
各グループに属するタスクを生成する。
グループ単位でタイマーチェックの解像度を設定できる。
</p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_taskcontext_cleanup">vce_taskcontext_cleanup</a><BR>
<a href="#vce_taskcontext_create">vce_taskcontext_create</a><BR>
<a href="#vce_taskcontext_get_elapsed_time">vce_taskcontext_get_elapsed_time</a><BR>
<a href="#vce_taskcontext_get_id">vce_taskcontext_get_id</a><BR>
<a href="#vce_taskcontext_get_workmem">vce_taskcontext_get_workmem</a><BR>
<a href="#vce_taskgroup_cleanup">vce_taskgroup_cleanup</a><BR>
<a href="#vce_taskgroup_create">vce_taskgroup_create</a><BR>
<a href="#vce_taskgroup_get_stat">vce_taskgroup_get_stat</a><BR>
<a href="#vce_taskgroup_set_scan_log_mode">vce_taskgroup_set_scan_log_mode</a><BR>
</td></tr>
</table>
<a name="tcp"></a>
<h3>tcp</h3>
<p>tcpカテゴリでは、tcpcontext_t 型の操作を通して、
VCEの主ターゲットプロトコルであるTCPに関する基本機能を実装している。
Blowfish/Twofish/Rijndael を用いた暗号化や、
Diffie-Hellmanによる鍵交換、
パケットベクトライザ、圧縮など、通信に必要な基本的機能の集合である。
tcpカテゴリの関数の働きを理解するには、
VCEにおける
<a href="tcpcontext.html">TCPコネクション管理システムの仕組</a>
を理解することが必要である。
</p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_circ_close">vce_circ_close</a><BR>
<a href="#vce_circ_get_index">vce_circ_get_index</a><BR>
<a href="#vce_circ_get_parent_conn">vce_circ_get_parent_conn</a><BR>
<a href="#vce_circ_get_remote_addr_string">vce_circ_get_remote_addr_string</a><BR>
<a href="#vce_circ_get_remote_ipv4_addr">vce_circ_get_remote_ipv4_addr</a><BR>
<a href="#vce_circ_get_remote_ipv4_addr_string">vce_circ_get_remote_ipv4_addr_string</a><BR>
<a href="#vce_circ_get_remote_ipv6_addr">vce_circ_get_remote_ipv6_addr</a><BR>
<a href="#vce_circ_get_remote_ipv6_addr_string">vce_circ_get_remote_ipv6_addr_string</a><BR>
<a href="#vce_circ_get_state_buffer">vce_circ_get_state_buffer</a><BR>
<a href="#vce_circ_get_struct_from_index">vce_circ_get_struct_from_index</a><BR>
<a href="#vce_circ_get_tcpcontext">vce_circ_get_tcpcontext</a><BR>
<a href="#vce_circ_is_equal">vce_circ_is_equal</a><BR>
<a href="#vce_circ_is_valid">vce_circ_is_valid</a><BR>
<a href="#vce_circ_set_timeout">vce_circ_set_timeout</a><BR>
<a href="#vce_circ_switch">vce_circ_switch</a><BR>
<a href="#vce_circ_test_sanity">vce_circ_test_sanity</a><BR>
<a href="#vce_circ_writable">vce_circ_writable</a><BR>
<a href="#vce_circ_write">vce_circ_write</a><BR>
<a href="#vce_conn_break_heartbeat">vce_conn_break_heartbeat</a><BR>
<a href="#vce_conn_clear">vce_conn_clear</a><BR>
<a href="#vce_conn_close">vce_conn_close</a><BR>
<a href="#vce_conn_close_tcpcontext_all">vce_conn_close_tcpcontext_all</a><BR>
<a href="#vce_conn_get_buffer">vce_conn_get_buffer</a><BR>
<a href="#vce_conn_get_child_circ">vce_conn_get_child_circ</a><BR>
<a href="#vce_conn_get_index">vce_conn_get_index</a><BR>
<a href="#vce_conn_get_local_addr_string">vce_conn_get_local_addr_string</a><BR>
<a href="#vce_conn_get_local_ipv4_addr">vce_conn_get_local_ipv4_addr</a><BR>
<a href="#vce_conn_get_local_ipv4_addr_string">vce_conn_get_local_ipv4_addr_string</a><BR>
<a href="#vce_conn_get_local_ipv6_addr">vce_conn_get_local_ipv6_addr</a><BR>
<a href="#vce_conn_get_local_ipv6_addr_string">vce_conn_get_local_ipv6_addr_string</a><BR>
<a href="#vce_conn_get_remote_addr_string">vce_conn_get_remote_addr_string</a><BR>
<a href="#vce_conn_get_remote_ipv4_addr">vce_conn_get_remote_ipv4_addr</a><BR>
<a href="#vce_conn_get_remote_ipv4_addr_string">vce_conn_get_remote_ipv4_addr_string</a><BR>
<a href="#vce_conn_get_remote_ipv6_addr">vce_conn_get_remote_ipv6_addr</a><BR>
<a href="#vce_conn_get_remote_ipv6_addr_string">vce_conn_get_remote_ipv6_addr_string</a><BR>
<a href="#vce_conn_get_stat">vce_conn_get_stat</a><BR>
<a href="#vce_conn_get_state_buffer">vce_conn_get_state_buffer</a><BR>
<a href="#vce_conn_get_struct_from_index">vce_conn_get_struct_from_index</a><BR>
<a href="#vce_conn_get_tcpcontext">vce_conn_get_tcpcontext</a><BR>
<a href="#vce_conn_is_equal">vce_conn_is_equal</a><BR>
<a href="#vce_conn_is_valid">vce_conn_is_valid</a><BR>
<a href="#vce_conn_set_parser">vce_conn_set_parser</a><BR>
<a href="#vce_conn_set_timeout">vce_conn_set_timeout</a><BR>
<a href="#vce_conn_show_stat">vce_conn_show_stat</a><BR>
<a href="#vce_conn_shrink_readbuf">vce_conn_shrink_readbuf</a><BR>
<a href="#vce_conn_writable">vce_conn_writable</a><BR>
<a href="#vce_conn_write">vce_conn_write</a><BR>
<a href="#vce_conn_writed">vce_conn_writed</a><BR>
<a href="#vce_get_tcp_packet_read_size">vce_get_tcp_packet_read_size</a><BR>
<a href="#vce_get_tcp_packet_write_size">vce_get_tcp_packet_write_size</a><BR>
<a href="#vce_switchcontext_create">vce_switchcontext_create</a><BR>
<a href="#vce_switchtable_read_from_file">vce_switchtable_read_from_file</a><BR>
<a href="#vce_switchtable_show">vce_switchtable_show</a><BR>
<a href="#vce_tcpcontext_add_circ_ipv4_filter">vce_tcpcontext_add_circ_ipv4_filter</a><BR>
<a href="#vce_tcpcontext_add_ipv4_filter">vce_tcpcontext_add_ipv4_filter</a><BR>
<a href="#vce_tcpcontext_circ_iterate">vce_tcpcontext_circ_iterate</a><BR>
<a href="#vce_tcpcontext_cleanup">vce_tcpcontext_cleanup</a><BR>
<a href="#vce_tcpcontext_clear_circ_ipv4_filter">vce_tcpcontext_clear_circ_ipv4_filter</a><BR>
<a href="#vce_tcpcontext_clear_conn_ipv4_filter">vce_tcpcontext_clear_conn_ipv4_filter</a><BR>
<a href="#vce_tcpcontext_connect">vce_tcpcontext_connect</a><BR>
<a href="#vce_tcpcontext_count_connections">vce_tcpcontext_count_connections</a><BR>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a><BR>
<a href="#vce_tcpcontext_delete_circ_ipv4_filter">vce_tcpcontext_delete_circ_ipv4_filter</a><BR>
<a href="#vce_tcpcontext_delete_conn_ipv4_filter">vce_tcpcontext_delete_conn_ipv4_filter</a><BR>
<a href="#vce_tcpcontext_enable_accept">vce_tcpcontext_enable_accept</a><BR>
<a href="#vce_tcpcontext_get_all_circuit">vce_tcpcontext_get_all_circuit</a><BR>
<a href="#vce_tcpcontext_get_all_connection">vce_tcpcontext_get_all_connection</a><BR>
<a href="#vce_tcpcontext_get_stat">vce_tcpcontext_get_stat</a><BR>
<a href="#vce_tcpcontext_is_circ_mode">vce_tcpcontext_is_circ_mode</a><BR>
<a href="#vce_tcpcontext_protocol_set_maxlength">vce_tcpcontext_protocol_set_maxlength</a><BR>
<a href="#vce_tcpcontext_reset_compress">vce_tcpcontext_reset_compress</a><BR>
<a href="#vce_tcpcontext_set_accept_max">vce_tcpcontext_set_accept_max</a><BR>
<a href="#vce_tcpcontext_set_circ_acceptwatcher">vce_tcpcontext_set_circ_acceptwatcher</a><BR>
<a href="#vce_tcpcontext_set_circ_closewatcher">vce_tcpcontext_set_circ_closewatcher</a><BR>
<a href="#vce_tcpcontext_set_circ_finalizer">vce_tcpcontext_set_circ_finalizer</a><BR>
<a href="#vce_tcpcontext_set_circ_hiwater_acceptwatcher">vce_tcpcontext_set_circ_hiwater_acceptwatcher</a><BR>
<a href="#vce_tcpcontext_set_circ_parser">vce_tcpcontext_set_circ_parser</a><BR>
<a href="#vce_tcpcontext_set_circ_switchresultwatcher">vce_tcpcontext_set_circ_switchresultwatcher</a><BR>
<a href="#vce_tcpcontext_set_circ_switchwatcher">vce_tcpcontext_set_circ_switchwatcher</a><BR>
<a href="#vce_tcpcontext_set_compress">vce_tcpcontext_set_compress</a><BR>
<a href="#vce_tcpcontext_set_conn_acceptwatcher">vce_tcpcontext_set_conn_acceptwatcher</a><BR>
<a href="#vce_tcpcontext_set_conn_call_parser_per_heartbeat">vce_tcpcontext_set_conn_call_parser_per_heartbeat</a><BR>
<a href="#vce_tcpcontext_set_conn_closewatcher">vce_tcpcontext_set_conn_closewatcher</a><BR>
<a href="#vce_tcpcontext_set_conn_finalizer">vce_tcpcontext_set_conn_finalizer</a><BR>
<a href="#vce_tcpcontext_set_conn_hiwater_acceptwatcher">vce_tcpcontext_set_conn_hiwater_acceptwatcher</a><BR>
<a href="#vce_tcpcontext_set_conn_kickip_array">vce_tcpcontext_set_conn_kickip_array</a><BR>
<a href="#vce_tcpcontext_set_conn_parser">vce_tcpcontext_set_conn_parser</a><BR>
<a href="#vce_tcpcontext_set_conn_safety_read">vce_tcpcontext_set_conn_safety_read</a><BR>
<a href="#vce_tcpcontext_set_equal_io_splitrate">vce_tcpcontext_set_equal_io_splitrate</a><BR>
<a href="#vce_tcpcontext_set_read_delay">vce_tcpcontext_set_read_delay</a><BR>
<a href="#vce_tcpcontext_timeout_control">vce_tcpcontext_timeout_control</a><BR>
<a href="#vce_tcpcontext_use_filter_file">vce_tcpcontext_use_filter_file</a><BR>
<a href="#vce_vec_init_mainserv">vce_vec_init_mainserv</a><BR>
<a href="#vce_vec_setup_linkage">vce_vec_setup_linkage</a><BR>
</td></tr>
</table>
<a name="text"></a>
<h3>text</h3>
<p>text カテゴリの関数群は、
HTTPプロトコルのヘッダや，サーバの設定ファイルなど，
複雑な構造を持たないテキストを高速に処理するためにデザインされている。
したがって，日本語文字変換などの高度な機能は含まれていない．
特に HTTP 関係の関数は，VCE を用いてHTTPサーバを作成する場合には有効である．
</p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_chop_string_destroy">vce_chop_string_destroy</a><BR>
<a href="#vce_copy_cstring">vce_copy_cstring</a><BR>
<a href="#vce_copy_cstring_upto">vce_copy_cstring_upto</a><BR>
<a href="#vce_escape_string">vce_escape_string</a><BR>
<a href="#vce_httptext_divide_header_and_content">vce_httptext_divide_header_and_content</a><BR>
<a href="#vce_httptext_get_header_info">vce_httptext_get_header_info</a><BR>
<a href="#vce_makecstr">vce_makecstr</a><BR>
<a href="#vce_snprintf">vce_snprintf</a><BR>
<a href="#vce_strcmptail">vce_strcmptail</a><BR>
<a href="#vce_strlenmax">vce_strlenmax</a><BR>
<a href="#vce_strncat">vce_strncat</a><BR>
<a href="#vce_strncpy">vce_strncpy</a><BR>
<a href="#vce_text_cmpnocase">vce_text_cmpnocase</a><BR>
<a href="#vce_text_hashpjw">vce_text_hashpjw</a><BR>
<a href="#vce_text_split_index">vce_text_split_index</a><BR>
<a href="#vce_text_split_index_get_int">vce_text_split_index_get_int</a><BR>
<a href="#vce_text_split_index_get_string">vce_text_split_index_get_string</a><BR>
</td></tr>
</table>
<a name="util"></a>
<h3>util</h3>
<p>utilカテゴリの関数群は、
VCEアプリケーションの開発をしていく時に有用である。
特に暗号化ルーチンやハッシュのルーチンを使うための関数群などが有用である．
</p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#ELEMENTOF">ELEMENTOF</a><BR>
<a href="#FREE">FREE</a><BR>
<a href="#GET_16BIT_INT">GET_16BIT_INT</a><BR>
<a href="#GET_16BIT_NATIVEINT">GET_16BIT_NATIVEINT</a><BR>
<a href="#GET_32BIT_INT">GET_32BIT_INT</a><BR>
<a href="#GET_32BIT_NATIVEINT">GET_32BIT_NATIVEINT</a><BR>
<a href="#GET_64BIT_INT">GET_64BIT_INT</a><BR>
<a href="#GET_64BIT_NATIVEINT">GET_64BIT_NATIVEINT</a><BR>
<a href="#GET_8BIT_INT">GET_8BIT_INT</a><BR>
<a href="#GET_8BIT_NATIVEINT">GET_8BIT_NATIVEINT</a><BR>
<a href="#MALLOC">MALLOC</a><BR>
<a href="#MAX">MAX</a><BR>
<a href="#MIN">MIN</a><BR>
<a href="#SET_16BIT_INT">SET_16BIT_INT</a><BR>
<a href="#SET_16BIT_NATIVEINT">SET_16BIT_NATIVEINT</a><BR>
<a href="#SET_32BIT_INT">SET_32BIT_INT</a><BR>
<a href="#SET_32BIT_NATIVEINT">SET_32BIT_NATIVEINT</a><BR>
<a href="#SET_64BIT_INT">SET_64BIT_INT</a><BR>
<a href="#SET_64BIT_NATIVEINT">SET_64BIT_NATIVEINT</a><BR>
<a href="#SET_8BIT_INT">SET_8BIT_INT</a><BR>
<a href="#SET_8BIT_NATIVEINT">SET_8BIT_NATIVEINT</a><BR>
<a href="#STRERR">STRERR</a><BR>
<a href="#vce_atoi">vce_atoi</a><BR>
<a href="#vce_decode_buffer_by_blowfish">vce_decode_buffer_by_blowfish</a><BR>
<a href="#vce_decode_buffer_by_rijndael">vce_decode_buffer_by_rijndael</a><BR>
<a href="#vce_dump_buffer">vce_dump_buffer</a><BR>
<a href="#vce_encode_buffer_by_blowfish">vce_encode_buffer_by_blowfish</a><BR>
<a href="#vce_encode_buffer_by_rijndael">vce_encode_buffer_by_rijndael</a><BR>
<a href="#vce_extract_data_from_hex_text">vce_extract_data_from_hex_text</a><BR>
<a href="#vce_get_current_utime">vce_get_current_utime</a><BR>
<a href="#vce_get_ipv4_addr_by_name">vce_get_ipv4_addr_by_name</a><BR>
<a href="#vce_make_binary_array_from_hex">vce_make_binary_array_from_hex</a><BR>
<a href="#vce_make_binary_array_from_line">vce_make_binary_array_from_line</a><BR>
<a href="#vce_make_hex_from_binary_array">vce_make_hex_from_binary_array</a><BR>
<a href="#vce_make_hex_text_from_buffer">vce_make_hex_text_from_buffer</a><BR>
<a href="#vce_read_plain_text_file">vce_read_plain_text_file</a><BR>
<a href="#vce_read_simple_config_file">vce_read_simple_config_file</a><BR>
<a href="#vce_replace_malloc_funcs">vce_replace_malloc_funcs</a><BR>
<a href="#vce_scandir">vce_scandir</a><BR>
<a href="#vce_sha1_buffer_checksum">vce_sha1_buffer_checksum</a><BR>
<a href="#vce_sha1_file_checksum">vce_sha1_file_checksum</a><BR>
<a href="#vce_utime_diff">vce_utime_diff</a><BR>
</td></tr>
</table>
<a name="watcher"></a>
<h3>watcher</h3>
<p>watcher カテゴリの関数群は、conn_t または circ_t コネクションを
新規に受けいれ(accept)したり、閉じられたりしたときにそれを検知するための
コールバック関数群である。現在は acceptwatcher と closewatcher
が存在する。
</p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_circ_set_alarmwatcher">vce_circ_set_alarmwatcher</a><BR>
<a href="#vce_conn_set_alarmwatcher">vce_conn_set_alarmwatcher</a><BR>
<a href="#vce_protocol_acceptwatcher_deny">vce_protocol_acceptwatcher_deny</a><BR>
<a href="#vce_protocol_acceptwatcher_noop">vce_protocol_acceptwatcher_noop</a><BR>
<a href="#vce_protocol_acceptwatcher_vec0">vce_protocol_acceptwatcher_vec0</a><BR>
<a href="#vce_protocol_closewatcher_noop">vce_protocol_closewatcher_noop</a><BR>
<a href="#vce_protocol_closewatcher_vec0">vce_protocol_closewatcher_vec0</a><BR>
<a href="#vce_vecprotocol_acceptwatcher_deny">vce_vecprotocol_acceptwatcher_deny</a><BR>
<a href="#vce_vecprotocol_acceptwatcher_noop">vce_vecprotocol_acceptwatcher_noop</a><BR>
<a href="#vce_vecprotocol_closewatcher_noop">vce_vecprotocol_closewatcher_noop</a><BR>
</td></tr>
</table>
<h2>全関数定義</h2>
<!-- make_funcdef start -->
<a name="ARRAY_SCAN"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
ARRAY_SCAN</th></tr>
<tr><th>概要</th><td>VCEによって管理されている配列の全使用中要素をスキャンする</td></tr>
<tr><th>カテゴリ</th><td>array</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>ARRAY_SCAN( int arraydescriptor, void* pointer )</b></td>
<tr><th>arg 1</Th><td>int arraydescriptor</td></tr>
<tr><th></th><td>VCEの管理する配列にアクセスするための識別値。
この値は、 vce_init_array の返り値を保存しておいたものが使われる。
ちょうどUNIXにおけるファイルデスクリプタと同じように扱えばよい。
</td></tr>
<tr><th>arg 2</Th><td>void *pointer</td></tr>
<tr><th></th><td>このポインター変数に配列の各要素のアドレスを代入する。
</td></tr>
<tr><th>返り値</th><td>本マクロは、関数のように使うのではなく、
ループの始まりとして使う(forのように)ために、返り値というものはない。
</td></tr>
<tr><th>詳細説明</th><td>VCEの配列管理ルーチンを使う場合に、
全要素をスキャンする処理をしたい場合がある。そのためには、
vce_get_array_object_top 関数を用いて使用中リストから先頭の要素を取りだし、
次に vce_get_array_object_next 関数を用いてNULLを返すまで処理をくりかえす。
しかしその処理は繁雑なため、本マクロが用意されている。<BR>
注意点としては、本マクロによって取りだされる配列の要素は、
「使用中」つまり、使用中リストに入っているものだけである。
配列の最大サイズが1000個であったとしても使用中のものがなければ、
ループは1回もまわらない。
</td></tr>
<tr><th>使用例</th><td><pre>
// memory_ind によって指定されている配列のすべての使用中要素に処理をする
struct client *c;
ARRAY_SCAN( memory_ind, c ){
  do_something_to_the_structure( c );
}
</pre>
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_array_object_next">vce_get_array_object_next</a>
<a href="#vce_get_array_object_top">vce_get_array_object_top</a>
<a href="#vce_init_array">vce_init_array</a>
</td></tr>
</table><br><br>
<a name="ARRAY_SCAN_TYPE"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
ARRAY_SCAN_TYPE</th></tr>
<tr><th>概要</th><td>ARRAY_SCAN を C++ で使うための変種</td></tr>
<tr><th>カテゴリ</th><td>array</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>ARRAY_SCAN_TYPE( int arraydescriptor void *pointer, typedecl )</b></td>
<tr><th>arg 1</Th><td>int arraydescriptor</td></tr>
<tr><th></th><td>VCE の配列にアクセスするための識別値
</td></tr>
<tr><th>arg 2</Th><td>void *pointer</td></tr>
<tr><th></th><td>このポインター変数に配列の各要素のアドレスを代入する。
</td></tr>
<tr><th>arg 3</Th><td> typedecl</td></tr>
<tr><th></th><td>ポインター変数の型を指定する。
</td></tr>
<tr><th>返り値</th><td>なし。 使用方法は、 ARRAY_SCANと同じ。
</td></tr>
<tr><th>詳細説明</th><td>ARRAY_SCAN は void のポインタをポインター変数 pointer に代入するが、
C++ においてはキャストが必要なためその処理がコンパイルエラーを発生する。
そのため、ARRAY_SCAN_TYPE マクロでは、
ポインタ変数の型をマクロに与えるようにしている。
</td></tr>
<tr><th>See also</th><td>
<a href="#ARRAY_SCAN">ARRAY_SCAN</a>
</td></tr>
</table><br><br>
<a name="ELEMENTOF"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
ELEMENTOF</th></tr>
<tr><th>概要</th><td>固定サイズの配列の要素数を返す(コンパイル時定数)。</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int ELEMENTOF(x)</b></td>
<tr><th>arg 1</Th><td>x</td></tr>
<tr><th></th><td>任意のC言語配列 (ポインタではない)
</td></tr>
<tr><th>返り値</th><td>配列の要素数
</td></tr>
<tr><th>詳細説明</th><td>このマクロは実際には
<pre>
( sizeof(x) / sizeof((x)[0]) ) 
</pre>
と定義されている。mallocによって割りあてた配列のサイズは
コンパイル時にサイズが確定しないため、このマクロは使用できない。
</td></tr>
<tr><th>使用例</th><td><pre>
  int hoge[]= {1,2,3,4,5};
  a = ELEMENTOF(hoge);           // a には5が入る
</pre>
</td></tr>
</table><br><br>
<a name="FREE"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
FREE</th></tr>
<tr><th>概要</th><td>MALLOC関数で割りあてたメモリ領域を解放する。</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void FREE( void *p )</b></td>
<tr><th>arg 1</Th><td>void *p</td></tr>
<tr><th></th><td>解放するメモリ領域の先頭アドレス
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>標準C言語のfree関数をwrapする関数である。
単純に、free呼びだし記録をログするだけである。
vce_set_verbose_mode を1に設定すると、ログを出力するようになる。
</td></tr>
<tr><th>See also</th><td>
<a href="#MALLOC">MALLOC</a>
<a href="#vce_set_verbose_mode">vce_set_verbose_mode</a>
</td></tr>
</table><br><br>
<a name="GET_16BIT_INT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
GET_16BIT_INT</th></tr>
<tr><th>概要</th><td>メモリ領域から16ビットの整数値を取りだす。</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>unsigned short GET_16BIT_INT( char *p )</b></td>
<tr><th>arg 1</Th><td>char *p</td></tr>
<tr><th></th><td>取りだしたい値がネットワークバイトオーダで格納されているバッファの先頭
アドレス
</td></tr>
<tr><th>返り値</th><td>結果のunsigned short値
</td></tr>
<tr><th>詳細説明</th><td>内部でntohsを使用している。主にプロトコル処理に使われるが、
より一般的な目的のためには、 bin カテゴリの関数群を使うべきである。
なお MIPS アーキテクチャ(PS2)のマシンでは、
このマクロは関数として実装されている。
</td></tr>
<tr><th>See also</th><td>
<a href="#GET_32BIT_INT">GET_32BIT_INT</a>
<a href="#GET_8BIT_INT">GET_8BIT_INT</a>
<a href="#SET_16BIT_INT">SET_16BIT_INT</a>
<a href="#SET_32BIT_INT">SET_32BIT_INT</a>
<a href="#SET_8BIT_INT">SET_8BIT_INT</a>
</td></tr>
</table><br><br>
<a name="GET_16BIT_NATIVEINT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
GET_16BIT_NATIVEINT</th></tr>
<tr><th>概要</th><td>バッファから16ビット整数値を取りだす。</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>short GET_16BIT_NATIVEINT( char *p )</b></td>
<tr><th>返り値</th><td>取りだしたshort値
</td></tr>
<tr><th>詳細説明</th><td>ntohs, htons などをつかわない、取りだしマクロである。
なお MIPS アーキテクチャ(PS2)のマシンでは、
このマクロは関数として実装されている。
</td></tr>
<tr><th>See also</th><td>
<a href="#GET_32BIT_NATIVEINT">GET_32BIT_NATIVEINT</a>
<a href="#GET_8BIT_NATIVEINT">GET_8BIT_NATIVEINT</a>
</td></tr>
</table><br><br>
<a name="GET_32BIT_INT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
GET_32BIT_INT</th></tr>
<tr><th>概要</th><td>メモリ領域から32ビット整数値を取りだすマクロ</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>unsigned int GET_32BIT_INT( char *p )</b></td>
<tr><th>arg 1</Th><td>char *p</td></tr>
<tr><th></th><td>取りだす元になるバッファの先頭アドレス
</td></tr>
<tr><th>返り値</th><td>取りだした値
</td></tr>
<tr><th>詳細説明</th><td>内部で ntohlを使用している。
このマクロはバイナリプロトコル解析用に使われるが、アプリケーションで
バイナリプロトコルを実装する場合には、このマクロではなく、
bin カテゴリの関数群を使うべきである。
なお MIPS アーキテクチャ(PS2)のマシンでは、
このマクロは関数として実装されている。
</td></tr>
<tr><th>See also</th><td>
<a href="#GET_16BIT_INT">GET_16BIT_INT</a>
<a href="#GET_8BIT_INT">GET_8BIT_INT</a>
<a href="#SET_16BIT_INT">SET_16BIT_INT</a>
<a href="#SET_32BIT_INT">SET_32BIT_INT</a>
<a href="#SET_8BIT_INT">SET_8BIT_INT</a>
</td></tr>
</table><br><br>
<a name="GET_32BIT_NATIVEINT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
GET_32BIT_NATIVEINT</th></tr>
<tr><th>概要</th><td>バッファから32ビット整数値を取りだす</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int GET_32BIT_NATIVEINT( char *p )</b></td>
<tr><th>返り値</th><td>取りだしたint値
</td></tr>
<tr><th>詳細説明</th><td>ntohl, htonl 等をつかわない取りだしマクロである。
なお MIPS アーキテクチャ(PS2)のマシンでは、
このマクロは関数として実装されている。
</td></tr>
<tr><th>See also</th><td>
<a href="#GET_16BIT_NATIVEINT">GET_16BIT_NATIVEINT</a>
<a href="#GET_8BIT_NATIVEINT">GET_8BIT_NATIVEINT</a>
</td></tr>
</table><br><br>
<a name="GET_64BIT_INT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
GET_64BIT_INT</th></tr>
<tr><th>概要</th><td>メモリ領域から64ビット整数値を取りだすマクロ</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>VCEI64 GET_64BIT_INT( char *p )</b></td>
<tr><th>arg 1</Th><td>char *p</td></tr>
<tr><th></th><td>取りだす元になるバッファの先頭アドレス
</td></tr>
<tr><th>返り値</th><td>取りだした値
</td></tr>
<tr><th>詳細説明</th><td>内部で ntohlを使用している。
このマクロはバイナリプロトコル解析用に使われるが、アプリケーションで
バイナリプロトコルを実装する場合には、このマクロではなく、
bin カテゴリの関数群を使うべきである。
なお MIPS アーキテクチャ(PS2)のマシンでは、
このマクロは関数として実装されている。
</td></tr>
<tr><th>See also</th><td>
<a href="#GET_16BIT_INT">GET_16BIT_INT</a>
<a href="#GET_8BIT_INT">GET_8BIT_INT</a>
<a href="#SET_16BIT_INT">SET_16BIT_INT</a>
<a href="#SET_32BIT_INT">SET_32BIT_INT</a>
<a href="#SET_8BIT_INT">SET_8BIT_INT</a>
</td></tr>
</table><br><br>
<a name="GET_64BIT_NATIVEINT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
GET_64BIT_NATIVEINT</th></tr>
<tr><th>概要</th><td>バッファから64ビット整数値を取りだす</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int GET_64BIT_NATIVEINT( char *p )</b></td>
<tr><th>返り値</th><td>取りだしたint値
</td></tr>
<tr><th>詳細説明</th><td>ntohl, htonl 等をつかわない取りだしマクロである。
なお MIPS アーキテクチャ(PS2)のマシンでは、
このマクロは関数として実装されている。
</td></tr>
<tr><th>See also</th><td>
<a href="#GET_16BIT_NATIVEINT">GET_16BIT_NATIVEINT</a>
<a href="#GET_8BIT_NATIVEINT">GET_8BIT_NATIVEINT</a>
</td></tr>
</table><br><br>
<a name="GET_8BIT_INT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
GET_8BIT_INT</th></tr>
<tr><th>概要</th><td>メモリ領域から8ビットの整数値を取りだす</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>unsigned char GET_8BIT_INT( char *b )</b></td>
<tr><th>arg 1</Th><td>char *b</td></tr>
<tr><th></th><td>取りだす値が格納されているバッファの先頭アドレス
</td></tr>
<tr><th>返り値</th><td>取りだした値
</td></tr>
<tr><th>詳細説明</th><td>単に値を取りだすだけ。32ビット、16ビット等のマクロとの整合性をとるために
定義されている。
</td></tr>
<tr><th>See also</th><td>
<a href="#GET_16BIT_INT">GET_16BIT_INT</a>
<a href="#GET_32BIT_INT">GET_32BIT_INT</a>
<a href="#SET_16BIT_INT">SET_16BIT_INT</a>
<a href="#SET_32BIT_INT">SET_32BIT_INT</a>
<a href="#SET_8BIT_INT">SET_8BIT_INT</a>
</td></tr>
</table><br><br>
<a name="GET_8BIT_NATIVEINT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
GET_8BIT_NATIVEINT</th></tr>
<tr><th>概要</th><td>バッファから8ビット整数値を取りだす</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>char GET_8BIT_NATIVEINT( char *p )</b></td>
<tr><th>返り値</th><td>取りだした8ビット値
</td></tr>
<tr><th>詳細説明</th><td>GET_32BIT_NATIVEINT,GET_16BIT_NATIVEINTなどと整合性のあるコードを書くため
だけに定義されている。
</td></tr>
<tr><th>See also</th><td>
<a href="#GET_16BIT_NATIVEINT">GET_16BIT_NATIVEINT</a>
<a href="#GET_32BIT_NATIVEINT">GET_32BIT_NATIVEINT</a>
</td></tr>
</table><br><br>
<a name="MALLOC"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
MALLOC</th></tr>
<tr><th>概要</th><td>malloc の wrapper. Cライブラリのmallocのラッパー</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void *MALLOC( size_t size )</b></td>
<tr><th>arg 1</Th><td>size_t size</td></tr>
<tr><th></th><td>割りあてるメモリのサイズ(バイト数)
</td></tr>
<tr><th>返り値</th><td>割りあてられたメモリ領域の先頭アドレス
</td></tr>
<tr><th>詳細説明</th><td>標準Cライブラリのmalloc()関数を呼びだし、mallocの返り値をそのまま
返す。
VCEでは、 malloc 関数はプログラム起動時に1回だけ呼びだして
大きなメモリ領域を割りあて、起動後は一切mallocせず、
cleanup時にすべてをfree()するという戦略を取っている。
これはmalloc関数の動作が遅いことや、
malloc関数の実装方法の違いによる挙動の変化を最小に抑えるためである。
MALLOC関数は、FREE関数と対で使用される。
vce_set_verbose_mode を1に設定すると、ログを出力するようになる。
</td></tr>
<tr><th>See also</th><td>
<a href="#FREE">FREE</a>
<a href="#vce_set_verbose_mode">vce_set_verbose_mode</a>
</td></tr>
</table><br><br>
<a name="MAX"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
MAX</th></tr>
<tr><th>概要</th><td>2つの値を比較して大きい方の値を返す</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int MAX(int a, int b)</b></td>
<tr><th>arg 1</Th><td>int a</td></tr>
<tr><th></th><td>比較する片方の値。プロトタイプではintになっているが、
実際はマクロで定義されているので、比較演算子が使える型であればどんな型でも
使用することができる(移植性は高い)。
</td></tr>
<tr><th>arg 2</Th><td>int b</td></tr>
<tr><th></th><td>比較するもう片方の値
</td></tr>
<tr><th>返り値</th><td>得られた値 ( 大きいほう )．
</td></tr>
<tr><th>詳細説明</th><td>以下のような定義になっている。char,short,int,long,long long ,float,double,VCEI64
とそれらの符号なし型に対応している。
<pre>
( (x) &gt; (y) ? (x)  (y) )
</pre>
</td></tr>
<tr><th>See also</th><td>
<a href="#MIN">MIN</a>
</td></tr>
</table><br><br>
<a name="MIN"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
MIN</th></tr>
<tr><th>概要</th><td>2つの値を比較して小さい方の値を返す</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int MIN(int a, int b )</b></td>
<tr><th>arg 1</Th><td>int a</td></tr>
<tr><th></th><td>比較する片方の値。プロトタイプではintになっているが、
実際はマクロで定義されているので、比較演算子が使える型であればどんな型でも
使用することができる(移植性は高い)。
</td></tr>
<tr><th>arg 2</Th><td>int b</td></tr>
<tr><th></th><td>比較するもう片方の値
</td></tr>
<tr><th>返り値</th><td>結果の値
</td></tr>
<tr><th>詳細説明</th><td>以下のような定義になっている。char,short,int,long,long long,float,double,VCEI64
 とそれらの符号なし型に対応している。
<pre>
( (x) &lt; (y) ? (x)  (y) )
</pre>
</td></tr>
<tr><th>See also</th><td>
<a href="#MAX">MAX</a>
</td></tr>
</table><br><br>
<a name="SET_16BIT_INT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
SET_16BIT_INT</th></tr>
<tr><th>概要</th><td>メモリ領域に16ビットの整数値をネットワークバイトオーダでコピーする</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void SET_16BIT_INT( char *b, unsigned short i )</b></td>
<tr><th>arg 1</Th><td>char *b</td></tr>
<tr><th></th><td>コピーする先のバッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>unsigned short i</td></tr>
<tr><th></th><td>コピーする16ビットネイティブ値。
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>内部でhtonsを使用している。主にプロトコル処理に使われるが、
より一般的な目的のためには、 bin カテゴリの関数群を使うべきである。
なお MIPS アーキテクチャ(PS2)のマシンでは、
このマクロは関数として実装されている。
</td></tr>
<tr><th>See also</th><td>
<a href="#GET_16BIT_INT">GET_16BIT_INT</a>
<a href="#GET_32BIT_INT">GET_32BIT_INT</a>
<a href="#GET_8BIT_INT">GET_8BIT_INT</a>
<a href="#SET_32BIT_INT">SET_32BIT_INT</a>
<a href="#SET_8BIT_INT">SET_8BIT_INT</a>
</td></tr>
</table><br><br>
<a name="SET_16BIT_NATIVEINT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
SET_16BIT_NATIVEINT</th></tr>
<tr><th>概要</th><td>16ビット整数値を任意のバッファにコピーする</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void SET_16BIT_NATIVEINT( char *p, short i )</b></td>
<tr><th>arg 1</Th><td>char *p</td></tr>
<tr><th></th><td>コピーする先のバッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>short i</td></tr>
<tr><th></th><td>コピーする値
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>ntohs, htons 等を使用しない。直接値をコピーする。
ポインタの型キャストをするためのマクロ。
なお MIPS アーキテクチャ(PS2)のマシンでは、
このマクロは関数として実装されている。
</td></tr>
<tr><th>See also</th><td>
<a href="#SET_16BIT_NATIVEINT">SET_16BIT_NATIVEINT</a>
<a href="#SET_8BIT_NATIVEINT">SET_8BIT_NATIVEINT</a>
</td></tr>
</table><br><br>
<a name="SET_32BIT_INT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
SET_32BIT_INT</th></tr>
<tr><th>概要</th><td>メモリ領域に32ビットの整数値をネットワークバイトオーダでコピーする</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void SET_32BIT_INT( char *b, unsigned int i )</b></td>
<tr><th>arg 1</Th><td>char *b</td></tr>
<tr><th></th><td>値をコピーする先のメモリの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>unsigned int i</td></tr>
<tr><th></th><td>コピーしたい値(ネイティブ値)
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>内部で htonlを使用している。プロトコル解析用に使用されるが、
アプリケーションはプロトコル解析をする場合は、このマクロを使用
せずに bin カテゴリの関数群を使うべきである(そのほうが堅牢である。)
なお MIPS アーキテクチャ(PS2)のマシンでは、
このマクロは関数として実装されている。
</td></tr>
<tr><th>See also</th><td>
<a href="#GET_16BIT_INT">GET_16BIT_INT</a>
<a href="#GET_32BIT_INT">GET_32BIT_INT</a>
<a href="#SET_16BIT_INT">SET_16BIT_INT</a>
<a href="#SET_8BIT_INT">SET_8BIT_INT</a>
<a href="#SET_8BIT_INT">SET_8BIT_INT</a>
</td></tr>
</table><br><br>
<a name="SET_32BIT_NATIVEINT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
SET_32BIT_NATIVEINT</th></tr>
<tr><th>概要</th><td>32ビットの値を、任意のバッファにセットする</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void SET_32BIT_NATIVEINT( char *p, int i )</b></td>
<tr><th>arg 1</Th><td>char *p</td></tr>
<tr><th></th><td>コピーする先のバッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int i</td></tr>
<tr><th></th><td>コピーする値
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>htonl, ntohl等を使用せず、直接値をコピーする。
ポインタのキャストをするだけのマクロ。
なお MIPS アーキテクチャ(PS2)のマシンでは、
このマクロは関数として実装されている。
</td></tr>
<tr><th>See also</th><td>
<a href="#SET_16BIT_NATIVEINT">SET_16BIT_NATIVEINT</a>
<a href="#SET_8BIT_NATIVEINT">SET_8BIT_NATIVEINT</a>
</td></tr>
</table><br><br>
<a name="SET_64BIT_INT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
SET_64BIT_INT</th></tr>
<tr><th>概要</th><td>メモリ領域に64ビットの整数値をネットワークバイトオーダでコピーする</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void SET_64BIT_INT( char *b, VCEI64 i )</b></td>
<tr><th>arg 1</Th><td>char *b</td></tr>
<tr><th></th><td>値をコピーする先のメモリの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>VCEI64 i</td></tr>
<tr><th></th><td>コピーしたい値(ネイティブ値)
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>内部で htonlを使用している。プロトコル解析用に使用されるが、
アプリケーションはプロトコル解析をする場合は、このマクロを使用
せずに bin カテゴリの関数群を使うべきである(そのほうが堅牢である。)
なお MIPS アーキテクチャ(PS2)のマシンでは、
このマクロは関数として実装されている。
</td></tr>
<tr><th>See also</th><td>
<a href="#GET_16BIT_INT">GET_16BIT_INT</a>
<a href="#GET_32BIT_INT">GET_32BIT_INT</a>
<a href="#SET_16BIT_INT">SET_16BIT_INT</a>
<a href="#SET_8BIT_INT">SET_8BIT_INT</a>
<a href="#SET_8BIT_INT">SET_8BIT_INT</a>
</td></tr>
</table><br><br>
<a name="SET_64BIT_NATIVEINT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
SET_64BIT_NATIVEINT</th></tr>
<tr><th>概要</th><td>64ビットの値を、任意のバッファにセットする</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void SET_64BIT_NATIVEINT( char *p, VCEI64 i )</b></td>
<tr><th>arg 1</Th><td>char *p</td></tr>
<tr><th></th><td>コピーする先のバッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int i</td></tr>
<tr><th></th><td>コピーする値
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>htonl, ntohl等を使用せず、直接値をコピーする。
ポインタのキャストをするだけのマクロ。
なお MIPS アーキテクチャ(PS2)のマシンでは、
このマクロは関数として実装されている。
</td></tr>
<tr><th>See also</th><td>
<a href="#SET_16BIT_NATIVEINT">SET_16BIT_NATIVEINT</a>
<a href="#SET_8BIT_NATIVEINT">SET_8BIT_NATIVEINT</a>
</td></tr>
</table><br><br>
<a name="SET_8BIT_INT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
SET_8BIT_INT</th></tr>
<tr><th>概要</th><td>メモリ領域に8ビットの整数値をコピーする</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void SET_8BIT_INT( char *b, unsigned char i )</b></td>
<tr><th>arg 1</Th><td>char *b</td></tr>
<tr><th></th><td>コピーする先のバッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>unsigned char i</td></tr>
<tr><th></th><td>コピーする8ビット値
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>単にバッファにコピーするだけ。32ビット、16ビットなどのマクロとの整合性
をとって美しいコードを書くためだけに存在する。
</td></tr>
<tr><th>See also</th><td>
<a href="#GET_16BIT_INT">GET_16BIT_INT</a>
<a href="#GET_32BIT_INT">GET_32BIT_INT</a>
<a href="#GET_8BIT_INT">GET_8BIT_INT</a>
<a href="#SET_16BIT_INT">SET_16BIT_INT</a>
<a href="#SET_32BIT_INT">SET_32BIT_INT</a>
</td></tr>
</table><br><br>
<a name="SET_8BIT_NATIVEINT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
SET_8BIT_NATIVEINT</th></tr>
<tr><th>概要</th><td>8ビットの整数値を任意のバッファにコピーする</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void SET_8BIT_NATIVEINT( char *p, char i )</b></td>
<tr><th>arg 1</Th><td>char *P</td></tr>
<tr><th></th><td>コピーする先のバッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>char i</td></tr>
<tr><th></th><td>コピーする値
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>SET_16BIT_NATIVEINT,SET_32BIT_NATIVEINT との整合性をとってソースコードを
美しく書くためだけのマクロ。
</td></tr>
<tr><th>See also</th><td>
<a href="#SET_16BIT_NATIVEINT">SET_16BIT_NATIVEINT</a>
<a href="#SET_8BIT_NATIVEINT">SET_8BIT_NATIVEINT</a>
</td></tr>
</table><br><br>
<a name="STRERR"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
STRERR</th></tr>
<tr><th>概要</th><td>VCEの最新エラーコードを文字列で得る</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>char *STRERR</b></td>
<tr><th>返り値</th><td>出力の文字列へのポインタ。
</td></tr>
<tr><th>詳細説明</th><td>STRERRの定義は
<pre>
(vce_strerror( vce_get_last_error() ))
</pre>
である。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_last_error">vce_get_last_error</a>
<a href="#vce_strerror">vce_strerror</a>
</td></tr>
</table><br><br>
<a name="vce_alloc_array_object"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_alloc_array_object</th></tr>
<tr><th>概要</th><td>VCE配列の未使用要素を1個わりあてる</td></tr>
<tr><th>カテゴリ</th><td>array</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void * vce_alloc_array_object( int index )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>VCE配列を特定するための配列デスクリプタ
</td></tr>
<tr><th>返り値</th><td>割りあてられた配列要素の先頭アドレス。
配列の最大要素数まで要素を使いきっている場合(空きリストに何もない場合)は、
ヌルポインタを返す。
それ以外にもエラーの内容は vce_get_last_error で得ることができる。
</td></tr>
<tr><th>詳細説明</th><td>VCE配列の空きリストを検索し、未使用要素がある場合はそのポインタを返す。
この関数は，あたらしく割りあてるバッファの中身に対して
何らかのデータを書きこむこと(ゼロ初期化等)は一切しない．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_free_array_object">vce_free_array_object</a>
<a href="#vce_free_array_object_all">vce_free_array_object_all</a>
<a href="#vce_init_array">vce_init_array</a>
</td></tr>
</table><br><br>
<a name="vce_analyzer_analyze"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_analyzer_analyze</th></tr>
<tr><th>概要</th><td>プロトコルの解析を行う</td></tr>
<tr><th>カテゴリ</th><td>analyzer</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_analyzer_analyze( analyzer_t *a, char *data, int data_len, int is_fail )</b></td>
<tr><th>arg 1</Th><td>analyzer_t *a</td></tr>
<tr><th></th><td>解析した結果を格納するanalyzer_t構造体のアドレス
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>解析するプロトコルのバイナリ。vce_protocol_unparser_bin**()に渡されるdata引数と同じもの。
</td></tr>
<tr><th>arg 3</Th><td>int data_len</td></tr>
<tr><th></th><td>dataの長さ
</td></tr>
<tr><th>arg 4</Th><td>int is_fail</td></tr>
<tr><th></th><td>送信に失敗したかどうか。送信に失敗した場合、非０の値を渡す。
基本的には、vce_protocol_unparser_bin**()の返り値を渡せばよい。
</td></tr>
<tr><th>返り値</th><td></td></tr>
<tr><th>詳細説明</th><td>プロトコルの解析を行う。
</td></tr>
<tr><th>See also</th><td>
<a href="# vce_analyzer_clear"> vce_analyzer_clear</a>
<a href="# vce_analyzer_get_state_string"> vce_analyzer_get_state_string</a>
<a href="#vce_analyzer_init">vce_analyzer_init</a>
</td></tr>
</table><br><br>
<a name="vce_analyzer_clear"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_analyzer_clear</th></tr>
<tr><th>概要</th><td>analyzerをクリアする</td></tr>
<tr><th>カテゴリ</th><td>analyzer</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_analyzer_clear( analyzer_t *a )</b></td>
<tr><th>arg 1</Th><td>analyzer_t *a</td></tr>
<tr><th></th><td>状態をクリアするanalyzer_t構造体のアドレス
</td></tr>
<tr><th>返り値</th><td></td></tr>
<tr><th>詳細説明</th><td>analyzrerのクリアを行う。
定期的にこの関数を呼ぶことで、一定期間内のプロトコルの解析を行うことができる。
</td></tr>
<tr><th>See also</th><td>
<a href="# vce_analyzer_analyze"> vce_analyzer_analyze</a>
<a href="# vce_analyzer_get_state_string"> vce_analyzer_get_state_string</a>
<a href="#vce_analyzer_init">vce_analyzer_init</a>
</td></tr>
</table><br><br>
<a name="vce_analyzer_get_state_string"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_analyzer_get_state_string</th></tr>
<tr><th>概要</th><td>analyzerをクリアする</td></tr>
<tr><th>カテゴリ</th><td>analyzer</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_analyzer_get_state_string( analyzer_t *a, char *buf, int buf_len )</b></td>
<tr><th>arg 1</Th><td>analyzer_t *a</td></tr>
<tr><th></th><td>状態を取得するanalyzer_t構造体のアドレス
</td></tr>
<tr><th>arg 2</Th><td>char *buf</td></tr>
<tr><th></th><td>結果を格納する文字列のアドレス
</td></tr>
<tr><th>arg 3</Th><td>int buf_len</td></tr>
<tr><th></th><td>bufのサイズ
</td></tr>
<tr><th>返り値</th><td></td></tr>
<tr><th>詳細説明</th><td>analyzerにより解析された結果を文字列で取得する。
文字列は以下のような形で返される。
total = **** bytes( **** times ), fail = **** bytes( **** times ), ill protocols [***] ***bytes ***times ...
これは、それぞれ送信された総バイト数、回数、送信に失敗したバイト数、回数。ill protocolsには、
送信に失敗した割合の多いプロトコルの番号とバイト数、回数が表示される。
</td></tr>
<tr><th>See also</th><td>
<a href="# vce_analyzer_analyze"> vce_analyzer_analyze</a>
<a href="# vce_analyzer_get_state_string"> vce_analyzer_get_state_string</a>
<a href="#vce_analyzer_init">vce_analyzer_init</a>
</td></tr>
</table><br><br>
<a name="vce_analyzer_init"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_analyzer_init</th></tr>
<tr><th>概要</th><td>アナライザ構造体をを初期化する</td></tr>
<tr><th>カテゴリ</th><td>analyzer</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_analyzer_init( analyzer_t *a, int protocol_max )</b></td>
<tr><th>arg 1</Th><td>analyzer_t *a</td></tr>
<tr><th></th><td>初期化するanalyzer_t構造体のアドレス
</td></tr>
<tr><th>arg 2</Th><td>int protocol_max</td></tr>
<tr><th></th><td>プロトコルの種類の数。256より多いかどうかのみが重要。
</td></tr>
<tr><th>返り値</th><td></td></tr>
<tr><th>詳細説明</th><td>analyzer_t構造体を初期化する。使用するanalyzer_t構造体は、かならずこの関数で初期化されなくては
ならない。<br>
vce_analyzer_***()関数群を使って解析できることは、vce_analyzer_clearが呼ばれてから、
送られた各プロトコルの数、総バイト数、送信に失敗した数、送信に失敗した総バイト数、
よく送信に失敗したプロトコルの種類である。<br>
これらは、サーバーの設定のチューニングや、バグの解明に有用である。<br>
とくに、サーバーが送信に失敗した場合コネクションを切断するという構造になっていた場合、
接続ユーザーが増えた場合バッファが溢れたため、送信に失敗して切断ということが多くなる。<br>
その際にanalyzerで解析してあれば、プロトコルの送信失敗が原因でコネクションを切断
していることがすぐに判明する。<br>
</td></tr>
<tr><th>See also</th><td>
<a href="# vce_analyzer_clear"> vce_analyzer_clear</a>
<a href="# vce_analyzer_get_state_string"> vce_analyzer_get_state_string</a>
<a href="#vce_analyzer_analyze">vce_analyzer_analyze</a>
</td></tr>
</table><br><br>
<a name="vce_array_object_inuse"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_array_object_inuse</th></tr>
<tr><th>概要</th><td>VCE配列の要素が使用中かどうかを調べる</td></tr>
<tr><th>カテゴリ</th><td>array</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_array_object_inuse( int index, void *p )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>配列ディスクリプタ
</td></tr>
<tr><th>arg 2</Th><td>void *p</td></tr>
<tr><th></th><td>配列要素をさすポインタ
</td></tr>
<tr><th>返り値</th><td>使用中なら1，そうでないなら0，
範囲外のポインタやindexの値が不正なときは負のエラーコード．
</td></tr>
<tr><th>詳細説明</th><td>この関数を使うと，あるポインタが，
配列の中で使用中かどうかの状態を知ることができる．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_alloc_array_object">vce_alloc_array_object</a>
<a href="#vce_free_array_object">vce_free_array_object</a>
</td></tr>
</table><br><br>
<a name="vce_atoi"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_atoi</th></tr>
<tr><th>概要</th><td>文字列を整数(int)に変換する。簡単な計算機能つき。</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_atoi( char *p )</b></td>
<tr><th>arg 1</Th><td>char *p</td></tr>
<tr><th></th><td>変換する文字列。
</td></tr>
<tr><th>返り値</th><td>変換後の値。不正な入力の場合は一律に0を返す。
</td></tr>
<tr><th>詳細説明</th><td>単純な計算機能つきatoiルーチンである。
以下のような入力を受けつける。
<pre>
"12345"    →  12345
"-12345"   → -12345
"123+123"  →  246
"123-123"  →  0
"123+-123"  →  0
"-123-123" →  -246
"123*3"    →  369
"-123*3"   → -369
"-123*-3"  →  369
"123+2*2"  →  250  先に + が計算されていることに注意
"1+1+1+1+1"  →  5  いくつでもつなげることができる
"1+1+  1+1  +1"  →  5  空白文字(TAB,SPACE)は読みとばされる
</pre>
電卓の操作のように、演算子の結合強度とは無関係に、前の演算子から順に
計算していくことに注意。
内部ではlibcの atoi を使用している。
<BR>
入力が変換不可能な場合は、一律に0を返すが、そういう仕様だと0という値が
エラーなのか正しい値なのか判別できないため、変換できなかった場合は、
vce_get_last_error 関数を使って、VCE_EFORMAT を検出することで、
0が正しい出力なのかエラーなのかを判別することができるようになっている。
10進数専用である。
</td></tr>
<tr><th>知られているバグやTODO</th><td>現在，この関数はまだ実験段階なため，
不安定(結果がおかしくなる場合がある)である．
</td></tr>
</table><br><br>
<a name="vce_binary_pack"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_pack</th></tr>
<tr><th>概要</th><td>構造体に保存されているデータをpackして、バイト列にする (古い)</td></tr>
<tr><th>カテゴリ</th><td>bin</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_binary_pack( struct bin_info *bi, int bn, char *outp, int len )</b></td>
<tr><th>arg 1</Th><td>struct bin_info *bi</td></tr>
<tr><th></th><td>bin_info構造体の配列の先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int bn</td></tr>
<tr><th></th><td>bin_info構造体の要素数
</td></tr>
<tr><th>arg 3</Th><td>char *outp</td></tr>
<tr><th></th><td>出力バッファ
</td></tr>
<tr><th>arg 4</Th><td>int len</td></tr>
<tr><th></th><td>出力バッファの最大長(バイト数)
</td></tr>
<tr><th>返り値</th><td>出力バッファに出力したバイト数
</td></tr>
<tr><th>詳細説明</th><td>bin_info 構造体に保存されている状態のデータをPackし、一連のバイト列に
変換する。主にプロトコル処理で使われる。
</td></tr>
<tr><th>知られているバグやTODO</th><td>現在は バイナリpush/pop 関数群によって，置きかえられている．
</td></tr>
</table><br><br>
<a name="vce_binary_pop_nb_i1"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_pop_nb_i1</th></tr>
<tr><th>概要</th><td>バッファから1バイト整数(char) を取りだす</td></tr>
<tr><th>カテゴリ</th><td>bin</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_binary_pop_nb_i1( char *in, int len, int ofs, char *out)</b></td>
<tr><th>arg 1</Th><td>char *in</td></tr>
<tr><th></th><td>データを取りだすバッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>データを取りだすバッファの長さ
</td></tr>
<tr><th>arg 3</Th><td>int ofs</td></tr>
<tr><th></th><td>実際にデータを取りだしはじめる場所の、バッファの先頭からのオフセット
</td></tr>
<tr><th>arg 4</Th><td>char *out</td></tr>
<tr><th></th><td>取りだしたデータを格納するための char のポインタ
</td></tr>
<tr><th>返り値</th><td>1バイト取りだすことによって移動する、新しい ofs の値
</td></tr>
<tr><th>詳細説明</th><td>vce_binary_push_nb_i1 関数で pack したデータを取りだす。
オフセットはつねに1進む。ただし、失敗した場合(データが足りないなど)は、
負のエラーコードを返す。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_push_nb_i1">vce_binary_push_nb_i1</a>
</td></tr>
</table><br><br>
<a name="vce_binary_pop_nb_i2"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_pop_nb_i2</th></tr>
<tr><th>概要</th><td>バッファから2バイト整数(short) を取りだす</td></tr>
<tr><th>カテゴリ</th><td>bin</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_binary_pop_nb_i2( char *in, int len, int ofs, short *out )</b></td>
<tr><th>arg 1</Th><td>char *in</td></tr>
<tr><th></th><td>データを取りだすバッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>データを取りだすバッファの長さ
</td></tr>
<tr><th>arg 3</Th><td>int ofs</td></tr>
<tr><th></th><td>実際にデータを取りだしはじめる場所の、バッファの先頭からのオフセット
</td></tr>
<tr><th>arg 4</Th><td>short *out</td></tr>
<tr><th></th><td>取りだしたデータを格納するための short のポインタ
</td></tr>
<tr><th>返り値</th><td>2バイト取りだすことによって移動する、新しい ofs の値
</td></tr>
<tr><th>詳細説明</th><td>vce_binary_push_nb_i2 関数で pack したデータを取りだす。
オフセットはつねに2進む。ただし、失敗した場合(データが足りないなど)は、
負のエラーコードを返す。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_push_nb_i2">vce_binary_push_nb_i2</a>
</td></tr>
</table><br><br>
<a name="vce_binary_pop_nb_i4"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_pop_nb_i4</th></tr>
<tr><th>概要</th><td>バッファから4バイト整数(int) を取りだす</td></tr>
<tr><th>カテゴリ</th><td>bin</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_binary_pop_nb_i4( char *in, int len, int ofs, int *out )</b></td>
<tr><th>arg 1</Th><td>char *in</td></tr>
<tr><th></th><td>データを取りだすバッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>データを取りだすバッファの長さ
</td></tr>
<tr><th>arg 3</Th><td>int ofs</td></tr>
<tr><th></th><td>実際にデータを取りだしはじめる場所の、バッファの先頭からのオフセット
</td></tr>
<tr><th>arg 4</Th><td>int *out</td></tr>
<tr><th></th><td>取りだしたデータを格納するための int のポインタ
</td></tr>
<tr><th>返り値</th><td>4バイト取りだすことによって移動する、新しい ofs の値
</td></tr>
<tr><th>詳細説明</th><td>vce_binary_push_nb_i4 関数で pack したデータを取りだす。
オフセットはつねに4進む。ただし、失敗した場合(データが足りないなど)は、
負のエラーコードを返す。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_push_nb_i4">vce_binary_push_nb_i4</a>
</td></tr>
</table><br><br>
<a name="vce_binary_pop_nb_i8"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_pop_nb_i8</th></tr>
<tr><th>概要</th><td>バッファから8バイト整数(VCEI64) を取りだす</td></tr>
<tr><th>カテゴリ</th><td>bin</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_binary_pop_nb_i8( char *in, int len, int ofs, VCEI64 *out )</b></td>
<tr><th>arg 1</Th><td>char *in</td></tr>
<tr><th></th><td>データを取りだすバッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>データを取りだすバッファの長さ
</td></tr>
<tr><th>arg 3</Th><td>int ofs</td></tr>
<tr><th></th><td>実際にデータを取りだしはじめる場所の、バッファの先頭からのオフセット
</td></tr>
<tr><th>arg 4</Th><td>VCEI64 *out</td></tr>
<tr><th></th><td>取りだしたデータを格納するための VCEI64 のポインタ
</td></tr>
<tr><th>返り値</th><td>8バイト取りだすことによって移動する、新しい ofs の値
</td></tr>
<tr><th>詳細説明</th><td>vce_binary_push_nb_i8 関数で pack したデータを取りだす。
オフセットはつねに8進む。ただし、失敗した場合(データが足りないなど)は、
負のエラーコードを返す。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_push_nb_i8">vce_binary_push_nb_i8</a>
</td></tr>
</table><br><br>
<a name="vce_binary_pop_nb_ia1"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_pop_nb_ia1</th></tr>
<tr><th>概要</th><td>バッファから1バイト整数(char) の配列を取りだす</td></tr>
<tr><th>カテゴリ</th><td>bin</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_binary_pop_nb_ia1( char *src, int len, int ofs, char *out, int *outlen )</b></td>
<tr><th>arg 1</Th><td>char *in</td></tr>
<tr><th></th><td>データを取りだすバッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>データを取りだすバッファの長さ
</td></tr>
<tr><th>arg 3</Th><td>int ofs</td></tr>
<tr><th></th><td>実際にデータを取りだす場所のバッファ先頭からのオフセット
</td></tr>
<tr><th>arg 4</Th><td>char *out</td></tr>
<tr><th></th><td>取りだしたデータを格納する char 型の配列の先頭アドレス
</td></tr>
<tr><th>arg 5</Th><td>int *outlen</td></tr>
<tr><th></th><td>値結果引数。引数として与えるときは、
out 引数で指定する配列の要素数を受けとり、
結果として、実際に埋めた要素数を返す。
</td></tr>
<tr><th>返り値</th><td>配列を取りだすことによって移動する、あたらしい ofs の値。
取りだしに失敗したら負のエラーコードを返す。
</td></tr>
<tr><th>詳細説明</th><td>vce_binary_push_nb_ia1 関数で pack したデータを取りだす。
データが足りない場合や、取りだすための配列が小さすぎるなどの場合は、
中途半端に取りだすことはせず、失敗をあらわす負のエラーコードを返す。
これは VCE のバイナリ操作のポリシーとなっている。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_push_nb_ia1">vce_binary_push_nb_ia1</a>
</td></tr>
</table><br><br>
<a name="vce_binary_pop_nb_ia2"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_pop_nb_ia2</th></tr>
<tr><th>概要</th><td>バッファから2バイト整数(short) の配列を取りだす</td></tr>
<tr><th>カテゴリ</th><td>bin</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_binary_pop_nb_ia2( char *src, int len, int ofs, short *out, int *outlen )</b></td>
<tr><th>arg 1</Th><td>char *in</td></tr>
<tr><th></th><td>データを取りだすバッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>データを取りだすバッファの長さ
</td></tr>
<tr><th>arg 3</Th><td>int ofs</td></tr>
<tr><th></th><td>実際にデータを取りだす場所のバッファ先頭からのオフセット
</td></tr>
<tr><th>arg 4</Th><td>short *out</td></tr>
<tr><th></th><td>取りだしたデータを格納する short 型の配列の先頭アドレス
</td></tr>
<tr><th>arg 5</Th><td>int *outlen</td></tr>
<tr><th></th><td>値結果引数。値として、 out 引数で指定する配列の要素数を受けとり、
結果として、実際に埋めた要素数を返す。
</td></tr>
<tr><th>返り値</th><td>配列を取りだすことによって移動する、あたらしい ofs の値。
取りだしに失敗したら負のエラーコードを返す。
</td></tr>
<tr><th>詳細説明</th><td>vce_binary_push_nb_ia2 関数で pack したデータを取りだす。
データが足りない場合や、取りだすための配列が小さすぎるなどの場合は、
中途半端に取りだすことはせず、失敗をあらわす負のエラーコードを返す。
これは VCE のバイナリ操作のポリシーとなっている。
データはネットワークバイトオーダからネイティブのオーダーに戻して格納される。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_push_nb_ia2">vce_binary_push_nb_ia2</a>
</td></tr>
</table><br><br>
<a name="vce_binary_pop_nb_ia4"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_pop_nb_ia4</th></tr>
<tr><th>概要</th><td>バッファから4バイト整数(int) の配列を取りだす</td></tr>
<tr><th>カテゴリ</th><td>bin</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_binary_pop_nb_ia4( char *src, int len, int ofs, int *out, int *outlen )</b></td>
<tr><th>arg 1</Th><td>char *in</td></tr>
<tr><th></th><td>データを取りだすバッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>データを取りだすバッファの長さ
</td></tr>
<tr><th>arg 3</Th><td>int ofs</td></tr>
<tr><th></th><td>実際にデータを取りだす場所のバッファ先頭からのオフセット
</td></tr>
<tr><th>arg 4</Th><td>int *out</td></tr>
<tr><th></th><td>取りだしたデータを格納する int 型の配列の先頭アドレス
</td></tr>
<tr><th>arg 5</Th><td>int *outlen</td></tr>
<tr><th></th><td>値結果引数。値として、 out 引数で指定する配列の要素数を受けとり、
結果として、実際に埋めた要素数を返す。
</td></tr>
<tr><th>返り値</th><td>配列を取りだすことによって移動する、あたらしい ofs の値。
取りだしに失敗したら負のエラーコードを返す。
</td></tr>
<tr><th>詳細説明</th><td>vce_binary_push_nb_ia4 関数で pack したデータを取りだす。
データが足りない場合や、取りだすための配列が小さすぎるなどの場合は、
中途半端に取りだすことはせず、失敗をあらわす負のエラーコードを返す。
これは VCE のバイナリ操作のポリシーとなっている。
データはネットワークバイトオーダからネイティブのオーダーに戻して格納される。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_push_nb_ia4">vce_binary_push_nb_ia4</a>
</td></tr>
</table><br><br>
<a name="vce_binary_pop_nb_ia8"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_pop_nb_ia8</th></tr>
<tr><th>概要</th><td>バッファから8バイト整数(int) の配列を取りだす</td></tr>
<tr><th>カテゴリ</th><td>bin</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_binary_pop_nb_ia8( char *src, int len, int ofs, VCEI64 *out, int *outlen )</b></td>
<tr><th>arg 1</Th><td>char *in</td></tr>
<tr><th></th><td>データを取りだすバッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>データを取りだすバッファの長さ
</td></tr>
<tr><th>arg 3</Th><td>int ofs</td></tr>
<tr><th></th><td>実際にデータを取りだす場所のバッファ先頭からのオフセット
</td></tr>
<tr><th>arg 4</Th><td>VCEI64 *out</td></tr>
<tr><th></th><td>取りだしたデータを格納する int 型の配列の先頭アドレス
</td></tr>
<tr><th>arg 5</Th><td>int *outlen</td></tr>
<tr><th></th><td>値結果引数。値として、 out 引数で指定する配列の要素数を受けとり、
結果として、実際に埋めた要素数を返す。
</td></tr>
<tr><th>返り値</th><td>配列を取りだすことによって移動する、あたらしい ofs の値。
取りだしに失敗したら負のエラーコードを返す。
</td></tr>
<tr><th>詳細説明</th><td>vce_binary_push_nb_ia8 関数で pack したデータを取りだす。
データが足りない場合や、取りだすための配列が小さすぎるなどの場合は、
中途半端に取りだすことはせず、失敗をあらわす負のエラーコードを返す。
これは VCE のバイナリ操作のポリシーとなっている。
データはネットワークバイトオーダからネイティブのオーダーに戻して格納される。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_push_nb_ia8">vce_binary_push_nb_ia8</a>
</td></tr>
</table><br><br>
<a name="vce_binary_pop_nb_stra"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_pop_nb_stra</th></tr>
<tr><th>概要</th><td>バッファから文字列の配列を取りだす</td></tr>
<tr><th>カテゴリ</th><td>bin</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_binary_pop_nb_stra( char *src, int len, int ofs, char **out, int *strnum, int eachmax )</b></td>
<tr><th>arg 1</Th><td>char *in</td></tr>
<tr><th></th><td>データを取りだすバッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>データを取りだすバッファの長さ
</td></tr>
<tr><th>arg 3</Th><td>int ofs</td></tr>
<tr><th></th><td>実際にデータを取りだす場所のバッファ先頭からのオフセット
</td></tr>
<tr><th>arg 4</Th><td>char **out</td></tr>
<tr><th></th><td>取りだした文字列を格納するための、文字列へのポインタの配列の先頭アドレス
</td></tr>
<tr><th>arg 5</Th><td>int *strnum</td></tr>
<tr><th></th><td>値結果引数。値として、 out 引数で指定する配列の要素数を受けとり、
結果として、実際に埋めた要素数を返す。
</td></tr>
<tr><th>arg 6</Th><td>int eachmax</td></tr>
<tr><th></th><td>結果として出力する各C言語文字列の最大の長さを指定する。
</td></tr>
<tr><th>返り値</th><td>配列を取りだすことによって移動する、あたらしい ofs の値。
取りだしに失敗したら負のエラーコードを返す。
</td></tr>
<tr><th>詳細説明</th><td>vce_binary_push_nb_stra 関数で pack したデータを取りだす。
データが足りない場合や、取りだすための配列が小さすぎるなどの場合は、
中途半端に取りだすことはせず、失敗をあらわす負のエラーコードを返す。
これは VCE のバイナリ操作のポリシーとなっている。
文字列は out 引数で指定される文字列配列にコピーされるため、
本関数を使用するアプリケーションによってコピー用のメモリ領域が
確保されている必要がある(サンプルコードを参照)。
</td></tr>
<tr><th>使用例</th><td>  char *orig_data[] = { "foo", "bar" };
  char packed[1000];
  char buf[3][100];
  char *out[3] = { buf[0] , buf[1], buf[2] }; // for を使ってもよい
  int new_ofs,strnum,packed_len;
  packed_len = vce_binary_push_nb_stra( packed, sizeof(packed), 0, orig_data, 3, 100 );
  strnum = 3;
  new_ofs = vce_binary_pop_nb_stra( packed, packed_len, 0, out,&strnum, 100 );
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_push_nb_stra">vce_binary_push_nb_stra</a>
</td></tr>
</table><br><br>
<a name="vce_binary_push_nb_i1"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_push_nb_i1</th></tr>
<tr><th>概要</th><td>1バイト整数(char) をバッファにpushする</td></tr>
<tr><th>カテゴリ</th><td>bin</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_binary_push_nb_i1( char *out, int ofs, int maxlen, char c )</b></td>
<tr><th>arg 1</Th><td>char *out</td></tr>
<tr><th></th><td>出力バッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int ofs</td></tr>
<tr><th></th><td>実際に出力する場所の、バッファの先頭からのオフセット
</td></tr>
<tr><th>arg 3</Th><td>int maxlen</td></tr>
<tr><th></th><td>出力バッファの長さ
</td></tr>
<tr><th>arg 4</Th><td>char c</td></tr>
<tr><th></th><td>出力する元データ
</td></tr>
<tr><th>返り値</th><td>1バイト push することによって ofs が移動するので、
あたらしい ofs の値を返す。 この関数の場合は常に ofs + 1 である。
push できなかったときは、負のエラーコードを返す。
</td></tr>
<tr><th>詳細説明</th><td>バイナリプロトコルを定義するときに使用されるバイナリ packer
用関数群のひとつ。gen.rb によって使用される。
対応する vce_binary_pop_nb_i1 関数で取りだすことができる。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_pop_nb_i1">vce_binary_pop_nb_i1</a>
</td></tr>
</table><br><br>
<a name="vce_binary_push_nb_i2"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_push_nb_i2</th></tr>
<tr><th>概要</th><td>2バイト整数(short) をバッファにpushする</td></tr>
<tr><th>カテゴリ</th><td>bin</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_binary_push_nb_i2( char *out, int ofs, int maxlen, short s )</b></td>
<tr><th>arg 1</Th><td>char *out</td></tr>
<tr><th></th><td>出力バッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int ofs</td></tr>
<tr><th></th><td>実際に出力する場所の、バッファの先頭からのオフセット
</td></tr>
<tr><th>arg 3</Th><td>int maxlen</td></tr>
<tr><th></th><td>出力バッファの長さ
</td></tr>
<tr><th>arg 4</Th><td>short s</td></tr>
<tr><th></th><td>出力する元データ
</td></tr>
<tr><th>返り値</th><td>2バイト push することによって ofs が移動するので、
あたらしい ofs の値を返す。 この関数の場合は常に ofs + 2 である。
push できなかったときは、負のエラーコードを返す。
</td></tr>
<tr><th>詳細説明</th><td>VCE のバイナリ packer のポリシー上、
2バイト以上のデータをバッファに push するときは、
絶対にデータを壊すことはしない。確実に全部のデータを push するか、
完全に失敗するかどちらかである。
対応する vce_binary_pop_nb_i2 関数で取りだすことができる。
データは、ネットワークバイトオーダで出力される。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_pop_nb_i2">vce_binary_pop_nb_i2</a>
</td></tr>
</table><br><br>
<a name="vce_binary_push_nb_i4"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_push_nb_i4</th></tr>
<tr><th>概要</th><td>4バイト整数(int) をバッファにpushする</td></tr>
<tr><th>カテゴリ</th><td>bin</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_binary_push_nb_i4( char *out, int ofs, int maxlen, int i )</b></td>
<tr><th>arg 1</Th><td>char *out</td></tr>
<tr><th></th><td>出力バッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int ofs</td></tr>
<tr><th></th><td>実際に出力する場所の、バッファの先頭からのオフセット
</td></tr>
<tr><th>arg 3</Th><td>int maxlen</td></tr>
<tr><th></th><td>出力バッファの長さ
</td></tr>
<tr><th>arg 4</Th><td>int i</td></tr>
<tr><th></th><td>出力する元データ
</td></tr>
<tr><th>返り値</th><td>4バイト push することによって ofs が移動するので、
あたらしい ofs の値を返す。 この関数の場合は常に ofs + 4 である。
push できなかったときは、負のエラーコードを返す。
</td></tr>
<tr><th>詳細説明</th><td>VCE のバイナリ packer のポリシー上、
4バイト以上のデータをバッファに push するときは、
絶対にデータを壊すことはしない。確実に全部のデータを push するか、
完全に失敗するかどちらかである。
対応する vce_binary_pop_nb_i4 関数で取りだすことができる。
データは、ネットワークバイトオーダで出力される。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_pop_nb_i4">vce_binary_pop_nb_i4</a>
</td></tr>
</table><br><br>
<a name="vce_binary_push_nb_i8"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_push_nb_i8</th></tr>
<tr><th>概要</th><td>8バイト整数(VCEI64) をバッファにpushする</td></tr>
<tr><th>カテゴリ</th><td>bin</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_binary_push_nb_i8( char *out, int ofs, int maxlen, VCEI64 i )</b></td>
<tr><th>arg 1</Th><td>char *out</td></tr>
<tr><th></th><td>出力バッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int ofs</td></tr>
<tr><th></th><td>実際に出力する場所の、バッファの先頭からのオフセット
</td></tr>
<tr><th>arg 3</Th><td>int maxlen</td></tr>
<tr><th></th><td>出力バッファの長さ
</td></tr>
<tr><th>arg 4</Th><td>VCEI64 i</td></tr>
<tr><th></th><td>出力する元データ
</td></tr>
<tr><th>返り値</th><td>8バイト push することによって ofs が移動するので、
あたらしい ofs の値を返す。 この関数の場合は常に ofs + 8 である。
push できなかったときは、負のエラーコードを返す。
</td></tr>
<tr><th>詳細説明</th><td>VCE のバイナリ packer のポリシー上、
8バイト以上のデータをバッファに push するときは、
絶対にデータを壊すことはしない。確実に全部のデータを push するか、
完全に失敗するかどちらかである。
対応する vce_binary_pop_nb_i8 関数で取りだすことができる。
データは、ネットワークバイトオーダで出力される。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_pop_nb_i8">vce_binary_pop_nb_i8</a>
</td></tr>
</table><br><br>
<a name="vce_binary_push_nb_ia1"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_push_nb_ia1</th></tr>
<tr><th>概要</th><td>1バイト整数(char)の配列をバッファに push する</td></tr>
<tr><th>カテゴリ</th><td>bin</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_binary_push_nb_ia1( char *out, int ofs, int maxlen, char *ia, int num )</b></td>
<tr><th>arg 1</Th><td>char *out</td></tr>
<tr><th></th><td>出力バッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int ofs</td></tr>
<tr><th></th><td>実際に出力する場所の、バッファの先頭からのオフセット
</td></tr>
<tr><th>arg 3</Th><td>int maxlen</td></tr>
<tr><th></th><td>出力バッファの長さ
</td></tr>
<tr><th>arg 4</Th><td>char *ia</td></tr>
<tr><th></th><td>出力する1バイト整数(char)の配列の先頭アドレス
</td></tr>
<tr><th>arg 5</Th><td>int num</td></tr>
<tr><th></th><td>出力する配列の要素数
</td></tr>
<tr><th>返り値</th><td>出力することによって移動した、あたらしいオフセットを返す。
出力に失敗した場合は負のエラーコードを返す。
</td></tr>
<tr><th>詳細説明</th><td>char型の配列の中身を出力バッファに push する。
対応する vce_binary_pop_nb_ia1 関数で取りだすことができる。
出力バッファの長さが足りない場合は、データを壊さず、
負のエラーコード(VCE_EFULL)を返す。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_pop_nb_ia1">vce_binary_pop_nb_ia1</a>
</td></tr>
</table><br><br>
<a name="vce_binary_push_nb_ia2"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_push_nb_ia2</th></tr>
<tr><th>概要</th><td>2バイト整数(short)の配列をバッファに push する</td></tr>
<tr><th>カテゴリ</th><td>bin</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_binary_push_nb_ia2( char *out, int ofs, int maxlen, short *ia, int num )</b></td>
<tr><th>arg 1</Th><td>char *out</td></tr>
<tr><th></th><td>出力バッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int ofs</td></tr>
<tr><th></th><td>実際に出力する場所の、バッファの先頭からのオフセット
</td></tr>
<tr><th>arg 3</Th><td>int maxlen</td></tr>
<tr><th></th><td>出力バッファの長さ
</td></tr>
<tr><th>arg 4</Th><td>short *ia</td></tr>
<tr><th></th><td>出力する2バイト整数(short)の配列の先頭アドレス
</td></tr>
<tr><th>arg 5</Th><td>int num</td></tr>
<tr><th></th><td>出力する配列の要素数
</td></tr>
<tr><th>返り値</th><td>出力することによって移動した、あたらしいオフセットを返す。
出力に失敗した場合は負のエラーコードを返す。
</td></tr>
<tr><th>詳細説明</th><td>short型の配列の中身を出力バッファに push する。
対応する vce_binary_pop_nb_ia2 関数で取りだすことができる。
データはすべてネットワークバイトオーダで保存される。
出力バッファの長さが足りない場合は、データを壊さず、
負のエラーコード(VCE_EFULL)を返す。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_pop_nb_ia2">vce_binary_pop_nb_ia2</a>
</td></tr>
</table><br><br>
<a name="vce_binary_push_nb_ia4"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_push_nb_ia4</th></tr>
<tr><th>概要</th><td>4バイト整数(int)の配列をバッファに push する</td></tr>
<tr><th>カテゴリ</th><td>bin</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_binary_push_nb_ia4( char *out, int ofs, int maxlen, int *ia, int num )</b></td>
<tr><th>arg 1</Th><td>char *out</td></tr>
<tr><th></th><td>出力バッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int ofs</td></tr>
<tr><th></th><td>実際に出力する場所の、バッファの先頭からのオフセット
</td></tr>
<tr><th>arg 3</Th><td>int maxlen</td></tr>
<tr><th></th><td>出力バッファの長さ
</td></tr>
<tr><th>arg 4</Th><td>int *ia</td></tr>
<tr><th></th><td>出力する4バイト整数(int)の配列の先頭アドレス
</td></tr>
<tr><th>arg 5</Th><td>int num</td></tr>
<tr><th></th><td>出力する配列の要素数
</td></tr>
<tr><th>返り値</th><td>出力することによって移動した、あたらしいオフセットを返す。
出力に失敗した場合は負のエラーコードを返す。
</td></tr>
<tr><th>詳細説明</th><td>int型の配列の中身を出力バッファに push する。
対応する vce_binary_pop_nb_ia4 関数で取りだすことができる。
データはすべてネットワークバイトオーダで保存される。
出力バッファの長さが足りない場合は、データを壊さず、
負のエラーコード(VCE_EFULL)を返す。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_pop_nb_ia4">vce_binary_pop_nb_ia4</a>
</td></tr>
</table><br><br>
<a name="vce_binary_push_nb_ia8"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_push_nb_ia8</th></tr>
<tr><th>概要</th><td>8バイト整数(VCEI64)の配列をバッファに push する</td></tr>
<tr><th>カテゴリ</th><td>bin</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_binary_push_nb_ia8( char *out, int ofs, int maxlen, VCEI64 *ia, int num )</b></td>
<tr><th>arg 1</Th><td>char *out</td></tr>
<tr><th></th><td>出力バッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int ofs</td></tr>
<tr><th></th><td>実際に出力する場所の、バッファの先頭からのオフセット
</td></tr>
<tr><th>arg 3</Th><td>int maxlen</td></tr>
<tr><th></th><td>出力バッファの長さ
</td></tr>
<tr><th>arg 4</Th><td>VCEI64 *ia</td></tr>
<tr><th></th><td>出力する8バイト整数(int)の配列の先頭アドレス
</td></tr>
<tr><th>arg 5</Th><td>int num</td></tr>
<tr><th></th><td>出力する配列の要素数
</td></tr>
<tr><th>返り値</th><td>出力することによって移動した、あたらしいオフセットを返す。
出力に失敗した場合は負のエラーコードを返す。
</td></tr>
<tr><th>詳細説明</th><td>int型の配列の中身を出力バッファに push する。
対応する vce_binary_pop_nb_ia8 関数で取りだすことができる。
データはすべてネットワークバイトオーダで保存される。
出力バッファの長さが足りない場合は、データを壊さず、
負のエラーコード(VCE_EFULL)を返す。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_pop_nb_ia8">vce_binary_pop_nb_ia8</a>
</td></tr>
</table><br><br>
<a name="vce_binary_push_nb_stra"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_push_nb_stra</th></tr>
<tr><th>概要</th><td>ヌル終端された文字列の配列をバッファに push する</td></tr>
<tr><th>カテゴリ</th><td>bin</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_binary_push_nb_stra( char *out, int ofs, int maxlen, char **stra, int num, int eachmax )</b></td>
<tr><th>arg 1</Th><td>char *out</td></tr>
<tr><th></th><td>出力バッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int ofs</td></tr>
<tr><th></th><td>実際に出力する場所の、バッファの先頭からのオフセット
</td></tr>
<tr><th>arg 3</Th><td>int maxlen</td></tr>
<tr><th></th><td>出力バッファの長さ
</td></tr>
<tr><th>arg 4</Th><td>char **stra</td></tr>
<tr><th></th><td>出力する元になる文字列へのポインタの配列。
</td></tr>
<tr><th>arg 5</Th><td>int num</td></tr>
<tr><th></th><td>stra 引数で与える文字列へのポインタの配列の要素数。
</td></tr>
<tr><th>arg 6</Th><td>int eachmax</td></tr>
<tr><th></th><td>stra 引数で与える各文字列の最大長さ。
文字列が一つでもこの長さに達するとエラーとなる。
</td></tr>
<tr><th>返り値</th><td>出力することによって移動した ofs の新しい値。
バッファが一杯になったり、その他の理由で push に失敗した場合は
負のエラーコードを返す。
</td></tr>
<tr><th>詳細説明</th><td>文字列をバイナリデータに pack し、バッファに追加する。
各文字列の最大文字数制限を可能にするために、
eachmax という引数が追加されている。
num が 0 のときは、 stra には NULL を指定することができる。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_pop_nb_stra">vce_binary_pop_nb_stra</a>
</td></tr>
</table><br><br>
<a name="vce_binary_unpack"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_unpack</th></tr>
<tr><th>概要</th><td>バッファのバイナリデータをunpackして構造体の配列にする(古い)</td></tr>
<tr><th>カテゴリ</th><td>bin</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_binary_unpack( struct bin_info *bi, int bn, char *inp, int len )</b></td>
<tr><th>arg 1</Th><td>struct bin_info *bi</td></tr>
<tr><th></th><td>bin_info構造体の配列の先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int bn</td></tr>
<tr><th></th><td>bin_info構造体の配列の要素数
</td></tr>
<tr><th>arg 3</Th><td>char *inp</td></tr>
<tr><th></th><td>入力バッファの先頭アドレス
</td></tr>
<tr><th>arg 4</Th><td>int len</td></tr>
<tr><th></th><td>入力バッファの長さ(バイト数)
</td></tr>
<tr><th>返り値</th><td>成功したら実際にunpackした長さを返す。これは lenより小さい可能性がある。
lenより大きいことはない。データが足りない場合は、
VCE_EDATASHORTを返す。
</td></tr>
<tr><th>詳細説明</th><td>バイナリデータを、 bin_info 構造体の配列に指定されている通りに
unpackし、構造を持った状態に戻す。
主にプロトコル処理で使われる。
</td></tr>
<tr><th>知られているバグやTODO</th><td>現在は バイナリpush/pop 関数群によって，置きかえられている．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_pack">vce_binary_pack</a>
</td></tr>
</table><br><br>
<a name="vce_chop_string_destroy"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_chop_string_destroy</th></tr>
<tr><th>概要</th><td>文字列の終端の改行記号を消す</td></tr>
<tr><th>カテゴリ</th><td>text</td></tr>
<tr><th>対応OS</th><td></td></tr>
<tr><th>関数プロトタイプ</th><td><b>char * vce_chop_string_destroy( char *s )</b></td>
<tr><th>arg 1</Th><td>char *s</td></tr>
<tr><th></th><td>文字列の先頭アドレス
</td></tr>
<tr><th>返り値</th><td>文字列の先頭アドレスをそのまま返す
</td></tr>
<tr><th>詳細説明</th><td>strlen を用いて最後の文字を調べ、最後の文字が改行記号(LF)であれば
それを取りのぞいて返す。文字列の末尾が CRLF である場合は CRLFを取りのぞく。
</td></tr>
</table><br><br>
<a name="vce_circ_clear"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_clear</th></tr>
<tr><th>概要</th><td>circ_t のインスタンスを正式に初期化する。</td></tr>
<tr><th>カテゴリ</th><td></td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_circ_clear(circ_t *c )</b></td>
<tr><th>arg 1</Th><td>circ_t *c</td></tr>
<tr><th></th><td>初期化する対象となる circ_t
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>memsetなどを用いてゼロクリアしただけでは、正式にcirc_t を初期化したとは
言えない。正式に無効な circ_t を作るためには、本関数を使って初期化する
必要がある。
</td></tr>
</table><br><br>
<a name="vce_circ_close"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_close</th></tr>
<tr><th>概要</th><td>仮想回路(circ_t)を閉じる</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_circ_close( circ_t cir )</b></td>
<tr><th>arg 1</Th><td>circ_t cir</td></tr>
<tr><th></th><td>閉じる仮想回路
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>仮想回路を強制的に閉じる。
閉じたら、vce_tcpcontext_create関数の呼びだし時に
指定している、仮想回路用のcircclosewatcherが呼びだされてから、
資源が解放される。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_circ_get_index"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_get_index</th></tr>
<tr><th>概要</th><td>仮想回路(circ_t)のインデックス番号を得る</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_circ_get_index( tcpcontext_t t, circ_t c );</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t t</td></tr>
<tr><th></th><td>パケットベクトライザサーバの設定になっているTCPコンテキスト
</td></tr>
<tr><th>arg 2</Th><td>circ_t c</td></tr>
<tr><th></th><td>仮想回路の構造体(circ_t)
</td></tr>
<tr><th>返り値</th><td>インデックス。エラーの場合は負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>仮想回路は、TCPコンテキストごとに1次元配列として管理されていて、
その配列へのインデックス値を得る。
このインデックス値は一意性をもっているため、
コネクションのセッションIDとして使用できる。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_circ_get_struct_from_index">vce_circ_get_struct_from_index</a>
</td></tr>
</table><br><br>
<a name="vce_circ_get_parent_conn"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_get_parent_conn</th></tr>
<tr><th>概要</th><td> 指定した circ_t が属するconn_t を取得する。</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>conn_t vce_circ_get_parent_conn( circ_t c)</b></td>
<tr><th>arg 1</Th><td>circ_t c</td></tr>
<tr><th></th><td>取得する元になるcirc_t
</td></tr>
<tr><th>返り値</th><td></td></tr>
<tr><th>詳細説明</th><td></td></tr>
</table><br><br>
<a name="vce_circ_get_remote_addr_string"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_get_remote_addr_string</th></tr>
<tr><th>概要</th><td>仮想回路(circ_t)のリモートピアのアドレスとポート番号を文字列で得る</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>char * vce_circ_get_remote_addr_string( circ_t ct, char *s, int max )</b></td>
<tr><th>arg 1</Th><td>circ_t ct</td></tr>
<tr><th></th><td>アドレスを取得したい仮想回路
</td></tr>
<tr><th>arg 2</Th><td>char *s</td></tr>
<tr><th></th><td>結果文字列を格納するためのバッファ
</td></tr>
<tr><th>arg 3</Th><td>int max</td></tr>
<tr><th></th><td>バッファのサイズ
</td></tr>
<tr><th>返り値</th><td>ワーク領域(引数s)をそのまま返す
</td></tr>
<tr><th>詳細説明</th><td>プロトコル独立なアプリケーションにおいて、circ_t のリモートピアのアドレスを
文字列で取得する。出力の形式に関しては vce_conn_get_remote_addr_string と
同等の動作をする。
アプリケーションはできるだけプロトコル独立に記述されるべきなので、
vce_circ_get_remote_ipv6_addr 等といった関数よりも
本関数を使用するべきである。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_remote_addr_string">vce_conn_get_remote_addr_string</a>
</td></tr>
</table><br><br>
<a name="vce_circ_get_remote_ipv4_addr"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_get_remote_ipv4_addr</th></tr>
<tr><th>概要</th><td>仮想回路のリモートピアのIPv4アドレス(32bit)を得る</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_circ_get_remote_ipv4_addr( circ_t ct, unsigned int *a, unsigned short *p )</b></td>
<tr><th>arg 1</Th><td>circ_t ct</td></tr>
<tr><th></th><td>アドレスを求める仮想回路
</td></tr>
<tr><th>arg 2</Th><td>unsigned int *a</td></tr>
<tr><th></th><td>IPv4アドレス(出力) ネットワークバイトオーダで出力されることに注意
</td></tr>
<tr><th>arg 3</Th><td>unsigned short *p</td></tr>
<tr><th></th><td>ポート番号。ネットワークバイトオーダであることに注意
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>リモートピアのIPv4のアドレスとポートを求める。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_remote_ipv4_addr">vce_conn_get_remote_ipv4_addr</a>
</td></tr>
</table><br><br>
<a name="vce_circ_get_remote_ipv4_addr_string"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_get_remote_ipv4_addr_string</th></tr>
<tr><th>概要</th><td>仮想回路のリモートピアのIPv4アドレス(32bit)を文字列で得る</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>char * vce_circ_get_remote_ipv4_addr_string( circ_t ct, char *s, int max )</b></td>
<tr><th>arg 1</Th><td>circ_t ct</td></tr>
<tr><th></th><td>アドレスを求める仮想回路
</td></tr>
<tr><th>arg 2</Th><td>char *s</td></tr>
<tr><th></th><td>出力先の文字列の先頭アドレス
</td></tr>
<tr><th>arg 3</Th><td>int max</td></tr>
<tr><th></th><td>出力先の文字列の最大長さ
</td></tr>
<tr><th>返り値</th><td>s のアドレスをそのまま返す。
</td></tr>
<tr><th>詳細説明</th><td>文字列でリモートクライアントのアドレスを得るが、
出力文字列のバッファは最低50バイトの長さをもつものを用意すること。
これは snprintf を持たない環境が存在することに起因している。
本関数は IPv4 専用なので、プロトコル独立をめざすために、
アプリケーションでは本関数を使わず、 vce_circ_get_remote_addr_string
関数を使うべきである。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_circ_get_remote_addr_string">vce_circ_get_remote_addr_string</a>
<a href="#vce_circ_get_remote_ipv4_addr">vce_circ_get_remote_ipv4_addr</a>
</td></tr>
</table><br><br>
<a name="vce_circ_get_remote_ipv6_addr"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_get_remote_ipv6_addr</th></tr>
<tr><th>概要</th><td>仮想回路のリモートピアのIPv6アドレス(128bit)を得る</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_circ_get_remote_ipv6_addr( circ_t ct, char *a, unsigned short *p )</b></td>
<tr><th>arg 1</Th><td>circ_t ct</td></tr>
<tr><th></th><td>アドレスを求める仮想回路
</td></tr>
<tr><th>arg 2</Th><td>char *a</td></tr>
<tr><th></th><td>IPv6アドレス(出力) ネットワークバイトオーダで出力されることに注意。
このバッファは16バイト以上のサイズを確保しておく事。
</td></tr>
<tr><th>arg 3</Th><td>unsigned short *p</td></tr>
<tr><th></th><td>ポート番号。ネットワークバイトオーダであることに注意
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>リモートピアのIPv6のアドレスとポートを求める。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_circ_get_remote_ipv6_addr_string">vce_circ_get_remote_ipv6_addr_string</a>
</td></tr>
</table><br><br>
<a name="vce_circ_get_remote_ipv6_addr_string"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_get_remote_ipv6_addr_string</th></tr>
<tr><th>概要</th><td>仮想回路のリモートピアのIPv6アドレス(128bit)を文字列で得る</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>char * vce_circ_get_remote_ipv6_addr_string( circ_t ct, char *s, int max )</b></td>
<tr><th>arg 1</Th><td>circ_t ct</td></tr>
<tr><th></th><td>アドレスを求める仮想回路
</td></tr>
<tr><th>arg 2</Th><td>char *s</td></tr>
<tr><th></th><td>出力先の文字列の先頭アドレス
</td></tr>
<tr><th>arg 3</Th><td>int max</td></tr>
<tr><th></th><td>出力先の文字列のサイズ
</td></tr>
<tr><th>返り値</th><td>s のアドレスをそのまま返す。
</td></tr>
<tr><th>詳細説明</th><td>文字列でリモートクライアントのアドレスを得るが、
出力文字列のバッファは最低50バイトの長さをもつものを用意すること。
これは snprintf を持たない環境が存在することに起因している。
本関数は IPv6 専用なので、プロトコル独立をめざすために、
アプリケーションでは本関数を使わず、 vce_circ_get_remote_addr_string
関数を使うべきである。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_circ_get_remote_addr">vce_circ_get_remote_addr</a>
<a href="#vce_circ_get_remote_addr_string">vce_circ_get_remote_addr_string</a>
<a href="#vce_circ_get_remote_ipv6_addr">vce_circ_get_remote_ipv6_addr</a>
</td></tr>
</table><br><br>
<a name="vce_circ_get_state_buffer"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_get_state_buffer</th></tr>
<tr><th>概要</th><td>仮想回路の状態管理バッファへのポインタを得る</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void * vce_circ_get_state_buffer( circ_t ct, int *len );</b></td>
<tr><th>arg 1</Th><td>circ_t ct</td></tr>
<tr><th></th><td>管理バッファを得たい仮想回路
</td></tr>
<tr><th>arg 2</Th><td>int *len</td></tr>
<tr><th></th><td>状態バッファの長さ。結果引数。 NULL を指定できる。
</td></tr>
<tr><th>返り値</th><td>バッファへのポインタ。状態のないプロトコルの場合は、NULLを返す
</td></tr>
<tr><th>詳細説明</th><td>circ_t に対応付けられている状態管理バッファのポインタを得る。
circ_t を状態ありプロトコルとして定義するには、
vce_tcpcontext_create 関数の呼びだし時に、 statebuf_size 引数を0より
大きな値にする。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_circ_get_struct_from_index"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_get_struct_from_index</th></tr>
<tr><th>概要</th><td>仮想回路(circ_t)の構造体を、インデックス値から得る</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>circ_t vce_circ_get_struct_from_index( tcpcontext_t t, int index );</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t t</td></tr>
<tr><th></th><td>その仮想回路が含まれるTCPコンテキスト
</td></tr>
<tr><th>arg 2</Th><td>int index</td></tr>
<tr><th></th><td>circ_t のインデックス。 vce_circ_get_index 関数を使って得た値。
</td></tr>
<tr><th>返り値</th><td>構造体そのもの。
</td></tr>
<tr><th>詳細説明</th><td>仮想回路のインデックスから、構造体そのものを得るときに使用する。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_circ_get_index">vce_circ_get_index</a>
</td></tr>
</table><br><br>
<a name="vce_circ_get_tcpcontext"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_get_tcpcontext</th></tr>
<tr><th>概要</th><td>circ_t から tcpcontext_t を得る</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>tcpcontext_t vce_circ_get_tcpcontext( circ_t c )</b></td>
<tr><th>arg 1</Th><td>circ_t c</td></tr>
<tr><th></th><td>tcpcontext_t を取りだしたい circ_t
</td></tr>
<tr><th>返り値</th><td>指定された circ_t が属する tcpcontext_t
</td></tr>
<tr><th>詳細説明</th><td>この関数は主に VCE 内部用に使われ、アプリケーションから使われることは
少ない。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_tcpcontext">vce_conn_get_tcpcontext</a>
</td></tr>
</table><br><br>
<a name="vce_circ_is_equal"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_is_equal</th></tr>
<tr><th>概要</th><td>ふたつの仮想回路(circ_t)が等しいかどうか調べる</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td></td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_circ_is_equal( circ_t c1, circ_t c2 )</b></td>
<tr><th>arg 1</Th><td>circ_t c1</td></tr>
<tr><th></th><td>調査対象となる仮想回路、ひとつ目
</td></tr>
<tr><th>arg 2</Th><td>circ_t c2</td></tr>
<tr><th></th><td>調査対象となる仮想回路、ふたつ目
</td></tr>
<tr><th>返り値</th><td>ふたつの仮想回路が等しいなら1、等しくないなら0を返す。
</td></tr>
<tr><th>詳細説明</th><td>ふたつの仮想回路が等しいかどうか調べる。
この二つのcirc_tを使った書きこみと読みこみは全く同じ結果になる。
具体的には同じポインタとシリアル番号を持っているコネクションとなる。
</td></tr>
</table><br><br>
<a name="vce_circ_is_valid"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_is_valid</th></tr>
<tr><th>概要</th><td>仮想回路(circ_t)が有効かどうか調べる。</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td></td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_circ_is_valid( circ_t ct )</b></td>
<tr><th>arg 1</Th><td>circ_t ct</td></tr>
<tr><th></th><td>調査する対象となる仮想回路
</td></tr>
<tr><th>返り値</th><td>ct が有効なら1、そうでないなら0を返す。
</td></tr>
<tr><th>詳細説明</th><td>接続に対する書きこみバッファが満杯になっている場合でもコネクション自体が
有効である場合は1を返す。
</td></tr>
</table><br><br>
<a name="vce_circ_set_alarmwatcher"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_set_alarmwatcher</th></tr>
<tr><th>概要</th><td>circ_t ごとにアラーム時刻とコールバック関数を設定変更する</td></tr>
<tr><th>カテゴリ</th><td>watcher</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>time_t vce_circ_set_alarmwatcher( circ_t c, int sec , int (*alarmwatcher)(circ_t))</b></td>
<tr><th>arg 1</Th><td>circ_t c</td></tr>
<tr><th></th><td>設定を変更したい circ_t
</td></tr>
<tr><th>arg 2</Th><td>int sec</td></tr>
<tr><th></th><td>新しく設定する秒
</td></tr>
<tr><th>arg 3</Th><td>int (*alarmwatcher)(cric_t c)</td></tr>
<tr><th></th><td>アラーム機能によって呼び出されるコールバック関数
</td></tr>
<tr><th>返り値</th><td>　本関数が呼ばれたグローバル時刻を返す。その値からパラメータのsecを足した時刻がアラームの発生する時刻である。
</td></tr>
<tr><th>詳細説明</th><td>vce_conn_set_alarmwathcer 参照
</td></tr>
<tr><th>使用例</th><td>vce_conn_set_alarmwathcer 参照
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_set_alarmwatcher">vce_conn_set_alarmwatcher</a>
</td></tr>
</table><br><br>
<a name="vce_circ_set_timeout"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_set_timeout</th></tr>
<tr><th>概要</th><td>circ_t ごとにタイムアウト時間を設定変更する</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_circ_set_timeout( circ_t c, int sec )</b></td>
<tr><th>arg 1</Th><td>circ_t c</td></tr>
<tr><th></th><td>設定を変更したい circ_t
</td></tr>
<tr><th>arg 2</Th><td>int sec</td></tr>
<tr><th></th><td>新しいタイムアウト値
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>デフォルト状態では，circ_t のタイムアウト時間の長さは，
vce_tcpcontext_create 関数で指定したタイムアウト時間と同じになる．
しかし，vce_tcpcontext_create 関数で指定するタイムアウト時間は，
SWP と本体サーバの間のコネクションのタイムアウト時間としても使われるため，
通常は非常に長い時間が設定される．
このため，circ_t のタイムアウト時間がアプリケーションにとって必要な時間
よりも長い場合がほとんどとなる．
このことを回避してアプリケーションにとって適切なタイムアウト時間を設定
するために，本関数を使うことができる．
acceptwatcher 内で本関数を呼びだしてタイムアウト時間を再設定するのが，
典型的だと言える(サンプルコードを参照)．
</td></tr>
<tr><th>使用例</th><td>  int application_circ_acceptwatcher( circ_t ct )
  {
      vce_circ_set_timeout( ct, 100 );
  }
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_tcpcontext_set_circ_acceptwatcher">vce_tcpcontext_set_circ_acceptwatcher</a>
</td></tr>
</table><br><br>
<a name="vce_circ_switch"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_switch</th></tr>
<tr><th>概要</th><td>circ_t コネクションを別なサーバにスイッチする。</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_circ_switch( circ_t c, int server_id, const char *data, int len )</b></td>
<tr><th>arg 1</Th><td>circ_t c</td></tr>
<tr><th></th><td>スイッチ対象となるコネクション。
</td></tr>
<tr><th>arg 2</Th><td>int server_id</td></tr>
<tr><th></th><td>スイッチ先のサーバーID.
</td></tr>
<tr><th>arg 3</Th><td>char *data</td></tr>
<tr><th></th><td>スイッチ先のサーバに伝える付帯情報。
ゲームなどアプリケーションでスイッチの処理に付帯させてキャラクタIDなどを
送信したい場合に便利である。
付帯情報には「ポインタ」を入れないこと。
ポインタは他のマシンでは意味をもたないため、
注意が必要である。普通は、各情報の「ID」や「インデックス」や
情報のコピーを入れる。
ほかのサーバでのバイトオーダやアラインメントが異なるときのために、
vce_binary_push_nb_i1 などのバイナリパッカーを用いて情報を圧縮して転送
するのがよいだろう。
なお、circ_t の「状態バッファ」も別にスイッチ先のサーバに転送されるので、
状態バッファの内容だけで十分な場合は、
付帯情報を添付することは必要ないだろう。
</td></tr>
<tr><th>arg 4</Th><td>int len</td></tr>
<tr><th></th><td>付帯情報の長さ。
</td></tr>
<tr><th>返り値</th><td>処理が成功したら0、失敗したら負のエラーコードを返す。
成功といっても相手のサーバにコネクションがスイッチし終わることではなく、
あくまでスイッチ要求が送信キューに入ったことを意味するだけで、
実際の処理が成功したかどうかは、 vce_tcpcontext_set_circ_switchresultwatcher
関数で指定するコールバック関数を呼ぶ必要がある。
</td></tr>
<tr><th>詳細説明</th><td>circ_t コネクションを別のサーバに移転させる処理の基本関数である。
コネクションスイッチでは、「付帯情報」のほかに、
「状態バッファ」の内容もコピーされる。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_set_circ_switchresultwatcher">vce_tcpcontext_set_circ_switchresultwatcher</a>
<a href="#vce_tcpcontext_set_circ_switchwatcher">vce_tcpcontext_set_circ_switchwatcher</a>
</td></tr>
</table><br><br>
<a name="vce_circ_test_sanity"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_test_sanity</th></tr>
<tr><th>概要</th><td>circ_t の内容が有効かどうか，最も精密に調べる</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_circ_test_sanity( tcpcontext_t tt, circ_t ct, int *type )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tt</td></tr>
<tr><th></th><td>その circ が派生した tcpcontext_t
</td></tr>
<tr><th>arg 2</Th><td>circ_t ct</td></tr>
<tr><th></th><td>テストしたい circ_t
</td></tr>
<tr><th>arg 3</Th><td>int *type</td></tr>
<tr><th></th><td>調べた結果の詳細．
</td></tr>
<tr><th>返り値</th><td>正しいなら1，そうでないなら0
type に，正しくない場合の種類の値を入れて返す．
type は正しい場合は0．
</td></tr>
<tr><th>詳細説明</th><td>circ_t はシリアル番号とアクセス用ポインタのふたつの情報を持っている．
vce_circ_is_valid関数は，circ_tが保持しているポインタを使って
メモリにアクセセスする前に，ヌルポインタとの比較のみを行なう．
しかし，ポインタがアプリケーションによって壊されているなどの場合，
そのような調べかただけではアプリケーションのメモリアクセス違反
をひきおこす場合がある．
本関数ではそのような問題を防ぐために，
より精密にポインタの中身をチェックする．
以下では返り値typeの値と意味の対応を列挙している．
<ul>
<LI>5  引数 tt (tcpcontext) が null ポインターである．
<LI>6  引数 tt (tcpcontext) が， VCEが割りあてていない値になっている．
<LI>10  引数 tt (tcpcontext) が，circ_t を生成できないモードになっている．
<LI>20  引数 tt (tcpcontext) が，状態バッファを使うように設定されているが，
内部の状態バッファ用変数が破壊されている(VCEのバグの可能性)．
<LI>30  引数 ct のポインタが NULL である
<LI>40  引数 ct のポインタが奇数アドレスである．つまり壊れている．
<LI>50  引数 ct のシリアル番号がゼロであり，不正．
<LI>60  引数 ct のポインタがVCEが割りあてたはずの値になっていない．
<LI>70  引数 ct の親コネクションのポインタが不正(VCEのバグの可能性)
<LI>80  引数 ct の親コネクションのシリアルが一致していない(VCEのバグの可能性)
<LI>90  引数 ct の状態バッファのポインタがNULLであり，不正．
<LI>100  引数 ct の状態バッファのポインタがVCEが割りあてたはずの値でない
</ul>

</td></tr>
<tr><th>See also</th><td>
<a href="#vce_circ_is_valid">vce_circ_is_valid</a>
</td></tr>
</table><br><br>
<a name="vce_circ_writable"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_writable</th></tr>
<tr><th>概要</th><td>仮想回路に対してどれだけのデータが書きこみ可能かを調べる</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_circ_writable( circ_t ct )</b></td>
<tr><th>arg 1</Th><td>circ_t ct</td></tr>
<tr><th></th><td>調査対象の仮想回路
</td></tr>
<tr><th>返り値</th><td>書きこみが可能な長さを返す。書きこみが可能な場合は1以上、
仮想回路が有効だが書きこみできない場合は0、
仮想回路が有効でない場合は負のエラーコードを返す。
</td></tr>
<tr><th>詳細説明</th><td>仮想回路の書きこみは、すべて上位のTCPコネクションのバッファに溜められる。
すなわち仮想回路ごとに独立な書きこみ用バッファが用意されているわけではない。
このため複数のcirc_t に対してこの関数を呼びだして調査すると、
同じ値を返すことがある。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_writable">vce_conn_writable</a>
</td></tr>
</table><br><br>
<a name="vce_circ_write"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_write</th></tr>
<tr><th>概要</th><td>TCPコネクション中の仮想回路(circ_t)にデータを書きこむ。</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_circ_write( circ_t cir, char *data, int datalen )</b></td>
<tr><th>arg 1</Th><td>circ_t cir</td></tr>
<tr><th></th><td>書きこむ先の仮想回路。仮想回路の説明は、tcp カテゴリの説明を参照。
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>書きこむデータ
</td></tr>
<tr><th>arg 3</Th><td>int datalen</td></tr>
<tr><th></th><td>書きこむデータの長さ
</td></tr>
<tr><th>返り値</th><td>成功したらdatalenを、失敗したら負のエラーコードを返す。
成功の場合は、かならずdatalenであり、
datalenより小さい正の値が返ることはない。これは、全部書きこむか、
全く書きこまないかどちらかであることを意味する。
</td></tr>
<tr><th>詳細説明</th><td>VCEでは1本のTCPコネクション(conn_t)の中に複数の仮想コネクションを入れる
ことができるが、その仮想回路にデータを直接に書きこむのが
vce_circ_write である。
この関数はデータを生で書きこむため、
さらに bin16 プロトコルパーサなどを使ってデータ処理をすることが
通常のアプリケーションでは必要である。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_cleanup_all_search_engine"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_cleanup_all_search_engine</th></tr>
<tr><th>概要</th><td>すべてのサーチエンジンを解放する</td></tr>
<tr><th>カテゴリ</th><td>search</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_cleanup_all_search_engine( void )</b></td>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>VCEが内部的に使用しているサーチエンジンをすべて解放する。
中身は、vce_cleanup_search_engineをループで呼びだしているだけ。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_init_int2_search">vce_init_int2_search</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_init_string_search">vce_init_string_search</a>
</td></tr>
</table><br><br>
<a name="vce_cleanup_search_engine"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_cleanup_search_engine</th></tr>
<tr><th>概要</th><td>サーチエンジンを解放する</td></tr>
<tr><th>カテゴリ</th><td>search</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_cleanup_search_engine( int index )</b></td>
<tr><th>返り値</th><td>成功したら0、失敗したら負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>サーチエンジンindex(サーチデスクリプタ)を指定してサーチエンジンを解放する。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_cleanup_search_engine">vce_cleanup_search_engine</a>
<a href="#vce_init_int2_search">vce_init_int2_search</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_init_string_search">vce_init_string_search</a>
</td></tr>
</table><br><br>
<a name="vce_conn_break_heartbeat"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_break_heartbeat</th></tr>
<tr><th>概要</th><td>コールバック関数内から、connのプロトコル処理を中止させる</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_conn_break_heartbeat()</b></td>
<tr><th>返り値</th><td></td></tr>
<tr><th>詳細説明</th><td>conn_parserコールバック関数内で、この関数を呼ぶことでそのheartbeat内でのそのconnの
プロトコル処理を中止する。
同一heartbeat内で後続のパケットを処理したくない場合に使用する。たとえばマップの
切り替えの際にいったんプロトコルの処理を停止して、フェードアウト、マップの読み込み、
フェードインを行いたいときなどに利用する。
<BR>
これは、VCE-0.4.99以前のVCEでコールバック関数で０を返す場合に相当する。
現在、その仕様は変更されたため、このAPIが追加された。
<BR>
コールバック関数外でこの関数を呼んでも、全く無意味である。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_set_conn_call_parser_per_heartbeat">vce_tcpcontext_set_conn_call_parser_per_heartbeat</a>
</td></tr>
</table><br><br>
<a name="vce_conn_clear"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_clear</th></tr>
<tr><th>概要</th><td>conn_t型のインスタンスを初期化する</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_conn_clear( conn_t *c )</b></td>
<tr><th>arg 1</Th><td>conn_t *c</td></tr>
<tr><th></th><td>初期化するconn_tへのポインタ
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>初期化済みな conn_t を正式に作る唯一の方法である。 memset でゼロクリア
しても、正式な方法ではない。
</td></tr>
</table><br><br>
<a name="vce_conn_close"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_close</th></tr>
<tr><th>概要</th><td>TCPコネクションを閉じて解放する。</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_conn_close( conn_t ct )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>閉じたいコネクションの conn_t
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>TCPコネクションを閉じる。実際には、次のheartbeatで close 処理をするための
フラグを立てるだけである。常に成功するが、すでに close フラグが立っている
コネクションに対して本関数を呼びだした場合は、 verbose モードでは
warning が出る。
このように vce_heartbeat を呼びださない限り、
実際にコネクションは閉じられないので注意が必要である。
VCEライブラリによってcloseされたコネクションは、アプリケーションが次に
write しようとしたときにエラーとして検出される。<BR>
また、資源を解放する前に、vce_tcpcontext_create時に指定している
closewatcherが呼びだされる。
Tips として， vce_conn_close した直後にタイムアウト値を通常よりも短く
設定しなおすことで，迅速な close 処理を期待できる．
そうしない場合，もしコネクションにデータが残っていたら，
デフォルトのタイムアウト時間を過ぎるまで，ずっとコネクションが残った
ままになるからである(サンプルコードを参照)．
引数が異常だった場合は VCE_EINVAL,
すでに閇じられているのに，さらに閇じようとした場合は VCE_EALREADY が，
vce_get_last_error で返される．
</td></tr>
<tr><th>使用例</th><td>// クローズ後，短いタイムアウト値を設定
vce_conn_close( co );
vce_conn_set_timeout( co, 0 );
</td></tr>
<tr><th>See also</th><td>
<a href="# vce_tcpcontext_connect"> vce_tcpcontext_connect</a>
<a href="# vce_tcpcontext_create"> vce_tcpcontext_create</a>
<a href="#vce_conn_writable">vce_conn_writable</a>
</td></tr>
</table><br><br>
<a name="vce_conn_close_tcpcontext_all"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_close_tcpcontext_all</th></tr>
<tr><th>概要</th><td>あるtcpが管理しているすべてのコネクションを切断する</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_conn_close_tcpcontext_all( tcpcontext_t tp )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>切断対象となるコネクションを管理している tcpcontext_t
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>すべてのコネクションを切断する。 closewatcher、 fainalizer は呼びだされる。
切断は「切断フラグ」を立てて次以降の vce_heartbeat を使って
実際の入出力をするため、本関数を呼びだした後は vce_heartbeat の呼びだしが
かならず必要である。
ゲームのサーバなどでは、サーバを正常に終了させるときには、
まず本関数の前に、全部のクライアントに対して shutdown の旨を伝え、
vce_tcpcontext_enable_accept 関数で新規の accept をブロックし、
そのあとこの関数を呼びだしてコネクションを閉じるという段階を
経るのが理想的である。
tcpcontext が circ_t を管理している場合でも、
本関数を使用してコネクションを切断すれば中継サーバが自動的に
全クライアントとのコネクションを切断するため、
問題なくコネクションを切断できる。
なお、本関数はサーバでもクライアントでも同様に動作する。
verbose モードのときは1本コネクションを切るごとにログを出力する(verbose).
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_enable_accept">vce_tcpcontext_enable_accept</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_buffer"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_buffer</th></tr>
<tr><th>概要</th><td>conn_t の受信/送信バッファを得る</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td></td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_conn_get_buffer( conn_t c, char **rb, int  *rblen, char **wb, int *wblen )</b></td>
<tr><th>arg 1</Th><td>conn_t c</td></tr>
<tr><th></th><td>バッファを取りだしたい conn_t
</td></tr>
<tr><th>arg 2</Th><td>char **rb</td></tr>
<tr><th></th><td>読みこみバッファの先頭アドレスを格納したいポインタへのポインタ。
読みこみバッファの先頭アドレスを返す
</td></tr>
<tr><th>arg 3</Th><td>int *rblen</td></tr>
<tr><th></th><td>読みこみバッファの長さを格納したい int 型の変数へのポインタ。
読みこみバッファの使用中の長さを返す。それは0以上の値を取る。
</td></tr>
<tr><th>arg 4</Th><td>char **wb</td></tr>
<tr><th></th><td>書きこみバッファの先頭アドレスを格納したいポインタへのポインタ。
書きこみバッファの先頭アドレスを返す
</td></tr>
<tr><th>arg 5</Th><td>int *wblen</td></tr>
<tr><th></th><td>書きこみバッファの長さを格納したい int 型の変数へのポインタ。
書きこみバッファの使用中の長さを返す。それは0以上の値を取る。
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>オリジナルのプロトコルパーサを定義したいアプリケーションは
この関数を使って読みこみバッファを直接参照し、
独自の動作を定義することができる。
このようにして作った独自のプロトコルパーサは、
vce_tcpcontext_set_conn_parser 関数等をもちいて登録することができる。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_shrink_readbuf">vce_conn_shrink_readbuf</a>
<a href="#vce_tcpcontext_set_conn_parser">vce_tcpcontext_set_conn_parser</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_child_circ"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_child_circ</th></tr>
<tr><th>概要</th><td> 指定した conn_t に属するcirc_t を取得する。</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_conn_get_child_circ( conn_t c , circ_t *a, int max)</b></td>
<tr><th>arg 1</Th><td>conn_t c</td></tr>
<tr><th></th><td>取得する元になるconn_t
</td></tr>
<tr><th>arg 2</Th><td>circ_t *a</td></tr>
<tr><th></th><td>配列を出力する先頭アドレス
</td></tr>
<tr><th>arg 3</Th><td>int max</td></tr>
<tr><th></th><td>配列の最大要素数
</td></tr>
<tr><th>返り値</th><td>配列を埋めた数を返す(0以上の値)。
</td></tr>
<tr><th>詳細説明</th><td>ひとつのconn_t に属する仮想回路を配列にコピーして出力する。
</td></tr>
</table><br><br>
<a name="vce_conn_get_index"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_index</th></tr>
<tr><th>概要</th><td>TCPコネクション(conn_t)のVCE内でのindexを求める</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_conn_get_index( conn_t c );</b></td>
<tr><th>arg 1</Th><td>conn_t c</td></tr>
<tr><th></th><td>インデックス値を求めたいコネクション
</td></tr>
<tr><th>返り値</th><td>インデックス値。エラーの場合は負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>conn_t 構造体はVCE内部で1次元配列として管理されているので、
その配列へのインデックスはconn_tを指定するために一意なものとして利用できる。
したがって、「セッションID」のような用途に使える。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_struct_from_index">vce_conn_get_struct_from_index</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_local_addr_string"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_local_addr_string</th></tr>
<tr><th>概要</th><td>TCPコネクションのローカルアドレスとポートを文字列で得る</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>char * vce_conn_get_local_addr_string( conn_t ct, char *s, int max )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>アドレスを取得したいコネクション
</td></tr>
<tr><th>arg 2</Th><td>char *s</td></tr>
<tr><th></th><td>結果文字列を格納するためのバッファ
</td></tr>
<tr><th>arg 3</Th><td>int max</td></tr>
<tr><th></th><td>バッファのサイズ
</td></tr>
<tr><th>返り値</th><td>ワーク領域(引数 s)をそのまま返す
</td></tr>
<tr><th>詳細説明</th><td>conn_t のローカルアドレスを文字列で取得する。取得できる
アドレスのフォーマットは、
vce_conn_get_remote_addr_string 関数と同じである。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_remote_addr_string">vce_conn_get_remote_addr_string</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_local_ipv4_addr"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_local_ipv4_addr</th></tr>
<tr><th>概要</th><td>TCPコネクションのローカルIPv4アドレス(32bit)を得る</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_conn_get_local_ipv4_addr( conn_t ct, unsigned int *a, unsigned short *p )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>処理対象となるコネクション
</td></tr>
<tr><th>arg 2</Th><td>unsigned int *a</td></tr>
<tr><th></th><td>32ビットのIPv4アドレス(ネットワークバイトオーダ)
を返すためのポインタ。NULLを指定すると出力しない。
</td></tr>
<tr><th>arg 3</Th><td>unsigned short *p</td></tr>
<tr><th></th><td>ポート番号(ネットワークバイトオーダ)
を返すためのポインタ。NULLを指定すると出力しない。
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>出力はネットワークバイトオーダとなっているので、
必要に応じて、 ntohs, ntohl, などを使用して変換すること。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_remote_ipv4_addr">vce_conn_get_remote_ipv4_addr</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_local_ipv4_addr_string"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_local_ipv4_addr_string</th></tr>
<tr><th>概要</th><td>TCPコネクションのローカルIPv4アドレスとポートを文字列で得る</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>char * vce_conn_get_local_ipv4_addr_string( conn_t ct, char *s, int max )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>処理対象となるコネクション
</td></tr>
<tr><th>arg 2</Th><td>char *s</td></tr>
<tr><th></th><td>出力先文字列の先頭アドレス
</td></tr>
<tr><th>arg 3</Th><td>int max</td></tr>
<tr><th></th><td>出力先文字列の最大長さ
</td></tr>
<tr><th>返り値</th><td>s のアドレスをそのまま返す
</td></tr>
<tr><th>詳細説明</th><td>本関数は IPv4 専用で、ソケットのこちら側の端点のアドレスを求める。
こちら側とは、本関数を呼びだしたプログラムが動作している側の端点である。
本関数は IPv4 専用なので、プロトコル独立をめざすために、本関数ではなく
vce_conn_get_local_addr_string 関数を使うことを推奨する。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_local_addr_string">vce_conn_get_local_addr_string</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_local_ipv6_addr"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_local_ipv6_addr</th></tr>
<tr><th>概要</th><td>TCPコネクションのローカルIPv6アドレス(128bit)を得る</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_conn_get_local_ipv6_addr( conn_t ct, char *a, unsigned short *p )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>処理対象となるコネクション
</td></tr>
<tr><th>arg 2</Th><td>char *a</td></tr>
<tr><th></th><td>128ビットのIPv6アドレス(ネットワークバイトオーダ)
を返すためのポインタ。NULLを指定すると出力しない。
アドレスはネットワークバイトオーダで16バイトが、
そのままバッファに格納される。したがってこのバッファには16バイト以上の
メモリ領域を指定する必要がある。
</td></tr>
<tr><th>arg 3</Th><td>unsigned short *p</td></tr>
<tr><th></th><td>ポート番号(ネットワークバイトオーダ)
を返すためのポインタ。NULLを指定すると出力しない。
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>vce_conn_get_remote_ipv4_addr 関数の IPv6版．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_remote_ipv4_addr">vce_conn_get_remote_ipv4_addr</a>
<a href="#vce_conn_get_remote_ipv6_addr">vce_conn_get_remote_ipv6_addr</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_local_ipv6_addr_string"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_local_ipv6_addr_string</th></tr>
<tr><th>概要</th><td>TCPコネクションのローカルIPv6アドレスとポートを文字列で得る</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>char *vce_conn_get_local_ipv6_addr_string( conn_t ct, char *s, int max )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>処理対象となる conn_t
</td></tr>
<tr><th>arg 2</Th><td>char *s</td></tr>
<tr><th></th><td>出力先文字列の先頭アドレス
</td></tr>
<tr><th>arg 3</Th><td>int max</td></tr>
<tr><th></th><td>出力先文字列の最大長さ
</td></tr>
<tr><th>返り値</th><td>s のアドレスをそのまま返す, エラーの場合は  NULL を返す
</td></tr>
<tr><th>詳細説明</th><td>TCP ソケットのローカルアドレスを文字列で得る。文字列の形式は、
vce_conn_get_remote_addr_string 関数と同じ。
この関数は  IPv6 専用でプロトコル独立でないため、
vce_conn_get_local_addr_string 関数の使用を推奨する。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_local_addr_string">vce_conn_get_local_addr_string</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_remote_addr_string"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_remote_addr_string</th></tr>
<tr><th>概要</th><td>TCPコネクションのリモートピアのアドレスとポートを文字列で得る</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>char *vce_conn_get_remote_addr_string( conn_t ct, char *s, int max )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>アドレスを取得したいコネクション
</td></tr>
<tr><th>arg 2</Th><td>char *s</td></tr>
<tr><th></th><td>結果文字列を格納するためのバッファ
</td></tr>
<tr><th>arg 3</Th><td>int max</td></tr>
<tr><th></th><td>バッファのサイズ
</td></tr>
<tr><th>返り値</th><td>ワーク領域(引数 s)をそのまま返す
</td></tr>
<tr><th>詳細説明</th><td>プロトコル独立なアプリケーションにおいて、 conn_t のリモートピアのアドレスを
文字列で取得する。現在 VCE は ipv4 と ipv6 に対応しているが、
名前を逆引きせずに、 ipv4 では"192.168.0.11234" 、
ipv6 では "fe802d0b7fffec6f4cd.5678" といった感じで返す。
ipv4 では最後のポート番号を示すトークンが "" で区切られているのに対し、
ipv6 では "." で区切られていることに注意。
返された文字列がどのプロトコルのものかを判定する処理はアプリケーションに
任されている。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_local_addr_string">vce_conn_get_local_addr_string</a>
<a href="#vce_conn_get_remote_ipv4_addr_string">vce_conn_get_remote_ipv4_addr_string</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_remote_ipv4_addr"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_remote_ipv4_addr</th></tr>
<tr><th>概要</th><td>TCPコネクションのリモートピアのIPv4アドレス(32bit)を得る</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_conn_get_remote_ipv4_addr( conn_t ct, unsigned int *a, unsigned short *p )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>処理対象となるコネクション
</td></tr>
<tr><th>arg 2</Th><td>unsigned int *a</td></tr>
<tr><th></th><td>32ビットのIPv4アドレス(ネットワークバイトオーダ)
を返すためのポインタ。NULLを指定すると出力しない。
</td></tr>
<tr><th>arg 3</Th><td>unsigned short *p</td></tr>
<tr><th></th><td>ポート番号(ネットワークバイトオーダ)
を返すためのポインタ。NULLを指定すると出力しない。
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>出力はネットワークバイトオーダとなっているので、
必要に応じて、 ntohs, ntohl, などを使用して変換すること。
</td></tr>
</table><br><br>
<a name="vce_conn_get_remote_ipv4_addr_string"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_remote_ipv4_addr_string</th></tr>
<tr><th>概要</th><td>TCPコネクションのリモートピアのIPv4アドレスとポートを文字列で得る</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>char *vce_conn_get_remote_ipv4_addr_string( conn_t ct, char *s, int max )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>処理対象となるコネクション
</td></tr>
<tr><th>arg 2</Th><td>char *s</td></tr>
<tr><th></th><td>出力先文字列の先頭アドレス
</td></tr>
<tr><th>arg 3</Th><td>int max</td></tr>
<tr><th></th><td>出力先文字列の最大長さ
</td></tr>
<tr><th>返り値</th><td>s のアドレスをそのまま返す
</td></tr>
<tr><th>詳細説明</th><td>IPアドレスをログ出力用などで、文字列に変換したい時が多いが、
この関数を使うと簡単に文字列を得ることができる。
PS2 での開発環境では、
出力バッファである s には、50バイト以上の長さのものを指定すること。
これは、
現在は PS2 のライブラリが snprintf をサポートしていないことが理由である。
この関数は IPv4 専用であるため IPv6 コネクションには対応していない。
プロトコル独立をめざすアプリケーションでは、
vce_conn_get_remote_addr 関数を用る。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_remote_addr">vce_conn_get_remote_addr</a>
<a href="#vce_conn_get_remote_ipv4_addr">vce_conn_get_remote_ipv4_addr</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_remote_ipv6_addr"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_remote_ipv6_addr</th></tr>
<tr><th>概要</th><td>TCPコネクションのリモートピアのIPv6アドレス(128bit)を得る</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_conn_get_remote_ipv6_addr( conn_t ct, char *a, unsigned short *p )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>処理対象となるコネクション
</td></tr>
<tr><th>arg 2</Th><td>char *a</td></tr>
<tr><th></th><td>128ビットのIPv6アドレス(ネットワークバイトオーダ)
を返すためのポインタ。NULLを指定すると出力しない。
アドレスはネットワークバイトオーダで16バイトが、
そのままバッファに格納される。したがってこのバッファには16バイト以上の
メモリ領域を指定する必要がある。
</td></tr>
<tr><th>arg 3</Th><td>unsigned short *p</td></tr>
<tr><th></th><td>ポート番号(ネットワークバイトオーダ)
を返すためのポインタ。NULLを指定すると出力しない。
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>出力はネットワークバイトオーダとなっているので、
必要に応じて、 ntohs, ntohl, などを使用して変換すること。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_local_ipv6_addr">vce_conn_get_local_ipv6_addr</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_remote_ipv6_addr_string"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_remote_ipv6_addr_string</th></tr>
<tr><th>概要</th><td>TCPコネクションのリモートピアのIPv6アドレスとポートを文字列で得る</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>char *vce_conn_get_remote_ipv6_addr_string( conn_t ct, char *s, int max )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>処理対象となるコネクション
</td></tr>
<tr><th>arg 2</Th><td>char *s</td></tr>
<tr><th></th><td>出力先文字列の先頭アドレス
</td></tr>
<tr><th>arg 3</Th><td>int max</td></tr>
<tr><th></th><td>出力先文字列の最大長さ
</td></tr>
<tr><th>返り値</th><td>s のアドレスをそのまま返す、エラーの場合は  NULL を返す
</td></tr>
<tr><th>詳細説明</th><td>vce_conn_get_remote_ipv4_addr_string 関数の IPv6版．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_remote_addr">vce_conn_get_remote_addr</a>
<a href="#vce_conn_get_remote_ipv4_addr_string">vce_conn_get_remote_ipv4_addr_string</a>
<a href="#vce_conn_get_remote_ipv6_addr">vce_conn_get_remote_ipv6_addr</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_stat"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_stat</th></tr>
<tr><th>概要</th><td>conn_t の統計情報を取得する</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_conn_get_stat( conn_t ct, conn_stat_t *st )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>情報を取得する対象となるコネクション(conn_t)
</td></tr>
<tr><th>arg 2</Th><td>conn_stat_t *st</td></tr>
<tr><th></th><td>情報を取りだすために専用に用意されている conn_stat_t 型のインスタンスの
先頭アドレス
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>TCPコネクションから統計情報を取りだす。
取りだすために conn_stat_t 構造体が定義されている。
以下はその構造体のメンバの説明である。
<ul>
<LI>recv_byte<BR>
そのコネクションで受信した総バイト数。
<LI>send_byte<BR>
そのコネクションで送信した総バイト数。
<LI>conn_write<BR>
そのコネクションに対して vce_conn_write した回数
<LI>recv_syscall, send_syscall<BR>
そのコネクションに対してrecv() システムコールを呼びだした回数と、
send_syscall を呼びだした回数。
</ul>
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_is_valid">vce_conn_is_valid</a>
<a href="#vce_get_stat">vce_get_stat</a>
<a href="#vce_tcpcontext_get_stat">vce_tcpcontext_get_stat</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_state_buffer"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_state_buffer</th></tr>
<tr><th>概要</th><td>conn_tの状態管理バッファへのポインタを返す</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void * vce_conn_get_state_buffer( conn_t c, int *len );</b></td>
<tr><th>arg 1</Th><td>conn_t c</td></tr>
<tr><th></th><td>状態を取りだしたいコネクション
</td></tr>
<tr><th>arg 2</Th><td>int *len</td></tr>
<tr><th></th><td>状態バッファの長さを返す。
NULL を指定すると何もしない
</td></tr>
<tr><th>返り値</th><td>値へのポインタ。状態のないプロトコルの場合NULLが返る
</td></tr>
<tr><th>詳細説明</th><td>状態のあるプロトコルの管理用バッファを返す。
vce_tcpcontext_create の呼びだし時に状態のあるプロトコルを指定(statebuf_size)
していれば、そのサイズの領域をもつバッファへのポインタを返す。
コネクションスイッチングを使用している場合は
vce_circ_get_state_buffer 関数を使ってポインタを得る必要がある。
コネクションスイッチングを使っているのに本関数を使ってポインタを得た場合は
返り値は未定義である。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_circ_get_state_buffer">vce_circ_get_state_buffer</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_struct_from_index"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_struct_from_index</th></tr>
<tr><th>概要</th><td>TCPコネクションのindex値からconn_t構造体を得る。</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>conn_t vce_conn_get_struct_from_index( int index );</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>インデックス値。前もって vce_conn_get_index 関数で得たindexを
つかって構造体に戻す。
</td></tr>
<tr><th>返り値</th><td>conn_t構造体そのもの。
</td></tr>
<tr><th>詳細説明</th><td>本関数は「セッションID」から構造体を取りだしたいときなどに使用する。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_index">vce_conn_get_index</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_tcpcontext"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_tcpcontext</th></tr>
<tr><th>概要</th><td>conn_t から、そのコネクションが属する tcpcontext を取りだす</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>tcpcontext_t vce_conn_get_tcpcontext( conn_t c )</b></td>
<tr><th>arg 1</Th><td>conn_t c</td></tr>
<tr><th></th><td>取りだしの対象となる conn_t
</td></tr>
<tr><th>返り値</th><td>conn_t が属する tcpcontext_t
</td></tr>
<tr><th>詳細説明</th><td>リモートにconnectするときや、新しいTCPのコネクションを受けいれた場合、
VCE内に conn_t が初期化されるが、その conn_t は、
かならず tcpcontext に関連づけられている。
したがって conn_t から tcpcontext_t を取りだすことが可能である。
この関数は主に VCE 内部で使用され、アプリケーションから使われることは少ない。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_circ_get_tcpcontext">vce_circ_get_tcpcontext</a>
<a href="#vce_tcpcontext_connect">vce_tcpcontext_connect</a>
</td></tr>
</table><br><br>
<a name="vce_conn_is_equal"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_is_equal</th></tr>
<tr><th>概要</th><td>ふたつのTCPコネクション(conn_t)が同じか調べる</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td></td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_conn_is_equal( conn_t c1 , conn_t c2 )</b></td>
<tr><th>arg 1</Th><td>conn_t c1</td></tr>
<tr><th></th><td>調べる対象となるコネクションその1
</td></tr>
<tr><th>arg 2</Th><td>conn_t c2</td></tr>
<tr><th></th><td>調べる対象となるコネクションその2
</td></tr>
<tr><th>返り値</th><td>等しい場合は1、等しくない場合は0を返す。
</td></tr>
<tr><th>詳細説明</th><td>ふたつのコネクションが等しいかどうか調べる。
この二つのconn_tを使った書きこみと読みこみは全く同じ結果になる。
具体的には同じポインタとシリアル番号を持っているコネクションとなる。
</td></tr>
</table><br><br>
<a name="vce_conn_is_valid"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_is_valid</th></tr>
<tr><th>概要</th><td>TCPコネクション(conn_t)が壊れているかどうか調べる。</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td></td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_conn_is_valid( conn_t c )</b></td>
<tr><th>arg 1</Th><td>conn_t c</td></tr>
<tr><th></th><td>調査対象の conn_t
</td></tr>
<tr><th>返り値</th><td>無効なインスタンスなら0，有効なら1を返す．
</td></tr>
<tr><th>詳細説明</th><td>VCE を使うアプリケーションでは，通常，VCEが返す conn_t を別のメモリ領域
に記憶しておいて，後でその接続を呼びだすために使うことが多い．
しかし，その時点では，その conn_t が指している VCE 内のオブジェクトは，
すでに解放されて再利用されている可能性がある．
本関数は，conn_t 型の serial メンバを使って，
すでにその conn_t が再利用されて存在しなくなっているかどうかを調べる．
また，本関数は， vce_tcpcontext_connect の返り値が正しいかどうかを調べる
ためにも使われる．
アプリケーションがあるコネクションに対して，
まだ書きこみができるかどうかを随時調べたい場合には，
常に vce_conn_writable 関数を使って調べるべきである．
ブロッキングモードの vce_tcpcontext_connect関数で返された conn_t を
本関数でテストする場合の詳細については，
<a href="connect.html">クライアントからの接続</a>を参照．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_writable">vce_conn_writable</a>
<a href="#vce_tcpcontext_connect">vce_tcpcontext_connect</a>
</td></tr>
</table><br><br>
<a name="vce_conn_set_alarmwatcher"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_set_alarmwatcher</th></tr>
<tr><th>概要</th><td>conn_t ごとにアラーム時刻とコールバック関数を設定する</td></tr>
<tr><th>カテゴリ</th><td>watcher</td></tr>
<tr><th>対応OS</th><td>linux O,win32 X,other X,darwin X</td></tr>
<tr><th>関数プロトタイプ</th><td><b>time_t vce_conn_set_alarmwatcher( conn_t ct, int sec, int (*alarmwatcher)(conn_t c))</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>設定したい conn_t
</td></tr>
<tr><th>arg 2</Th><td>int sec</td></tr>
<tr><th></th><td>設定する秒
</td></tr>
<tr><th>arg 3</Th><td>int (*alarmwatcher)(conn_t c)</td></tr>
<tr><th></th><td>アラーム機能によって呼びだされるコールバック関数
</td></tr>
<tr><th>返り値</th><td>本関数が呼ばれたグローバル時刻を返す。その値から、パラメータのsecを足した時刻がアラームの発生する時刻である。
</td></tr>
<tr><th>詳細説明</th><td>本関数を用いて、コネクションごとのアラームを設定できる。
デフォルトでは各コネクションのアラームは設定されていないので、機能しない。
本関数で、コールバック関数を指定したときに初めて機能する。
1回コールバック関数が呼ばれるとアラームは自動的にリセットされる。
再度アラームを使用したい場合は、本関数で再度アラームを指定しなければならない。
再帰的にアラームを設定したい場合、コールバック関数内で本関数を用いてセットすればよい。

＊注意点
secに大きい値をセットすると、アラーム時刻を計算するときに、secとグローバル時間と加算によって、オーバーフローを起こすことがあるので、注意せよ。
数分までを常用として使うべきで、２４時間を越えるような場合は、別の方法を考えた方がよいだろう。一定時間ごとに値が変化する場合や、制限時間の設定などに利用するとよい。

</td></tr>
<tr><th>使用例</th><td>  // 最初にメイン関数や acceptwatcher などでセットする
  // (これで初めて、60秒後に alarm がよばれる。)
  vce_conn_set_alarmwatcher( ct, 60, alarm );

  // 再帰的にアラームをセットする場合
  int alarm( conn_t ct ){
  
      // 何かの処理
      
      vce_conn_set_alarmwatcher( ct, 60, alarm );
      return 0;
  }
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_circ_set_alarmwatcher">vce_circ_set_alarmwatcher</a>
</td></tr>
</table><br><br>
<a name="vce_conn_set_delay"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_set_delay</th></tr>
<tr><th>概要</th><td>クライアント、サーバー間の通信の遅延んをシミュレートsる。</td></tr>
<tr><th>カテゴリ</th><td>core</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_conn_set_delay(conn_t ct,int delay_min,int delay_max)</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>遅延を設定する対象のコネクション
</td></tr>
<tr><th>arg 2</Th><td>int delay_min</td></tr>
<tr><th></th><td>遅延させる最低の時間。単位はミリ秒
</td></tr>
<tr><th>arg 3</Th><td>int delay_max</td></tr>
<tr><th></th><td>遅延させる最大の時間。単位はミリ秒
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>受信（若しくは送信）するときにmin〜maxまでの間で平均的に遅れを発生させる。
クライアント回線のラグタイムをシミュレートするときに使う。
一度設定すると遅延時間をゼロに設定することはできなくなる。
</td></tr>
<tr><th>知られているバグやTODO</th><td>バッファサイズが通常の送受信バッファと同じサイズで受信したパケットに細かく
時間等ヘッダが付加されるの上に遅延されるのでバッファが詰まりやすい。
</td></tr>
</table><br><br>
<a name="vce_conn_set_parser"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_set_parser</th></tr>
<tr><th>概要</th><td>conn_t ごとに動的にプロトコルパーサを設定する</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_conn_set_parser( conn_t ct, int (*parser)(conn_t), int (*pcallback)(conn_t,char*,int))</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>設定したい conn_t
</td></tr>
<tr><th>arg 2</Th><td>int (*parser)(conn_t)</td></tr>
<tr><th></th><td>パーサー関数． vce_protocol_parser_bin16 など．
</td></tr>
<tr><th>arg 3</Th><td>int (*pcallback)(conn_t c,char *d, int l )</td></tr>
<tr><th></th><td>パーサによって呼びだされるコールバック関数
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>プロトコル処理の都合上，
コネクションごとに動的にパーサを変更したいことがある．
本関数を使うと，コネクションごとに，動的にパーサとコールバックの両方を
変更することができる．
プロトコルのコールバック関数の処理の中で本関数を使って関数を変更した場合，
次のパーサ呼びだしから，
その変更が適用される．
本関数は，たとえばプロトコルをデバッグモードに切りかえるときや
管理用関数に切りかえたいときなどにも使用できる．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_parser_bin16">vce_protocol_parser_bin16</a>
<a href="#vce_protocol_parser_text">vce_protocol_parser_text</a>
<a href="#vce_protocol_parser_through">vce_protocol_parser_through</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_tcpcontext_set_conn_parser">vce_tcpcontext_set_conn_parser</a>
</td></tr>
</table><br><br>
<a name="vce_conn_set_timeout"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_set_timeout</th></tr>
<tr><th>概要</th><td>conn_t ごとにタイムアウト時間を設定変更する</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_conn_set_timeout( conn_t c, int sec )</b></td>
<tr><th>arg 1</Th><td>conn_t c</td></tr>
<tr><th></th><td>設定を変更したい conn_t
</td></tr>
<tr><th>arg 2</Th><td>int sec</td></tr>
<tr><th></th><td>新しいタイムアウト値(秒)
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>デフォルトでは，各コネクションのタイムアウト値は，
vce_tcpcontext_create 関数のタイムアウト設定に準じるが，
本関数を用いて，コネクションごとのタイムアウトを自在に調整できる．
アプリケーションの実行中に特にセキュリティを高めたい状況などに
本関数を使って調整をするとよいだろう．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_conn_show_stat"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_show_stat</th></tr>
<tr><th>概要</th><td>使用中のすべてのコネクションの状態を表示する。</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_conn_show_stat( void )</b></td>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td><pre>
"=== SHOW CONNECTION STATISTICS ===\n"
</pre>
ではじまる、コネクションの個数と同じ行数の統計情報を出力する。
以下は、表示される内容の説明である。
<ul>
<LI><B>A</B><BR>
コネクション構造体(conn_t)のアドレス
<LI><B>Enc</B><BR>
暗号化しているなら1、そうでないなら0
<LI><B>IP</B><BR>
IPアドレスポート番号。ポート番号は10進数である。
<LI><B>Lst</B><BR>
最後にアクセスした時刻(time_t、システムタイム)
<LI><B>I</B><BR>
VCEの管理index
<LI><B>Sv</b><BR>
サーバコネクションなら1、クライアントコネクションなら0
<LI><B>ER</B><BR>
暗号化前の読みこみバッファのアドレス
<LI><B>EW</B><BR>
暗号化後の書きこみバッファのアドレス
<LI><B>R</B><BR>
復号後の読みこみバッファのアドレス
<LI><B>W</B><BR>
暗号化前の書きこみバッファのアドレス
<LI><B>St</B><BR>
暗号ネゴシエーション状態。
</ul>
注意点としては，サイレントモードでコンパイルされているVCEライブラリ
では，本関数は何も出力せず，VCE_ESUPPORT をラストエラーに設定する．
</td></tr>
<tr><th>知られているバグやTODO</th><td>本関数は、標準エラー出力を利用するため、
Win32GUI環境において標準エラー出力が使えない場合は本関数は使用できない。
</td></tr>
</table><br><br>
<a name="vce_conn_shrink_readbuf"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_shrink_readbuf</th></tr>
<tr><th>概要</th><td>conn_t の読みこみバッファを縮ませる</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_conn_shrink_readbuf( conn_t ct, int len )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>縮ませる読みこみバッファをもつ conn_t
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>縮ませるながさ
</td></tr>
<tr><th>返り値</th><td>縮ませることができた長さを返す。
通常はlenがそのまま返る。
</td></tr>
<tr><th>詳細説明</th><td>オリジナルのプロトコルパーサを定義する場合、
読みこみバッファの内容を処理した後、
vce_conn_shrink_readbufを使って読みこみバッファの内容を削る必要がある。
</td></tr>
</table><br><br>
<a name="vce_conn_writable"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_writable</th></tr>
<tr><th>概要</th><td>TCPコネクションに書きこみが可能かどうかを調べる</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_conn_writable( conn_t ct );</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>書きこみ可能かどうか調べる対象となるTCPコネクションをあらわす conn_t。
ノンブロッキングのconnectをvce_tcpcontext_create するときに指定している
場合は、コネクションが完成したかどうかも調べることができる。
この関数はサーバーにおいてもクライアントにおいても使えるが、
クライアントで使うことのほうがほとんどである。
</td></tr>
<tr><th>返り値</th><td>ct が有効でない場合は VCE_EINVAL をかえす。
ct がVCEの内部で初期化されている場合(つまり、コネクションがアプリケーション
の知らないところで切れている場合)は VCE_ECONNSERIAL を返す。
ct は有効だが、書きこみバッファに空きがないか、暗号鍵のネゴシエーション中
の場合はゼロを返す。
書きこみ可能な場合はプラスの値を返す。値の意味は、書きこみ可能なバイト数
である。
</td></tr>
<tr><th>詳細説明</th><td>アプリケーションプログラムにおいて
TCPコネクションに何かを書きこみたいときは、この関数をつかって
書きこみ可能かどうかを調べてから書きこむこと。
</td></tr>
<tr><th>使用例</th><td><pre>
  // ひたすらソケットに書きこみ続けるプログラム
  tcpcontext_t t = vce_tcpontext_create( 0, ... );
  conn_t new_con = vce_tcpcontext_connect( t, "localhost" , 80 );
  while (1 ){
      vce_heartbeat();
      if( vce_conn_writable( new_con ) >= 4 ){
          vce_conn_write( new_con, "test" , 4 );
      } else {
          // Aから一定時間たったら，失敗を通知
      }
  }
</pre>
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_is_valid">vce_conn_is_valid</a>
<a href="#vce_conn_write">vce_conn_write</a>
<a href="#vce_tcpcontext_connect">vce_tcpcontext_connect</a>
</td></tr>
</table><br><br>
<a name="vce_conn_write"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_write</th></tr>
<tr><th>概要</th><td>TCPコネクションにデータを生で書きこむ。</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_conn_write( conn_t ct, char *b, size_t len );</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>書きこむ対象となる conn_t
</td></tr>
<tr><th>arg 2</Th><td>char *b</td></tr>
<tr><th></th><td>書きこむデータ．
</td></tr>
<tr><th>arg 3</Th><td>size_t len</td></tr>
<tr><th></th><td>書きこむデータの長さ．
</td></tr>
<tr><th>返り値</th><td>1以上： 書きこみが成功した。<BR>
0  バッファがいっぱいになってしまっている。<BR>
</td></tr>
<tr><th>詳細説明</th><td>生データを直接送信する。直接送信するといっても、VCEの内部的には、
一旦TCPコネクション(conn_t)の内部に確保されている書きこみバッファに
溜めてからフラッシュされる。したがって、一度に書きこめる量の最大は、
vce_tcpcontext_create するときの書きこみバッファの長さによって決まる。
暗号化や圧縮などの処理は自動的に内部で行なわれる。

また、 vce_conn_write が負を返したら、もうそのコネクションは使えないので、
すみやかに vce_conn_close するべきである。<BR><BR>
<B>0が返ってくるなど、全部書きこめなかった場合の処理</B><BR>
vce_conn_write が0を返す場合は、
何らかの事情でソケットにデータが書きこめない状況になっている。
これは通常はクライアント側がそれ以上読みこめないことを意味する。
アプリケーションの内容がJPEGファイルなど大きなデータをやりとりする場合は、
0を返してもvce_conn_close せずに処理を続けるべきだが、
ゲームの操作パケットなど小さいデータの場合は、
クライアントに問題が発生していると解釈して vce_conn_close したほうがよい。
</td></tr>
<tr><th>使用例</th><td>  // ゲームなど小さいパケットばかりを使う場合の vce_conn_close の使いかた
  if( vce_writable( ct ) > 0 ){
      int writel = vce_conn_write( ct, "hoge", 4 );
      if( writel < 4 ){
          vce_conn_close(ct);
      }
  }
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_close">vce_conn_close</a>
<a href="#vce_conn_writable">vce_conn_writable</a>
</td></tr>
</table><br><br>
<a name="vce_conn_writed"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_writed</th></tr>
<tr><th>概要</th><td>connに書き込まれたデータがTCPコネクションに書き出されているかを調べる</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td></td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_conn_writed( conn_t c )</b></td>
<tr><th>arg 1</Th><td>conn_t c</td></tr>
<tr><th></th><td>調査対象の conn_t
</td></tr>
<tr><th>返り値</th><td>バッファが全て書き出されていれば1, まだ書き出されていなければ0を返す．
</td></tr>
<tr><th>詳細説明</th><td>vce_conn_write()をされていても、まだTCPのコネクションにデータが書き出されている訳ではなく実際にはconnの持つバッファーに書き込まれている。
VCEでは、vce_heartbeatを呼び出すことによって可能な限りデータを書き込む。実際にconnに書き込まれたデータが送信されてるかしらべるには、vce_conn_writed()を使用する必要がある。
特に、connをcloseする直前にデータを書き込む場合、vce_conn_writed()で調べてからcloseしないと実際には送信されていない可能性がある。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_valid">vce_conn_valid</a>
</td></tr>
</table><br><br>
<a name="vce_copy_cstring"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_copy_cstring</th></tr>
<tr><th>概要</th><td>C文字列のコピー。バッファあふれチェック機能あり。</td></tr>
<tr><th>カテゴリ</th><td>text</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_copy_cstring( char *dest , int destlen , char *src )</b></td>
<tr><th>arg 1</Th><td>char *dest</td></tr>
<tr><th></th><td>コピー先バッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int destlen</td></tr>
<tr><th></th><td>コピーする長さ
</td></tr>
<tr><th>arg 3</Th><td>char *src</td></tr>
<tr><th></th><td>コピー元の文字列
</td></tr>
<tr><th>返り値</th><td>バッファあふれを検出したら1、そうでないなら0を返す。
</td></tr>
<tr><th>詳細説明</th><td>コピー元のC言語文字列('\0'で終了しているもの)をコピー先にコピーする。
元の文字列が長すぎてコピー先のバッファが足りなかったら1を、
そうでないなら0を返す。コピー先のバッファがたとえば10バイトだったとすると、
10文字+1ヌル文字のバッファを与えると1が返される．
vce_copy_cstring は、かならずコピー先のバッファは0で終了することを保証する。
</td></tr>
</table><br><br>
<a name="vce_copy_cstring_upto"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_copy_cstring_upto</th></tr>
<tr><th>概要</th><td>C言語文字列を、ある文字がみつかるまでコピーする</td></tr>
<tr><th>カテゴリ</th><td>text</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_copy_cstring_upto( char *dest, char *src, char c, int destlen  )</b></td>
<tr><th>arg 1</Th><td>char *dest</td></tr>
<tr><th></th><td>コピーする先の文字列の先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>char *src</td></tr>
<tr><th></th><td>コピーする元の文字列の先頭アドレス
</td></tr>
<tr><th>arg 3</Th><td>char c</td></tr>
<tr><th></th><td>コピー中止の判定に使う文字
</td></tr>
<tr><th>arg 4</Th><td>int destlen</td></tr>
<tr><th></th><td>コピー先の最大長さ(バイト数)
</td></tr>
<tr><th>返り値</th><td>正常にコピーできた場合はコピーした文字列の長さ(正の値)を返す。
他の関数と同じくコピーした文字列が含むヌル終端文字を含む長さである。
</td></tr>
<tr><th>詳細説明</th><td>VCE附属のツールでは、
テキストの設定ファイルを読みこんだりするときに使用される。
通常アプリケーションから使うことはない。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_copy_cstring">vce_copy_cstring</a>
</td></tr>
</table><br><br>
<a name="vce_decode_buffer_by_blowfish"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_decode_buffer_by_blowfish</th></tr>
<tr><th>概要</th><td>メモリ領域をBlowfishアルゴリズムを使って復号化する</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_decode_buffer_by_blowfish( char *buf , int len , char *k, int kl )</b></td>
<tr><th>arg 1</Th><td>char *buf</td></tr>
<tr><th></th><td>復号化したいバッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>復号化したいバッファの長さ
</td></tr>
<tr><th>arg 3</Th><td>char *k</td></tr>
<tr><th></th><td>復号化キーの先頭アドレス
</td></tr>
<tr><th>arg 4</Th><td>int kl</td></tr>
<tr><th></th><td>復号化キーの長さ
</td></tr>
<tr><th>返り値</th><td>引数が異常である場合は VCE_EINVAL, それ以外の場合は成功で0を返す。
</td></tr>
<tr><th>詳細説明</th><td>引数の意味は vce_encode_buffer_by_blowfish 関数を参照。
本関数は、 まったく逆の変換をするだけである。
</td></tr>
<tr><th>See also</th><td>
<a href="#bf">bf</a>
<a href="#vce_encode_buffer_by_blowfish">vce_encode_buffer_by_blowfish</a>
</td></tr>
</table><br><br>
<a name="vce_decode_buffer_by_rijndael"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_decode_buffer_by_rijndael</th></tr>
<tr><th>概要</th><td>メモリ領域をRijndaelアルゴリズムを使って復号化する</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_decode_buffer_by_rijndael( char *buf , int len , char *k, int kl )</b></td>
<tr><th>arg 1</Th><td>char *buf</td></tr>
<tr><th></th><td>復号化したいバッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>復号化したいバッファの長さ
</td></tr>
<tr><th>arg 3</Th><td>char *k</td></tr>
<tr><th></th><td>復号化キーの先頭アドレス
</td></tr>
<tr><th>arg 4</Th><td>int kl</td></tr>
<tr><th></th><td>復号化キーの長さ
</td></tr>
<tr><th>返り値</th><td>引数が異常である場合は VCE_EINVAL, それ以外の場合は成功で0を返す。
</td></tr>
<tr><th>詳細説明</th><td>引数の意味は vce_encode_buffer_by_rijndael 関数を参照。
本関数は、 まったく逆の変換をするだけである。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_encode_buffer_by_rijndael">vce_encode_buffer_by_rijndael</a>
</td></tr>
</table><br><br>
<a name="vce_delete_int2_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_delete_int2_search</th></tr>
<tr><th>概要</th><td>2整数の検索エンジンから、「キーと値」の組を削除する</td></tr>
<tr><th>カテゴリ</th><td>search</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_delete_int2_search( int index , int key0 , int key1 )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>検索エンジンを特定するためのサーチデスクリプタ
</td></tr>
<tr><th>arg 2</Th><td>int key0</td></tr>
<tr><th></th><td>検索キーとなる整数、ひとつ目
</td></tr>
<tr><th>arg 3</Th><td>int key1</td></tr>
<tr><th></th><td>検索キーとなる整数、ふたつ目
</td></tr>
<tr><th>返り値</th><td>正常終了なら0、異常終了なら負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>2整数のキーにマッチする値を、検索エンジンから削除する。
一旦削除すると、今後の検索ではヒットしなくなる。
複数ある場合でも，最初にヒットしたものを削除する．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_int2_search">vce_get_int2_search</a>
<a href="#vce_init_int2_search">vce_init_int2_search</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_update_int2_search">vce_update_int2_search</a>
</td></tr>
</table><br><br>
<a name="vce_delete_int4_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_delete_int4_search</th></tr>
<tr><th>概要</th><td>4整数の検索エンジンから、「キーと値」の組を削除する</td></tr>
<tr><th>カテゴリ</th><td>search</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_delete_int4_search( int index , int key0 , int key1, int key2, int key3 )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>検索エンジンを特定するためのサーチデスクリプタ
</td></tr>
<tr><th>arg 2</Th><td>int key0</td></tr>
<tr><th></th><td>検索キーとなる整数、ひとつ目
</td></tr>
<tr><th>arg 3</Th><td>int key1</td></tr>
<tr><th></th><td>検索キーとなる整数、ふたつ目
</td></tr>
<tr><th>arg 4</Th><td>int key2</td></tr>
<tr><th></th><td>検索キーとなる整数、3つ目
</td></tr>
<tr><th>arg 5</Th><td>int key3</td></tr>
<tr><th></th><td>検索キーとなる整数、4つ目
</td></tr>
<tr><th>返り値</th><td>正常終了なら0、異常終了なら負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>4整数のキーにマッチする値を、検索エンジンから削除する。
一旦削除すると、今後の検索ではヒットしなくなる。
複数ある場合でも，最初にヒットしたものを削除する．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_int4_search">vce_get_int4_search</a>
<a href="#vce_init_int4_search">vce_init_int4_search</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_update_int4_search">vce_update_int4_search</a>
</td></tr>
</table><br><br>
<a name="vce_delete_int_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_delete_int_search</th></tr>
<tr><th>概要</th><td>整数サーチエンジンの「キーと値」の組を削除する</td></tr>
<tr><th>カテゴリ</th><td>search</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_delete_int_search( int index , int key )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>検索エンジンを特定するためのサーチデスクリプタ
</td></tr>
<tr><th>arg 2</Th><td>int key</td></tr>
<tr><th></th><td>検索キー
</td></tr>
<tr><th>返り値</th><td>正常終了なら0、異常が発生したら負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>key で指定される検索キーをもつ値を削除する。
削除後は検索してもヒットしなくなる。
複数ある場合でも，最初にヒットしたものを削除する．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_int_search">vce_get_int_search</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_update_int_search">vce_update_int_search</a>
</td></tr>
</table><br><br>
<a name="vce_delete_string_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_delete_string_search</th></tr>
<tr><th>概要</th><td>文字列検索エンジンから、「キーと値」の組を取りのぞく</td></tr>
<tr><th>カテゴリ</th><td>search</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_delete_string_search( int index , char *key )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>検索エンジンを特定するためのサーチデスクリプタ
</td></tr>
<tr><th>arg 2</Th><td>char *key</td></tr>
<tr><th></th><td>検索キーとなる文字列
</td></tr>
<tr><th>返り値</th><td>正常終了なら0、異常終了なら負のエラーコード
</td></tr>
<tr><th>詳細説明</th><td>指定された検索キーにマッチする「キーと値」の組を取りのぞく。
複数ある場合でも，最初にヒットしたものを削除する．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_string_search">vce_get_string_search</a>
<a href="#vce_init_string_search">vce_init_string_search</a>
<a href="#vce_update_string_search">vce_update_string_search</a>
</td></tr>
</table><br><br>
<a name="vce_delete_vstring_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_delete_vstring_search</th></tr>
<tr><th>概要</th><td>任意長文字列検索エンジンから，「キーと値」の組を取りのぞく</td></tr>
<tr><th>カテゴリ</th><td>search</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_delete_vstring_search( int index, char *key )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>検索エンジンを特定するためのサーチデスクリプタ
</td></tr>
<tr><th>arg 2</Th><td>char *key</td></tr>
<tr><th></th><td>検索キーとなる文字列
</td></tr>
<tr><th>返り値</th><td>正常終了なら0、異常終了なら負のエラーコード
</td></tr>
<tr><th>詳細説明</th><td>指定された検索キーにマッチする「キーと値」の組を取りのぞく。
複数ある場合でも，最初にヒットしたものを削除する．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_vstring_search">vce_get_vstring_search</a>
<a href="#vce_init_vstring_search">vce_init_vstring_search</a>
<a href="#vce_update_vstring_search">vce_update_vstring_search</a>
</td></tr>
</table><br><br>
<a name="vce_descape_string"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_descape_string</th></tr>
<tr><th>概要</th><td>エスケープされた文字列を元に戻す</td></tr>
<tr><th>カテゴリ</th><td></td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_descape_string( char *to, int tolen, char *from )</b></td>
<tr><th>arg 1</Th><td>char *to</td></tr>
<tr><th></th><td>元にもどった文字列の出力先文字列の先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int tolen</td></tr>
<tr><th></th><td>出力先文字列の最大長さ
</td></tr>
<tr><th>arg 3</Th><td>char *from</td></tr>
<tr><th></th><td>変換元文字列の先頭アドレス
</td></tr>
<tr><th>返り値</th><td>出力先バッファが足りていたら出力された文字列の長さを返す．
</td></tr>
<tr><th>詳細説明</th><td>vce_escape_string 関数を使ってエスケープされた文字列を元に戻す．
出力先バッファが不足していたら出力を壊すのではなくエラーを返す．
ただし，
引数 to で指定されたバッファの内容は上書きされるので注意が必要である．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_escape_string">vce_escape_string</a>
</td></tr>
</table><br><br>
<a name="vce_dump_buffer"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_dump_buffer</th></tr>
<tr><th>概要</th><td>バイナリ配列をvce_erroutを用いてダンプする。</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_dump_buffer( char *buf, int len )</b></td>
<tr><th>arg 1</Th><td>char *buf</td></tr>
<tr><th></th><td>ダンプしたいデータの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>ダンプしたいデータの長さ
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>vce_errout 関数を用いて、バイナリデータを含む配列の内容をすべてログする。
8バイトごとに区切って表示する非常に単純なものである。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_errout">vce_errout</a>
</td></tr>
</table><br><br>
<a name="vce_encode_buffer_by_blowfish"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_encode_buffer_by_blowfish</th></tr>
<tr><th>概要</th><td>メモリ領域をBlowfishアルゴリズムを使って暗号化する</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_encode_buffer_by_blowfish( char *buf , int len , char *k, int kl )</b></td>
<tr><th>arg 1</Th><td>char *buf</td></tr>
<tr><th></th><td>暗号化したいバッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>暗号化したいバッファの長さ
</td></tr>
<tr><th>arg 3</Th><td>char *k</td></tr>
<tr><th></th><td>暗号化キーの先頭アドレス
</td></tr>
<tr><th>arg 4</Th><td>int kl</td></tr>
<tr><th></th><td>暗号化キーの長さ
</td></tr>
<tr><th>返り値</th><td>引数が異常である場合は負のエラーコード。
それ以外の場合は成功で0を返す。
</td></tr>
<tr><th>詳細説明</th><td>Blowfishアルゴリズムは8バイト単位のブロック暗号なので、
vce_encode_buffer_by_blowfish では、
余計な処理を介入させないために、入力バッファは8バイトの倍数の長さで
なければ入力を受けつけないようにしている(VCE_EODDBUFSIZE)。
またキーの長さは Blowfishでは32ビットから448ビットまでなので、
kl には4から56までの値を指定すること。
VCEに附属のbf プログラムは、 vce_encode_buffer_by_blowfish を使用して
ファイルを暗号化するユーティリティである。
</td></tr>
<tr><th>See also</th><td>
<a href="#bf">bf</a>
<a href="#vce_decode_buffer_by_blowfish">vce_decode_buffer_by_blowfish</a>
</td></tr>
</table><br><br>
<a name="vce_encode_buffer_by_rijndael"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_encode_buffer_by_rijndael</th></tr>
<tr><th>概要</th><td>メモリ領域をRijndaelアルゴリズムを使って暗号化する</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_encode_buffer_by_rijndael( char *buf , int len , char *k, int kl )</b></td>
<tr><th>arg 1</Th><td>char *buf</td></tr>
<tr><th></th><td>暗号化したいバッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>暗号化したいバッファの長さ
</td></tr>
<tr><th>arg 3</Th><td>char *k</td></tr>
<tr><th></th><td>暗号化キーの先頭アドレス
</td></tr>
<tr><th>arg 4</Th><td>int kl</td></tr>
<tr><th></th><td>暗号化キーの長さ
</td></tr>
<tr><th>返り値</th><td>引数が異常である場合は負のエラーコード。
それ以外の場合は成功で0を返す。
</td></tr>
<tr><th>詳細説明</th><td>Rijndael アルゴリズムは16/32バイト単位のブロック暗号なので、
vce_encode_buffer_by_rijndael も同様に、
入力バッファの長さが16バイトで割りきれない場合は VCE_EODDBUFSIZE を
返すようにしている。
キーの長さは、16/24/32 バイトのいずれかである。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_decode_buffer_by_rijndael">vce_decode_buffer_by_rijndael</a>
</td></tr>
</table><br><br>
<a name="vce_end_all_array"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_end_all_array</th></tr>
<tr><th>概要</th><td>全てのVCE配列を解放する</td></tr>
<tr><th>カテゴリ</th><td>array</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_end_all_array( void )</b></td>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>すべてのVCE配列に対して vce_end_array を呼びだす。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_init_array">vce_init_array</a>
</td></tr>
</table><br><br>
<a name="vce_end_array"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_end_array</th></tr>
<tr><th>概要</th><td>VCE配列を解放する。</td></tr>
<tr><th>カテゴリ</th><td>array</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_end_array( int index )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>配列を特定する配列デスクリプタ。
vce_init_array の返り値である。
</td></tr>
<tr><th>返り値</th><td>成功の場合は0、エラーだったら負のエラーコードを返す(vce.h)
</td></tr>
<tr><th>詳細説明</th><td>配列の要素ではなく、配列自体を解放することに注意。
また，すべて配列の要素は解放される．
vce_end_array を呼びだした後は、
その配列に関してはすべての操作が不可能となる。
vce_end_array 関数は内部で FREE 関数を呼びだしているので、
FREE 関数の呼びだし状況がログ出力される。
</td></tr>
<tr><th>See also</th><td>
<a href="#FREE">FREE</a>
<a href="#vce_init_array">vce_init_array</a>
</td></tr>
</table><br><br>
<a name="vce_errout"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_errout</th></tr>
<tr><th>概要</th><td>VCEのログ出力をする</td></tr>
<tr><th>カテゴリ</th><td>core</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_errout( const char *format, ... )</b></td>
<tr><th>arg 1</Th><td>char *format</td></tr>
<tr><th></th><td>フォーマット文字列。 printf のものと同じ
</td></tr>
<tr><th>arg 2</Th><td>...</td></tr>
<tr><th></th><td>0個以上の引数列。 printf のものと同じ
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>文字列を標準エラー出力に表示する。ただし、
vce_errout_config 関数によってログ出力ディレクトリが指定されている場合は、
そのディレクトリにも出力し、そのログは自動的に rotate される。
標準エラー出力がない環境では，標準出力に出力される．
</td></tr>
<tr><th>See also</th><td>
<a href="# vce_errout_set_another"> vce_errout_set_another</a>
<a href="# vce_verrout"> vce_verrout</a>
<a href="#vce_errout_config">vce_errout_config</a>
<a href="#vce_errout_v">vce_errout_v</a>
</td></tr>
</table><br><br>
<a name="vce_errout0"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_errout0</th></tr>
<tr><th>概要</th><td>1個の文字列をログ出力する</td></tr>
<tr><th>カテゴリ</th><td>core</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_errout0( const char *s )</b></td>
<tr><th>arg 1</Th><td>char *s</td></tr>
<tr><th></th><td>出力したい文字列の先頭アドレス
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>vce_errout と同じだが、vfprintf を使わない、単純なバージョンである。
僅かに高速である。Win32環境の場合は、OutputDebugString 関数にも
引数 s を渡す。
verboseモードが-1のときは、出力されない。
出力される先は，vce_errout 関数と同じである．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_errout">vce_errout</a>
<a href="#vce_errout0_v">vce_errout0_v</a>
</td></tr>
</table><br><br>
<a name="vce_errout0_v"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_errout0_v</th></tr>
<tr><th>概要</th><td>冗長モード時に1個の文字列をログ出力する</td></tr>
<tr><th>カテゴリ</th><td>core</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_errout0_v( const char *s )</b></td>
<tr><th>arg 1</Th><td>char *s</td></tr>
<tr><th></th><td>出力したい文字列の先頭アドレス
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>vce_errout_v と同じく冗長出力モード(verbose mode)のときだけ
エラー出力する。ただし、引数列を指定できない。 また、
win32環境の場合は、 OutputDebugString 関数にも引数 s を渡す。
verboseモードが -1 のときは、出力されない。
出力される先は， vce_errout 関数と同じである．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_errout0">vce_errout0</a>
<a href="#vce_errout_v">vce_errout_v</a>
</td></tr>
</table><br><br>
<a name="vce_errout_config"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_errout_config</th></tr>
<tr><th>概要</th><td>vce_errout関数の出力ディレクトリを設定する。</td></tr>
<tr><th>カテゴリ</th><td>core</td></tr>
<tr><th>対応OS</th><td>linux,win32,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_errout_config( const char *dirname, unsigned int rotate_size )</b></td>
<tr><th>arg 1</Th><td>char *dirname</td></tr>
<tr><th></th><td>ログの出力先ディレクトリ名。 512文字以下で指定すること。それを越えると、
後ろが切りとられる。最後のスラッシュは付けても付けなくても正しく設定
される。
</td></tr>
<tr><th>arg 2</Th><td>unsigned int rotate_size</td></tr>
<tr><th></th><td>ログファイルを分割する単位となるサイズ．
たとえば 100*1024 を指定すると 100KBごとに別のファイルに出力される．
ゼロを指定すると，分割を行なわない．
</td></tr>
<tr><th>返り値</th><td>エラーなら負のvceのエラーコード。成功なら0を返す。
現在は常に成功する。
</td></tr>
<tr><th>詳細説明</th><td>VCEのすべてのエラー出力が出力されるディレクトリを設定する。
デフォルトではエラー出力はstderr(windowsではstdout)に出力される。
vce_errout_config によりディレクトリが指定された後は、
そのディレクトリの中に <code>stderr.プロセス番号.分割番号</code>
というファイル名でエラー出力が保存される。
プロセス番号は VCE を使用しているサーバのプロセス番号で，
分割番号は，rotate_size の設定により 0から順にインクリメントされていく．
ローテートの機能とログバックアップツールを併用してログを
保存するのが定番の方法である．
verboseモードが -1 のときは、まったく出力されない。
</td></tr>
<tr><th>使用例</th><td><pre>
  vce_errout( "Testing.\n" );    // この出力は stderr へ
  vce_errout_config( "/var/netgame1/error_output", 1000 );
  vce_errout( "Testing again.\n" ); // この出力は1KBごとに上記ディレクトリへ
</pre>  
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_errout">vce_errout</a>
</td></tr>
</table><br><br>
<a name="vce_errout_set_another"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_errout_set_another</th></tr>
<tr><th>概要</th><td>VCEのエラー出力先を変える</td></tr>
<tr><th>カテゴリ</th><td>core</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_errout_set_another(void (*callback)(int vmode,const char *str))</b></td>
<tr><th>arg 1</Th><td>void (*callback)(int vmode,const char *str)</td></tr>
<tr><th></th><td>引数にverbosemodeとnull終端された文字列を受け取る関数
NULLを設定すれば関数は呼ばない。デフォルトはNULL
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>vce_erroutでフォーマットされた文字列を標準出力以外の場所へ出力するときに使う。
</td></tr>
<tr><th>知られているバグやTODO</th><td>TODO 現在はvce_erroutのみですべての出力が出るわけではない
</td></tr>
<tr><th>See also</th><td>
<a href="# vce_errout_config"> vce_errout_config</a>
<a href="#vce_errout">vce_errout</a>
</td></tr>
</table><br><br>
<a name="vce_errout_v"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_errout_v</th></tr>
<tr><th>概要</th><td>VCEが冗長モードのときにログ出力をする</td></tr>
<tr><th>カテゴリ</th><td>core</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_errout_v( const char *format, ... )</b></td>
<tr><th>arg 1</Th><td>char *format</td></tr>
<tr><th></th><td>フォーマット文字列。printf のものと全く同じ。
</td></tr>
<tr><th>arg 2</Th><td>...</td></tr>
<tr><th></th><td>0個以上の引数列。printf のものと全く同じ。
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>VCEがverboseモードになっているとき(すなわち、vce_set_verbose_mode(1)のとき)
だけ出力される、
vce_errout_config 関数でディレクトリが指定されている場合は、
そのディレクトリに出力される。その場合にログは自動的にローテートする。
verbose モードが -1 のときは、出力されない。
出力される先は，vce_errout関数と同じ．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_errout">vce_errout</a>
<a href="#vce_errout_config">vce_errout_config</a>
</td></tr>
</table><br><br>
<a name="vce_escape_string"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_escape_string</th></tr>
<tr><th>概要</th><td>文字列をエスケープする．</td></tr>
<tr><th>カテゴリ</th><td>text</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_escape_string( char *to, int tolen, char *from, int fromlen )</b></td>
<tr><th>arg 1</Th><td>char *to</td></tr>
<tr><th></th><td>出力先文字列の先頭アドレス．エスケープした文字列が出力される．
</td></tr>
<tr><th>arg 2</Th><td>int tolen</td></tr>
<tr><th></th><td>出力先文字列の最大長さ． (fromlen*2+1) を確保しておくと，
足りなくなることはない．
</td></tr>
<tr><th>arg 3</Th><td>char *from</td></tr>
<tr><th></th><td>エスケープする元の文字列の先頭アドレス
</td></tr>
<tr><th>arg 4</Th><td>int fromlen</td></tr>
<tr><th></th><td>エスケープする元の文字列の長さ
この文字列はバイナリとして扱われるので途中にヌル文字があってもよい．
</td></tr>
<tr><th>返り値</th><td>出力先バッファが足りないと，壊れた文字列を返すのではなく，
エラー(VCE_ETOOSHORT)を返す．出力先文字列は，ヌル文字で終端される．
バッファが足りていたら，出力文字列の長さを返す．
</td></tr>
<tr><th>詳細説明</th><td>'\0', '\n', '\\', '\r', '\"', '\'', '\032' をエスケープして，
出力先の文字列にこれらの文字が直接含まれないようにする．
基本的なロジックは MySQL の mysql_escape_string と同等だが，
エラーチェックが厳しくなっている．
この関数でエスケープした文字は， vce_descape_string で元に戻せる．
</td></tr>
<tr><th>知られているバグやTODO</th><td>バグではないが，本関数を使って日本語など多バイト文字を変換するときには
注意が必要である．本関数は多バイトの特別な処理をしていないため，
日本語の場合，
Shift-JIS と EUC を使う場合は問題ないが，
JIS の文字列を変換するときにはエスケープされる文字が日本語文字列の中に
含まれる場合があるため，出力された文字列が腐って表示されることがある．
vce_descape_string を使えば完全に元に戻るが，
変換後の文字列の可読性が著しく損なわれる結果となる．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_descape_string">vce_descape_string</a>
</td></tr>
</table><br><br>
<a name="vce_extract_data_from_hex_text"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_extract_data_from_hex_text</th></tr>
<tr><th>概要</th><td>hextext 形式のASCIIテキストを、バイナリデータ配列に戻す</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_extract_data_from_hex_text( const char *buf, int len, char *out, int outlen )</b></td>
<tr><th>arg 1</Th><td>char *buf</td></tr>
<tr><th></th><td>入力となるASCIIテキストの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>入力テキストの長さ(バイト数)
</td></tr>
<tr><th>arg 3</Th><td>char *out</td></tr>
<tr><th></th><td>出力バイナリ配列の先頭アドレス
</td></tr>
<tr><th>arg 4</Th><td>int outlen</td></tr>
<tr><th></th><td>出力する最大のバイト数
</td></tr>
<tr><th>返り値</th><td>テキストの中身が正当でない場合は VCE_EFORMAT を、
それ以外の何らかのエラー(バッファが足りないなど)の場合はそれに応じた
負のエラーコードを、完全に成功した場合は正の数(バイナリのバイト数)を返す。
</td></tr>
<tr><th>詳細説明</th><td>hextext 形式のバッファを読みこみ、データの中身の正当性をチェックした上で、
バイナリ配列に読みこむ。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_make_hex_text_from_buffer">vce_make_hex_text_from_buffer</a>
</td></tr>
</table><br><br>
<a name="vce_finalize"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_finalize</th></tr>
<tr><th>概要</th><td>VCEの解放を行なう。</td></tr>
<tr><th>カテゴリ</th><td>core</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_finalize( void )</b></td>
<tr><th>返り値</th><td>正常に終了できた場合は0、異常な場合は負のエラーコードを返す。
</td></tr>
<tr><th>詳細説明</th><td>VCEが使用していたすべての資源を解放する。
vce_errout* を除いて，
この関数を呼びだした後のVCE関数の呼びだしはすべて未定義の動作となる。
</td></tr>
</table><br><br>
<a name="vce_free_array_object"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_free_array_object</th></tr>
<tr><th>概要</th><td>VCE配列の要素を解放する</td></tr>
<tr><th>カテゴリ</th><td>array</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_free_array_object( int index , void *p )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>配列を特定するための配列デスクリプタ
</td></tr>
<tr><th>arg 2</Th><td>void *p</td></tr>
<tr><th></th><td>解放したい配列の要素の先頭アドレス
</td></tr>
<tr><th>返り値</th><td>成功したら0、失敗したら負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>vce_free_array_object 関数は、 ARRAY_SCAN マクロ内で使用することができる。
この関数は，解放されるバッファの中身に対して何か書きこむことは一切しない．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_alloc_array_object">vce_alloc_array_object</a>
<a href="#vce_free_array_object_all">vce_free_array_object_all</a>
<a href="#vce_init_array">vce_init_array</a>
</td></tr>
</table><br><br>
<a name="vce_free_array_object_all"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_free_array_object_all</th></tr>
<tr><th>概要</th><td>配列の全要素を解放する(配列自体は解放しない)</td></tr>
<tr><th>カテゴリ</th><td>array</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_free_array_object_all( int index )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>配列を特定するための配列デスクリプタ
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>1つの配列の中で使用中になっているすべての要素を解放する。
</td></tr>
<tr><th>知られているバグやTODO</th><td>現在は1個1個解放しているため比較的遅い。
全体を一気に初期化することによって高速化する予定である(バージョン1以降)。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_free_array_object">vce_free_array_object</a>
<a href="#vce_init_array">vce_init_array</a>
</td></tr>
</table><br><br>
<a name="vce_get_array_maxnum"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_array_maxnum</th></tr>
<tr><th>概要</th><td>配列の最大要素数を返す</td></tr>
<tr><th>カテゴリ</th><td>array</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_get_array_maxnum( int index )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>情報を取得したい配列のindex
</td></tr>
<tr><th>返り値</th><td>配列のメンバの最大数．
</td></tr>
<tr><th>詳細説明</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_array_member_size">vce_get_array_member_size</a>
<a href="#vce_init_array">vce_init_array</a>
</td></tr>
</table><br><br>
<a name="vce_get_array_member_size"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_array_member_size</th></tr>
<tr><th>概要</th><td>配列の各メンバのサイズを返す</td></tr>
<tr><th>カテゴリ</th><td>array</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_get_array_member_size( int index )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>情報を取得したい配列の index
</td></tr>
<tr><th>返り値</th><td>配列のメンバのサイズ(vce_init_array の第一引数の値)．
引数が異常の場合は負のエラーコードを返す．
</td></tr>
<tr><th>詳細説明</th><td>VCE の配列管理ルーチンが管理している配列のメンバのサイズを得る
vce_init_array の size 引数の値．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_array_maxnum">vce_get_array_maxnum</a>
<a href="#vce_init_array">vce_init_array</a>
</td></tr>
</table><br><br>
<a name="vce_get_array_object_index"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_array_object_index</th></tr>
<tr><th>概要</th><td>VCE配列要素が配列の何番目に位置しているかを得る</td></tr>
<tr><th>カテゴリ</th><td>array</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_get_array_object_index( int index , void *p )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>配列を特定するための配列デスクリプタ
</td></tr>
<tr><th>arg 2</Th><td>void *p</td></tr>
<tr><th></th><td>インデックスを得たい要素の先頭アドレス
</td></tr>
<tr><th>返り値</th><td>引数が不正な場合はVCE_EINVALを、ポインタが適切な値でない場合は
VCE_EALIGNMENT を返す。
正常終了の場合は、0以上のインデックスを返す
</td></tr>
<tr><th>詳細説明</th><td>vce_get_array_object_index 関数は、指定されたポインタが配列の
どの位置にあるか、ポインタの減算により計算し、インデックスを求める。
</td></tr>
</table><br><br>
<a name="vce_get_array_object_last"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_array_object_last</th></tr>
<tr><th>概要</th><td>VCE配列の最後の要素を取りだす。</td></tr>
<tr><th>カテゴリ</th><td>array</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void * vce_get_array_object_last( int index )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>配列を特定するための配列デスクリプタ
</td></tr>
<tr><th>返り値</th><td>最後の要素へのポインタ。要素がひとつも存在しない場合はNULLを返す
</td></tr>
<tr><th>詳細説明</th><td>VCE配列の使用中のもののうち最後の要素へのポインタを得る。
vce_alloc_array_object は、常に使用中リンクの先頭に追加されるため、
vce_alloc_array_object と本関数をつかえば、 FIFOのようなことができる。
つまり、
先頭にのみ追加され、末尾からのみ取りだされるという配列を作ることができる。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_alloc_array_object">vce_alloc_array_object</a>
<a href="#vce_get_array_object_next">vce_get_array_object_next</a>
<a href="#vce_get_array_object_top">vce_get_array_object_top</a>
</td></tr>
</table><br><br>
<a name="vce_get_array_object_next"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_array_object_next</th></tr>
<tr><th>概要</th><td>VCE配列の使用中要素の次の要素を取りだす</td></tr>
<tr><th>カテゴリ</th><td>array</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void * vce_get_array_object_next( int index , void *p )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>配列を特定する配列デスクリプタ
</td></tr>
<tr><th>arg 2</Th><td>void *p</td></tr>
<tr><th></th><td>vce_get_array_object_next は、
この引数で与えられたポインタの差す要素の次の使用中要素を返す。
</td></tr>
<tr><th>返り値</th><td>次の要素のポインタ
</td></tr>
<tr><th>詳細説明</th><td>vce_get_array_object_next は、 ARRAY_SCAN マクロ中で使用されている。
通常のアプリケーションは、本関数を直接に使用するべきではない。
ARRAY_SCAN マクロを使用したほうが安全確実である。
</td></tr>
<tr><th>See also</th><td>
<a href="#ARRAY_SCAN">ARRAY_SCAN</a>
<a href="#vce_get_array_object_top">vce_get_array_object_top</a>
</td></tr>
</table><br><br>
<a name="vce_get_array_object_pointer_by_index"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_array_object_pointer_by_index</th></tr>
<tr><th>概要</th><td>VCE配列の要素をインデクスを指定して得る</td></tr>
<tr><th>カテゴリ</th><td>array</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void *vce_get_array_object_pointer_by_index( int index, int objindex )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>VCE配列を特定するための配列ディスクリプタ
</td></tr>
<tr><th>arg 2</Th><td>int objindex</td></tr>
<tr><th></th><td>取りだしたい要素の配列中のindex
</td></tr>
<tr><th>返り値</th><td>取りだした要素を指すポインタ。
</td></tr>
<tr><th>詳細説明</th><td>通常、VCE配列の要素は ARRAY_SCAN もしくは、ポインタによってアクセスされるが、
本関数を使えばインデックスを使って要素にアクセスすることもできる．
NULLポインタを返す場合は、 vce_get_last_error を使ってエラーの内容を知る
ことができる。
</td></tr>
<tr><th>使用例</th><td>  // 使用中、未使用にかかわらず配列の全要素を初期化する
  for(int i=0;;i++){
      sometype *t = vce_get_array_object_pointer_by_index( memind, i );
      if( t == NULL )break;
      t->someparam = somevalue;
  }
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_array_object_pointer_by_index_only_used">vce_get_array_object_pointer_by_index_only_used</a>
<a href="#vce_init_array">vce_init_array</a>
</td></tr>
</table><br><br>
<a name="vce_get_array_object_pointer_by_index_only_used"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_array_object_pointer_by_index_only_used</th></tr>
<tr><th>概要</th><td>VCE配列の指定したインデクスを持つ要素を得る(使用中の要素のみ)</td></tr>
<tr><th>カテゴリ</th><td>array</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void * vce_get_array_object_pointer_by_index_only_used( int index, int objindex )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>配列を特定するための配列デスクリプタ
</td></tr>
<tr><th>arg 2</Th><td>int objindex</td></tr>
<tr><th></th><td>取りだしたい要素の配列中のインデックス。
</td></tr>
<tr><th>返り値</th><td>取りだした要素をさすポインタ。要素が使用中でない場合はNULLポインタを返す
</td></tr>
<tr><th>詳細説明</th><td>vce_get_array_object_pointer_by_index 関数とほぼ同じだが、
現在使用のものだけを返す。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_array_object_pointer_by_index">vce_get_array_object_pointer_by_index</a>
<a href="#vce_init_array">vce_init_array</a>
</td></tr>
</table><br><br>
<a name="vce_get_array_object_top"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_array_object_top</th></tr>
<tr><th>概要</th><td></td></tr>
<tr><th>カテゴリ</th><td>array</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void * vce_get_array_object_top( int index )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>配列を特定するための配列デスクリプタ
</td></tr>
<tr><th>返り値</th><td>使用中の要素をさすポインタ。
使用中の要素がない場合はヌルポインタを返す
</td></tr>
<tr><th>詳細説明</th><td>vce_get_array_object_top は、 ARRAY_SCAN マクロの内部で使用される。

ARRAY_SCAN マクロは、配列の要素のうち使用中のものすべてをスキャンする
ために実装されているが、本関数はそのうち先頭のものを取りだす。
通常のアプリケーションは、 ARRAY_SCAN マクロを直接使用するほうが便利な
場合が多い。
</td></tr>
<tr><th>See also</th><td>
<a href="#ARRAY_SCAN">ARRAY_SCAN</a>
<a href="#vce_get_array_object_next">vce_get_array_object_next</a>
</td></tr>
</table><br><br>
<a name="vce_get_array_usenum"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_array_usenum</th></tr>
<tr><th>概要</th><td>VCE配列の要素のうちいくつが使用中になっているかを数える</td></tr>
<tr><th>カテゴリ</th><td>array</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_get_array_usenum( int index )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>配列を特定するための配列デスクリプタ
</td></tr>
<tr><th>返り値</th><td>使用中の要素の数。
</td></tr>
<tr><th>詳細説明</th><td>配列全体をスキャンして数えることなく、使用中の数を返す。
スキャンしないので非常に高速である。
</td></tr>
<tr><th>See also</th><td>
<a href="#ARRAY_SCAN">ARRAY_SCAN</a>
<a href="#vce_init_array">vce_init_array</a>
</td></tr>
</table><br><br>
<a name="vce_get_current_utime"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_current_utime</th></tr>
<tr><th>概要</th><td>現在時刻を VCEI64型で得る</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>VCEI64 vce_get_current_utime( void )</b></td>
<tr><th>返り値</th><td>現在時刻。
UNIX環境においては、 gettimeofday  関数により得られた
timeval 構造体の値を VCEI64 に変換した値を返す。
Win32環境においては、 GetSystemTime 関数により得られた
SYSTEMTIME 構造体の値を VCEI64 に変換した値を返す。
</td></tr>
<tr><th>詳細説明</th><td>VCEI64に変換される元になるtimevalの値は、 gettimeofday() が返す値を
変換して得られるものである。
VCEはこの関数が返す値を、vce_heartbeat が呼びだされるごとに更新する。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_set_internal_timer">vce_set_internal_timer</a>
</td></tr>
</table><br><br>
<a name="vce_get_int2_or_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_int2_or_search</th></tr>
<tr><th>概要</th><td>2整数の検索エンジンでOR検索を実行する</td></tr>
<tr><th>カテゴリ</th><td>search</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void* vce_get_int2_or_search( int index, int key0, int key1, void **next_ptr, int *next_index )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>検索エンジンを特定するためのサーチデスクリプタ
</td></tr>
<tr><th>arg 2</Th><td>int key0</td></tr>
<tr><th></th><td>検索キーとなる整数、ひとつ目
</td></tr>
<tr><th>arg 3</Th><td>int key1</td></tr>
<tr><th></th><td>検索キーとなる整数、ふたつ目
</td></tr>
<tr><th>arg 4</Th><td>void **next_ptr</td></tr>
<tr><th></th><td>ループ検索に使う関数の戻り値
</td></tr>
<tr><th>arg 5</Th><td>int next_index</td></tr>
<tr><th></th><td>ループ検索に使う関数の戻り値
</td></tr>
<tr><th>返り値</th><td>検索結果へのポインタ。NULLなら全てを検索して見つからなかった。
</td></tr>
<tr><th>詳細説明</th><td>ふたつの検索キーにいづれかにマッチする値を取りだす。
検索の仕組については、 vce_init_int_search を参照してください。
next_ptrにNULLをもつポインタ、next_indexに0をもつポインタを指定して検索を開始させます。
繰り返して関数を呼び出すことにより複数の結果を取得できます。
</td></tr>
<tr><th>使用例</th><td><pre>
  int i2is = vce_init_int2_search( 10, 5, "foo" );
       .
       .
       .
  int input_IP   = 0x23445599;
  int input_Port = 0;
  int next_index = 0;
  void *cinfop, *next_ptr = NULL;

  while (1)
  {
    cinfop = vce_get_int2_or_search( i2si, input_IP, input_Port, &next_ptr, &next_index);
    if ( !cinfop ) break;
       .
       .
       .
  }
</pre>
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_delete_int2_search">vce_delete_int2_search</a>
<a href="#vce_get_int2_search">vce_get_int2_search</a>
<a href="#vce_init_int2_search">vce_init_int2_search</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_update_int2_search">vce_update_int2_search</a>
</td></tr>
</table><br><br>
<a name="vce_get_int2_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_int2_search</th></tr>
<tr><th>概要</th><td>2整数の検索エンジンで検索を実行する</td></tr>
<tr><th>カテゴリ</th><td>search</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void* vce_get_int2_search( int index , int key0 , int key1 )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>検索エンジンを特定するためのサーチデスクリプタ
</td></tr>
<tr><th>arg 2</Th><td>int key0</td></tr>
<tr><th></th><td>検索キーとなる整数、ひとつ目
</td></tr>
<tr><th>arg 3</Th><td>int key1</td></tr>
<tr><th></th><td>検索キーとなる整数、ふたつ目
</td></tr>
<tr><th>返り値</th><td>検索結果へのポインタ
</td></tr>
<tr><th>詳細説明</th><td>ふたつの検索キーに同時にマッチする値を取りだす。
検索の仕組については、 vce_init_int_search を参照
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_delete_int2_search">vce_delete_int2_search</a>
<a href="#vce_get_int2_or_search">vce_get_int2_or_search</a>
<a href="#vce_init_int2_search">vce_init_int2_search</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_update_int2_search">vce_update_int2_search</a>
</td></tr>
</table><br><br>
<a name="vce_get_int4_or_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_int4_or_search</th></tr>
<tr><th>概要</th><td>4整数の検索エンジンでOR検索を実行する</td></tr>
<tr><th>カテゴリ</th><td>search</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void* vce_get_int4_or_search( int index, int key0, int key1, int key2, int key3, void **next_ptr, int *next_index )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>検索エンジンを特定するためのサーチデスクリプタ
</td></tr>
<tr><th>arg 2</Th><td>int key0</td></tr>
<tr><th></th><td>検索キーとなる整数、ひとつ目
</td></tr>
<tr><th>arg 3</Th><td>int key1</td></tr>
<tr><th></th><td>検索キーとなる整数、ふたつ目
</td></tr>
<tr><th>arg 4</Th><td>int key2</td></tr>
<tr><th></th><td>検索キーとなる整数、3つ目
</td></tr>
<tr><th>arg 5</Th><td>int key3</td></tr>
<tr><th></th><td>検索キーとなる整数、4つ目
</td></tr>
<tr><th>arg 6</Th><td>void **next_ptr</td></tr>
<tr><th></th><td>ループ検索に使う関数の戻り値
</td></tr>
<tr><th>arg 7</Th><td>int next_index</td></tr>
<tr><th></th><td>ループ検索に使う関数の戻り値
</td></tr>
<tr><th>返り値</th><td>検索結果へのポインタ。NULLなら全てを検索して見つからなかった。
</td></tr>
<tr><th>詳細説明</th><td>４つの検索キーにいづれかにマッチする値を取りだす。
検索の仕組については、 vce_init_int_search を参照してください。
next_ptrにNULLをもつポインタ、next_indexに0をもつポインタを指定して検索を開始させます。
繰り返して関数を呼び出すことにより複数の結果を取得できます。
</td></tr>
<tr><th>使用例</th><td><pre>
  int i4is = vce_init_int4_search( 10, 5, "foo" );
       .
       .
       .
  int input_key0 = 0x23445599;
  int input_key1 = 0;
  int input_key2 = 0;
  int input_key3 = 0;
  int next_index = 0;
  void *cinfop, *next_ptr = NULL;

  while (1)
  {
    cinfop = vce_get_int4_or_search( i4si, input_key0, input_key1,
                                     input_key2, input_key3, &next_ptr,
                                     &next_index);
    if ( !cinfop ) break;
       .
       .
       .
  }
</pre>
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_delete_int4_search">vce_delete_int4_search</a>
<a href="#vce_get_int4_search">vce_get_int4_search</a>
<a href="#vce_init_int4_search">vce_init_int4_search</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_update_int4_search">vce_update_int4_search</a>
</td></tr>
</table><br><br>
<a name="vce_get_int4_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_int4_search</th></tr>
<tr><th>概要</th><td>4整数の検索エンジンで検索を実行する</td></tr>
<tr><th>カテゴリ</th><td>search</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void* vce_get_int4_search( int index , int key0 , int key1, int key2, int key3  )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>検索エンジンを特定するためのサーチデスクリプタ
</td></tr>
<tr><th>arg 2</Th><td>int key0</td></tr>
<tr><th></th><td>検索キーとなる整数、ひとつ目
</td></tr>
<tr><th>arg 3</Th><td>int key1</td></tr>
<tr><th></th><td>検索キーとなる整数、ふたつ目
</td></tr>
<tr><th>arg 4</Th><td>int key2</td></tr>
<tr><th></th><td>検索キーとなる整数、3つ目
</td></tr>
<tr><th>arg 5</Th><td>int key3</td></tr>
<tr><th></th><td>検索キーとなる整数、4つ目
</td></tr>
<tr><th>返り値</th><td>検索結果へのポインタ
</td></tr>
<tr><th>詳細説明</th><td>4つの検索キーに同時にマッチする値を取りだす。
検索の仕組については、 vce_init_int_search を参照
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_delete_int4_search">vce_delete_int4_search</a>
<a href="#vce_get_int4_or_search">vce_get_int4_or_search</a>
<a href="#vce_init_int4_search">vce_init_int4_search</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_update_int4_search">vce_update_int4_search</a>
</td></tr>
</table><br><br>
<a name="vce_get_int_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_int_search</th></tr>
<tr><th>概要</th><td>整数のサーチエンジンで値を検索する</td></tr>
<tr><th>カテゴリ</th><td>search</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void * vce_get_int_search( int index , int key )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>サーチエンジンを特定するサーチデスクリプタ
</td></tr>
<tr><th>arg 2</Th><td>int key</td></tr>
<tr><th></th><td>検索キーとなる整数値
</td></tr>
<tr><th>返り値</th><td>検索結果の値。
検索エンジンの中では，値は、直接保存されているわけではなく、
値へのポインタとして保存されている。値がみつかればそのポインタを、
見つからない場合はヌルポインタを返す。
</td></tr>
<tr><th>詳細説明</th><td>vce_init_int_search で初期化した検索エンジンに、
vce_update_int_search で値を登録し、
vce_get_int_search で値を取りだす。 vce_get_int_search は整数検索エンジン
を使用して値を検索する。 vce_get_int_search は非常に高速であり、
ハッシュ表の大きさが十分大きければ、
検索侯補の数にかかわらず1マイクロ秒以下の検索速度を実現する。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_init_int_search">vce_init_int_search</a>
</td></tr>
</table><br><br>
<a name="vce_get_ipv4_addr_by_name"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_ipv4_addr_by_name</th></tr>
<tr><th>概要</th><td>ホスト名から IPv4アドレス(ネットワークバイトオーダ)を得る</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_get_ipv4_addr_by_name( unsigned int *a, const char *s );</b></td>
<tr><th>arg 1</Th><td>unsigned int *a</td></tr>
<tr><th></th><td>IPv4アドレスのポインタ。出力に使われる。
出力はネットワークバイトオーダのままである。in_addr 構造体の
s_addr メンバそのもの。
</td></tr>
<tr><th>arg 2</Th><td>char *s</td></tr>
<tr><th></th><td>ホスト名。"192.168.1.2" や "www.vce-lab.net" などが指定できる。
</td></tr>
<tr><th>返り値</th><td>成功したら0、失敗したら負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>UNIXの場合は inet_aton 、 gethostbyname の順に呼びだす。
Win32の場合は、inet_addr, gethostbyname の順に呼びだす。
PlanetWeb の場合は，現在は DNS解決に対応していない．
</td></tr>
</table><br><br>
<a name="vce_get_last_error"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_last_error</th></tr>
<tr><th>概要</th><td>VCE内で最後に起こったエラー番号を取得する。</td></tr>
<tr><th>カテゴリ</th><td>err</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_get_last_error(void);</b></td>
<tr><th>返り値</th><td>エラーコードの値。
</td></tr>
<tr><th>詳細説明</th><td>この関数で取得されるエラー番号はすべて vce.h に定義されている。
それでエラーの内容を知ることができる他に、ログとして残したい場合は、
vce_strerror を利用することができる。
ただし、
vce_strerror の返す文字列の内容は将来変更されないとは限らないため、
その出力文字列をパースして処理に利用しないほうがよい。
vce.h で定義されているエラーコードは、
将来にわたって変更されることはない。(削除される場合は欠番となる。)
</td></tr>
<tr><th>使用例</th><td><pre>
// vce_tcpcontext_create はよくエラーが発生する関数である。
tcpcontext_t t = vce_tcpcontext_create( .... );
if( !t ){
    vce_errout( "Cannot create tcpcontext! %s\n",
    vce_strerror( vce_get_last_error() ) );
}
</pre>
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_strerror">vce_strerror</a>
</td></tr>
</table><br><br>
<a name="vce_get_netstat_string"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_netstat_string</th></tr>
<tr><th>概要</th><td>VCE が管理しているすべての接続情報を文字列で取得する。</td></tr>
<tr><th>カテゴリ</th><td>log</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_get_netstat_string( char *buf, int maxlen )</b></td>
<tr><th>arg 1</Th><td>char *buf</td></tr>
<tr><th></th><td>出力先文字列
</td></tr>
<tr><th>arg 2</Th><td>int maxlen</td></tr>
<tr><th></th><td>出力する最大の長さ
</td></tr>
<tr><th>返り値</th><td>バッファが余ったら0、埋まったら負(VCE_EFULL)を返す
</td></tr>
<tr><th>詳細説明</th><td>VCE が管理しているすべてのコネクションに関する情報を文字列で取りだす。
UNIXでいうところの、 netstat コマンドの出力に相当する内容となっている。
各コネクションの情報は "PARAM=VALUE" をコンマで区切ってならべた内容で、
1行あたり1コネクション(ソケット)となる。
行の基本種類は "circ","conn","listen_circ", "listen_conn", の4種類がある。
"conn" の場合に表示される情報が最も種類が多い。
<ul>
<LI>"type=conn" の場合の情報<BR>
type=conn は、通常のコネクションをあらわす。
<ul>
<LI>r=NUM  受信バッファの長さ(暗号デコード済み)
<LI>w=NUM  送信バッファの長さ(暗号エンコードまだ)
<LI>er=NUM  受信バッファの長さ(暗号デコードまだ)
<LI>ew=NUM  送信バッファの長さ(暗号エンコード済み)
<LI>rem=STR  リモートアドレス。 vce_conn_get_remote_addr_string の出力。
<LI>loc=STR  ローカルアドレス。 vce_conn_get_local_addr_string の出力。
<LI>fd=NUM  OS の socket fd.
<LI>s=NUM  VCE内のシリアル番号
<LI>last=NUM  最後にアクセスがあった時刻
<LI>timeo=NUM  タイムアウトまでの時間
<LI>nego=NUM  暗号ネゴシエーション状態
</ul>
<LI>"type=circ" の場合の情報<BR>
type=circ は、仮想回路(circ_t)をあらわす。
<UL>
<LI>r=NUM  読みこみバッファの長さ(暗号デコード済み)
<LI>rem=STR  リモートアドレス。vce_circ_get_remote_addr_string の出力
<LI>loc=STR  ローカルアドレス。親 conn_t のローカルアドレスを表示
<LI>s=NUM  circ_t のシリアル番号
<LI>last=NUM  最後にアクセスのあった時刻
</UL>
<LI>"type=listen_circ", "type=listen_conn" の場合<BR>
これらのタイプは、接続待ち状態の tcpcontext あたり1個、表示される。
ほかのホストとつながっているコネクションをあらわしているわけではない。
<UL>
<LI>loc=STR  ローカルアドレス。ソケットを bind しているアドレス
<LI>fd=NUM  ソケットの File Descriptor
</UL>
</ul>
アプリケーションは出力バッファのためのメモリを確保し、
本関数に与えなければならないが、そのためには1コネクションあたり
1コネクションあたり最大200バイト使うので，
最大コネクションに応じたサイズのバッファを渡す必要がある．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_stat">vce_get_stat</a>
</td></tr>
</table><br><br>
<a name="vce_get_search_usenum"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_search_usenum</th></tr>
<tr><th>概要</th><td>サーチエンジンのエントリの使用数を得る</td></tr>
<tr><th>カテゴリ</th><td>search</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_get_search_usenum( int index )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>情報を取得したいサーチエンジンのインデックス
</td></tr>
<tr><th>返り値</th><td>使用中の個数．
</td></tr>
<tr><th>詳細説明</th><td>サーチエンジンでは update することによってエントリが増え，
delete することによってエントリが減る．
update/delete の対応が取れていないとエントリがあふれてしまう．
このバグはサーバプログラミングにおいて頻発するバグである．
本関数を使って定期的に使用数を調べることは，
検索エンジンまわりのデバッグの助けとなる．
本関数はすべての種類のサーチエンジンに対して使用可能である．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_init_int_search">vce_init_int_search</a>
</td></tr>
</table><br><br>
<a name="vce_get_stat"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_stat</th></tr>
<tr><th>概要</th><td>VCE 全体の動作状況記録を取得する</td></tr>
<tr><th>カテゴリ</th><td>log</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_get_stat( vce_stat_t *v )</b></td>
<tr><th>arg 1</Th><td>vce_stat_t *v</td></tr>
<tr><th></th><td>記録を格納する vce_stat_t 構造体へのポインタ
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>本関数は、 vce_stat_t 構造体にVCE 全体の統計情報を格納する。
構造体メンバの意味は以下の通り。
<ul>
<LI>time_t boot_time<BR>
vce_initialize の起動時刻(time_t)
<LI>VCEI64 recv_byte,send_byte<BR>
読みこみ/書きこみ総バイト数
<LI>VCEI64 send_syscall, send_syscall_e<BR>
send() システムコールの呼びだし回数。 _e は、エラー発生回数
<LI>VCEI64 recv_syscall, recv_syscall_e<BR>
recv() システムコールの呼びだし回数。 _e は、エラー発生回数
<LI>VCEI64 accept_syscall, accept_syscall_e<BR>
accept() システムコールの呼びだし回数。 _e は、エラー発生回数
<LI>VCEI64 connect_syscall, connect_syscall_e<BR>
connect() システムコールの呼びだし回数。 _e は、エラー発生回数
<LI>conn_free, conn_alloc, conn_close, conn_write<BR>
VCE の各関数の呼びだし回数
<LI>keyex<BR>
DiffieHellman 鍵交換を使って鍵を交換した総回数。
鍵交換の負荷試験等に使う。
<LI>tcpcontext_create,tcpcontext_cleanup,tcpcontext_connect<BR>
各関数の呼びだし回数。成功したときだけ回数としてカウントされることに注意。
<LI>conn_timeout<BR>
コネクション(conn_t)がタイムアウトした回数
<LI>log_count<BR>
vce_errout や vce_errout0 を呼びだした回数。
</ul>
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_stat">vce_conn_get_stat</a>
<a href="#vce_tcpcontext_get_stat">vce_tcpcontext_get_stat</a>
</td></tr>
</table><br><br>
<a name="vce_get_string_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_string_search</th></tr>
<tr><th>概要</th><td>文字列サーチエンジンでキーから値を検索する</td></tr>
<tr><th>カテゴリ</th><td>search</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void * vce_get_string_search( int index , char *key )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>検索エンジンを特定するサーチデスクリプタ
</td></tr>
<tr><th>arg 2</Th><td>char *key</td></tr>
<tr><th></th><td>検索のキーとなる文字列
</td></tr>
<tr><th>返り値</th><td>検索に成功したら検索エンジンが保管している有効なポインタ，
失敗したらヌルポインタを返す
</td></tr>
<tr><th>詳細説明</th><td>文字列キーから値を検索する。
検索の仕組については、整数検索エンジン vce_init_int_search を参照。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_delete_string_search">vce_delete_string_search</a>
<a href="#vce_get_int_search">vce_get_int_search</a>
<a href="#vce_init_string_search">vce_init_string_search</a>
<a href="#vce_update_string_search">vce_update_string_search</a>
</td></tr>
</table><br><br>
<a name="vce_get_tcp_packet_read_size"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_tcp_packet_read_size</th></tr>
<tr><th>概要</th><td>読み込みデータの圧縮時のサイズと展開時のサイズを取得する</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_get_tcp_packet_read_size(int *original, int *processing)</b></td>
<tr><th>arg 1</Th><td>int *original</td></tr>
<tr><th></th><td>展開したデータサイズを返すためのバッファの先頭アドレス。
</td></tr>
<tr><th>arg 2</Th><td>int *processing</td></tr>
<tr><th></th><td>圧縮したデータサイズを返すためのバッファの先頭アドレス。
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>読み込みデータの圧縮時、展開時のデータサイズを取得できる。コールバック関数で
参照する。コールバック関数以外で使用するとたえず0になる。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_tcp_packet_read_size">vce_get_tcp_packet_read_size</a>
</td></tr>
</table><br><br>
<a name="vce_get_tcp_packet_write_size"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_tcp_packet_write_size</th></tr>
<tr><th>概要</th><td>書きこみデータの圧縮時のサイズと展開時のサイズを取得する</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_get_tcp_packet_write_size(int *original, int *processing)</b></td>
<tr><th>arg 1</Th><td>int *original</td></tr>
<tr><th></th><td>展開したデータサイズを返すためのバッファの先頭アドレス。
</td></tr>
<tr><th>arg 2</Th><td>int *processing</td></tr>
<tr><th></th><td>圧縮したデータサイズを返すためのバッファの先頭アドレス。
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>書きこみデータの圧縮時、展開時のデータサイズを取得できる。コールバック関数で
参照する。コールバック関数以外で使用するとたえず0になる。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_tcp_packet_read_size">vce_get_tcp_packet_read_size</a>
</td></tr>
</table><br><br>
<a name="vce_get_version"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_version</th></tr>
<tr><th>概要</th><td>VCEライブラリのバージョン番号を得る。</td></tr>
<tr><th>カテゴリ</th><td>core</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_get_version( int *majv, int *minv , int *rel )</b></td>
<tr><th>arg 1</Th><td>int *majv</td></tr>
<tr><th></th><td>VCEのメジャーバージョン。 VCE-0.2.1 の場合は0.
</td></tr>
<tr><th>arg 2</Th><td>int *minv</td></tr>
<tr><th></th><td>VCEのマイナーバージョン。VCE-0.2.1 の場合は2.
</td></tr>
<tr><th>arg 3</Th><td>int *rel</td></tr>
<tr><th></th><td>VCEのリリースバージョン。 VCE-0.2.1 の場合は1.
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>VCEライブラリには、バージョン番号が埋めこまれている。
vce_get_version関数は、それらの番号をint値として得る。
</td></tr>
<tr><th>使用例</th><td><pre>
  #include "vce.h"
  #include &lt;stdio.h&gt;
  int main( int argc, char **argv )
  {
      int a,b,c;
      vce_get_version( &amp;a, &amp;b, &amp;c );
      printf( "%d %d %d\n", a,b,c );
      return 0;
  }
</pre>
</td></tr>
</table><br><br>
<a name="vce_get_vstring_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_vstring_search</th></tr>
<tr><th>概要</th><td>任意長文字列検索エンジンでキーから値を検索する</td></tr>
<tr><th>カテゴリ</th><td>search</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void * vce_get_vstring_search( int index, char *key )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>検索エンジンを特定するサーチデスクリプタ
</td></tr>
<tr><th>arg 2</Th><td>char *key</td></tr>
<tr><th></th><td>検索のキーとなる文字列
</td></tr>
<tr><th>返り値</th><td>検索に成功したら検索エンジンが保管している有効なポインタ，
失敗したらヌルポインタを返す
</td></tr>
<tr><th>詳細説明</th><td>任意長の文字列キーから値を検索する。
検索の仕組については、整数検索エンジン vce_init_int_search を参照。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_init_vstring_search">vce_init_vstring_search</a>
</td></tr>
</table><br><br>
<a name="vce_heartbeat"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_heartbeat</th></tr>
<tr><th>概要</th><td>VCEを能動的に呼びだし、I/O処理をさせる。</td></tr>
<tr><th>カテゴリ</th><td>core</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_heartbeat( void )</b></td>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>VCEのI/O処理ルーチンを1回動かす。vce_mainloopではこの関数をずっと
呼びだし続けている。vce_mainloopではなくこの関数を使うことで、
より柔軟なユーザーメインルーチンを作ることができる。
この関数によってVCEをドライブする場合は、vce_set_mainloop_callback
関数で指定した関数は呼びだされないことに注意。
デフォルトでは、vce_heartbeat は呼びだしたらすぐにreturnするが、
このままサーバを起動すると、CPU時間を目一杯使用することになる。
vce_set_heartbeat_wait_flag 関数を使ってsleep時間を調整すれば、
この状況を回避できる。
もちろんCPU時間を一杯まで使わないようにする調整は、
アプリケーションの側で行なってもよく、
そのほうがアプリケーションごとに最適なCPU時間の利用ができる。
</td></tr>
<tr><th>使用例</th><td><pre>
  #include "vce.h"
  int main()
  {
      while(1){
          user_function();
          vce_heartbeat();
      }
  }
</pre>
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_mainloop">vce_mainloop</a>
<a href="#vce_set_heartbeat_wait_flag">vce_set_heartbeat_wait_flag</a>
<a href="#vce_set_mainloop_callback">vce_set_mainloop_callback</a>
</td></tr>
</table><br><br>
<a name="vce_httptext_divide_header_and_content"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_httptext_divide_header_and_content</th></tr>
<tr><th>概要</th><td>HTTPの入力において、データ本体とヘッダを分離する。</td></tr>
<tr><th>カテゴリ</th><td>text</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_httptext_divide_header_and_content( char *in , int inlen, char **head, int *headlen, char **body, int *bodylen )</b></td>
<tr><th>arg 1</Th><td>char *in</td></tr>
<tr><th></th><td>入力データの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int inlen</td></tr>
<tr><th></th><td>入力データの長さ
</td></tr>
<tr><th>arg 3</Th><td>char **head</td></tr>
<tr><th></th><td>ヘッダの各行へのポインタの配列(返り値用)
</td></tr>
<tr><th>arg 4</Th><td>int *headlen</td></tr>
<tr><th></th><td>ヘッダの各行の長さを格納する配列のアドレス(返り値用)
</td></tr>
<tr><th>arg 5</Th><td>char **body</td></tr>
<tr><th></th><td>メッセージ本体の先頭アドレスへのポインタ(返り値用)
</td></tr>
<tr><th>arg 6</Th><td>int *bodylen</td></tr>
<tr><th></th><td>メッセージ本体の長さへのポインタ(返り値用)
</td></tr>
<tr><th>返り値</th><td>ヘッダが存在しない場合(デリミタがない場合)は headlen = 0 となり、
戻り値は 0である。<BR>
メッセージ本体が存在しない場合は、 body=NULL, bodylen = 0 となり、
戻り値は0である。<BR>
両方存在しない場合はheadlen=0,body=NULL,bodylen=0となり、
VCE_EFORMAT を返す。
</td></tr>
<tr><th>詳細説明</th><td>HTTPにおけるリクエストヘッダとメッセージ本体とを分離する。
すべてオンメモリで処理する。
ヘッダのわかれ目としては、"\r\n\r\n" を見るが、"\n\n" にも対応する。<BR>
本関数は、VCEを使って高速なプログラムドHTTPサーバを実装する場合に必須となる。
ヘッダとデータ本体の分離を、 HTTP の「空行」デリミタだけを基準に
分離するので、実際のHTTP method が適切かどうかなどの判定は、
アプリケーションにまかされている。
</td></tr>
<tr><th>See also</th><td>
<a href="#hextext">hextext</a>
</td></tr>
</table><br><br>
<a name="vce_httptext_get_header_info"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_httptext_get_header_info</th></tr>
<tr><th>概要</th><td>HTTP ヘッダ全体の中から、指定したリクエストヘッダの値を取りだす</td></tr>
<tr><th>カテゴリ</th><td>text</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_httptext_get_header_info( char *h, int hlen , char *item , char *out, int outlen )</b></td>
<tr><th>arg 1</Th><td>char *h</td></tr>
<tr><th></th><td>HTTP ヘッダ全体を含む文字列の先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int hlen</td></tr>
<tr><th></th><td>ヘッダ全体の長さ
</td></tr>
<tr><th>arg 3</Th><td>char *item</td></tr>
<tr><th></th><td>取りだしたいリクエストヘッダの名前。 例："Content-Length"
</td></tr>
<tr><th>arg 4</Th><td>char *out</td></tr>
<tr><th></th><td>出力を格納するバッファの先頭アドレス。デリミタの改行記号は含まれない。
</td></tr>
<tr><th>arg 5</Th><td>int outlen</td></tr>
<tr><th></th><td>出力の最大長さ(バイト数)
</td></tr>
<tr><th>返り値</th><td>文字列をコピーした長さを返す。
項目が見つからない場合は空文字列を返し、戻り値は0となる。
</td></tr>
<tr><th>詳細説明</th><td>ヌル終端する。ヘッダに含まれる文字列に0というバイナリデータは含まれない
からである。
</td></tr>
</table><br><br>
<a name="vce_if_included_in_array"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_if_included_in_array</th></tr>
<tr><th>概要</th><td>配列のある要素が、正しく配列に含まれてるかどうかしらべる</td></tr>
<tr><th>カテゴリ</th><td>array</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_if_included_in_array( int index, void *p )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>配列を特定するための配列デスクリプタ
</td></tr>
<tr><th>arg 2</Th><td>void *p</td></tr>
<tr><th></th><td>調べたい要素をさすポインタ
</td></tr>
<tr><th>返り値</th><td>指定した配列に含まれているなら1、そうでないなら0を返す
引数が不正な場合は負のエラーコードを返す。
</td></tr>
<tr><th>詳細説明</th><td>void *p で指定される要素が、 index で指定される配列に含まれている
かどうかを調べる。<BR>
配列要素が正しく配列に含まれているかどうかを調べるには、
まず p から配列の先頭アドレスを引き、その結果を配列要素のサイズ
で割った余りを得る。その余りが0でない場合は、要素が正しく配置されて
いないことがわかる。
さらに、わりきれる場合でも、
商が0以上配列の要素数-1 の範囲を越えていたら、
範囲外に配置されているためエラーとなる。
</td></tr>
<tr><th>See also</th><td>
<a href="#ARRAY_SCAN">ARRAY_SCAN</a>
<a href="#vce_get_array_object_index">vce_get_array_object_index</a>
<a href="#vce_init_array">vce_init_array</a>
</td></tr>
</table><br><br>
<a name="vce_init_array"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_init_array</th></tr>
<tr><th>概要</th><td>新規にVCEの配列を初期化する。</td></tr>
<tr><th>カテゴリ</th><td>array</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_init_array ( size_t size , int num , char *nm )</b></td>
<tr><th>arg 1</Th><td>size_t size</td></tr>
<tr><th></th><td>配列の要素のサイズ(バイト数)
</td></tr>
<tr><th>arg 2</Th><td>int num</td></tr>
<tr><th></th><td>配列の要素の個数
</td></tr>
<tr><th>arg 3</Th><td>char *nm</td></tr>
<tr><th></th><td>配列の名前。名前を指定しておくと、VCE内で問題が生じたときに
ログに名前が出力されるのでデバッグの助けとなる。
</td></tr>
<tr><th>返り値</th><td>返り値： 成功したら0以上の配列ID。
このIDは今後のアクセスに使用する。この値をUNIXのファイルにならって、
配列デスクリプタと呼ぶ。失敗したらvce.h に定義されている負の値を返す。
</td></tr>
<tr><th>詳細説明</th><td>配列に必要なメモリを割りあてて配列をゼロクリアし、
使用中リストも同時に初期化する。
VCEの配列は、配列の初期化、空き要素の検索、解放を、
空きリストを実装することによって高速に実現できるように実装されている。
vce_init_array は、
概算で(要素のサイズ+20)×要素の個数 バイトのメモリを消費する。<BR>
vce_init_array が返すint値は、UNIXファイルの file descriptor のような
もので、今後の配列へのアクセスに使用する。<BR><BR>
VCE配列はVCEの処理の基盤ルーチンとして使用されている。<BR>
また、 vce_init_array 関数は内部で MALLOC 関数を使用している.
</td></tr>
<tr><th>See also</th><td>
<a href="#ARRAY_SCAN">ARRAY_SCAN</a>
<a href="#MALLOC">MALLOC</a>
<a href="#vce_alloc_array_object">vce_alloc_array_object</a>
<a href="#vce_end_array">vce_end_array</a>
<a href="#vce_free_array_object">vce_free_array_object</a>
<a href="#vce_free_array_object_all">vce_free_array_object_all</a>
</td></tr>
</table><br><br>
<a name="vce_init_int2_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_init_int2_search</th></tr>
<tr><th>概要</th><td>2整数の値を検索キーとする検索エンジンを初期化する</td></tr>
<tr><th>カテゴリ</th><td>search</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_init_int2_search( int hashtbl_size , int ent_num , char *sname )</b></td>
<tr><th>arg 1</Th><td>int hashtbl_size</td></tr>
<tr><th></th><td>ハッシュ表のサイズ。サイズのヒントについては、
vce_init_int_search を参照
</td></tr>
<tr><th>arg 2</Th><td>int ent_num</td></tr>
<tr><th></th><td>登録される「キーと値」の組の最大数。
</td></tr>
<tr><th>arg 3</Th><td>char *sname</td></tr>
<tr><th></th><td>検索エンジンの名前
</td></tr>
<tr><th>返り値</th><td>今後の検索関数の呼びだし時に使用するサーチデスクリプタ。
正常終了なら0以上の値を返し、異常終了なら負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>2整数を検索の組とするサーチエンジンを初期化する。
2整数の検索は、主にインターネットのアドレス(IPv4, 32bit address + 16bit port)
を検索キーとしてクライアント構造体へのポインタを検索するような用途に
用いられる。 vce_init_int2_search は、特にその検索を高速に実行する
必要のある、パケットベクトライザルーチンの内部で利用されている。
一般的な検索の仕組については、整数検索エンジンを参照。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_delete_int2_search">vce_delete_int2_search</a>
<a href="#vce_get_int2_search">vce_get_int2_search</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_update_int2_search">vce_update_int2_search</a>
</td></tr>
</table><br><br>
<a name="vce_init_int4_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_init_int4_search</th></tr>
<tr><th>概要</th><td>4整数の値を検索キーとする検索エンジンを初期化する</td></tr>
<tr><th>カテゴリ</th><td>search</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_init_int4_search( int hashtbl_size , int ent_num , char *sname )</b></td>
<tr><th>arg 1</Th><td>int hashtbl_size</td></tr>
<tr><th></th><td>ハッシュ表のサイズ。サイズのヒントについては、
vce_init_int_search を参照
</td></tr>
<tr><th>arg 2</Th><td>int ent_num</td></tr>
<tr><th></th><td>登録される「キーと値」の組の最大数。
</td></tr>
<tr><th>arg 3</Th><td>char *sname</td></tr>
<tr><th></th><td>検索エンジンの名前
</td></tr>
<tr><th>返り値</th><td>今後の検索関数の呼びだし時に使用するサーチデスクリプタ。
正常終了なら0以上の値を返し、異常終了なら負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>4整数を検索の組とするサーチエンジンを初期化する。
4整数の検索は、主にインターネットのアドレス(IPv4, 32bit address + 16bit port)
を検索キーとしてクライアント構造体へのポインタを検索するような用途に
用いられる。 vce_init_int4_search は、特にその検索を高速に実行する
必要のある、パケットベクトライザルーチンの内部で利用されている。
一般的な検索の仕組については、整数検索エンジンを参照。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_delete_int4_search">vce_delete_int4_search</a>
<a href="#vce_get_int4_search">vce_get_int4_search</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_update_int4_search">vce_update_int4_search</a>
</td></tr>
</table><br><br>
<a name="vce_init_int_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_init_int_search</th></tr>
<tr><th>概要</th><td>整数をキーとしてデータを検索するサーチエンジンを初期化</td></tr>
<tr><th>カテゴリ</th><td>search</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_init_int_search( int hashtbl_size , int ent_num , char *sname )</b></td>
<tr><th>arg 1</Th><td>int hashtbl_size</td></tr>
<tr><th></th><td>ハッシュ表のサイズ。ポインタの数の数分の1か、もしくは同じ程度にすると
検索速度が速い。できるだけ同じにするのが望ましいが、
大きくするためには大量のメモリを必要とする。トレードオフが存在する。
整数エンジンの場合は、この値を1大きくすると12バイトのメモリが必要である。
2整数エンジンの場合は、16バイト、文字列エンジンの場合は、
44バイト必要である。
</td></tr>
<tr><th>arg 2</Th><td>int ent_num</td></tr>
<tr><th></th><td>検索される情報を指すポインタの数(検索できる要素の数)
</td></tr>
<tr><th>arg 3</Th><td>char *sname</td></tr>
<tr><th></th><td>サーチエンジンの名前
</td></tr>
<tr><th>返り値</th><td>サーチエンジンを特定するためのint値。UNIXのファイルデスクリプタのように
使い、今後の検索時に第一引数として使用する。この値を、
VCEでは、「サーチデスクリプタ」と呼ぶことにする。
エラーが発生した場合は負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>検索エンジンをVCE内部で初期化し、それへアクセスするための
サーチデスクリプタを返す。<BR>
VCEのサーチエンジンは、メモリに固定的に確保されたハッシュ表を使った
検索を実装している。あらかじめ検索する情報が構造体の配列に格納されていて、
その配列の要素を検索して見つけるために使用される。<BR>
したがって、「検索キー」と「値を指すポインタ」の組をまずupdateし、
登録後に、検索キーを指定してそのポインタを見つけだすという風に使う。<BR>
この検索エンジンは非常に限られた用途にしか使えないが、
本格的な保存と検索をする場合はおそらく外部にDBMSが用意されることとなるので、
searchカテゴリの関数を使う最適な場面は、
「数万までの情報の中から単純な検索キーを用いて非常に高速な検索を
したい場合」である。ちなみに、1回の検索につき、外部DBMSを使うと1ms程度かかる
のに対し、 vce_init_int_search 等の関数を使うと、
1us程度の時間で済む。この速度の違いをうまく生かすことが望まれる。<BR>
vce_init_int_search は、内部で array カテゴリの関数を多く使用している。<BR>
また、VCEが一度に管理できるサーチエンジンの数は、
vce_initialize_limited 関数を使って調整できる(デフォルトでは256)．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_delete_int_search">vce_delete_int_search</a>
<a href="#vce_get_int_search">vce_get_int_search</a>
<a href="#vce_init_int2_search">vce_init_int2_search</a>
<a href="#vce_init_string_search">vce_init_string_search</a>
<a href="#vce_initialize_limited">vce_initialize_limited</a>
</td></tr>
</table><br><br>
<a name="vce_init_limit_t"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_init_limit_t</th></tr>
<tr><th>概要</th><td>vce_limit_t 構造体をデフォルト値に初期化する</td></tr>
<tr><th>カテゴリ</th><td>core</td></tr>
<tr><th>対応OS</th><td>linux,win32,other.darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b> void vce_init_limit_t( vce_limit_t *t )</b></td>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>vce_initialize_limited 関数に与える構造体引数である vce_limit_t を
正式に初期化する関数である。この構造体を使う場合はかならず
この関数を使って初期化しなければならない。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_initialize_limited">vce_initialize_limited</a>
</td></tr>
</table><br><br>
<a name="vce_init_string_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_init_string_search</th></tr>
<tr><th>概要</th><td>文字列のサーチエンジンを初期化する。</td></tr>
<tr><th>カテゴリ</th><td>search</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_init_string_search( int hashtbl_size , int ent_num , char *sname )</b></td>
<tr><th>arg 1</Th><td>int hashtbl_size</td></tr>
<tr><th></th><td>検索に使用するハッシュ表のサイズ
</td></tr>
<tr><th>arg 2</Th><td>int ent_num</td></tr>
<tr><th></th><td>検索される値を指すポインタを保存する最大数
</td></tr>
<tr><th>arg 3</Th><td>char *sname</td></tr>
<tr><th></th><td>検索エンジンの名前
</td></tr>
<tr><th>返り値</th><td>整数の，サーチディスクリプタ
</td></tr>
<tr><th>詳細説明</th><td>文字列を検索キーとして持つ検索エンジンを初期化する。
小規模で高速な検索を目的としている．大規模な検索が行ないたい
場合は外部の RDBMS などを使用する事．
小規模に限定しているため使用できる文字列の長さは32文字までである．
検索の仕組については vce_init_int_search の説明を参照。<BR>

vce_init_string_search で文字列検索エンジンを初期化した後、
vce_update_string_search を使用してキーから値を登録し、
vce_get_string_search を使用して実際に検索をする。
キーと値の組が必要なくなれば
vce_delete_string_search を使用して削除する。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_delete_string_search">vce_delete_string_search</a>
<a href="#vce_get_string_search">vce_get_string_search</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_update_string_search">vce_update_string_search</a>
</td></tr>
</table><br><br>
<a name="vce_init_vstring_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_init_vstring_search</th></tr>
<tr><th>概要</th><td>任意の長さの文字列をキーとして使う検索エンジンを初期化</td></tr>
<tr><th>カテゴリ</th><td>search</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_init_vstring_search( int hashtbl_size, int ent_num, int key_len, char *sname )</b></td>
<tr><th>arg 1</Th><td>int hashtbl_size</td></tr>
<tr><th></th><td>検索に使用するハッシュ表のサイズ
</td></tr>
<tr><th>arg 2</Th><td>int ent_num</td></tr>
<tr><th></th><td>検索される値を指すポインタを保存する最大数
</td></tr>
<tr><th>arg 3</Th><td>key_len</td></tr>
<tr><th></th><td>検索キーとなる文字列の最大の長さ
</td></tr>
<tr><th>arg 4</Th><td>char *sname</td></tr>
<tr><th></th><td>検索エンジンの名前
</td></tr>
<tr><th>返り値</th><td>初期化に成功したらゼロ以上，そうでない場合は負のエラーコードを返す．
</td></tr>
<tr><th>詳細説明</th><td>文字列を検索キーとして持つ検索エンジンを初期化する。
vce_init_string_search と異なり，
使用できる文字列の長さを key_len で任意の値に指定することができる．
vce_init_string_search と，文字列の長さが同じ場合は
速度も同じなので，完全に置きかえることが可能である．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_cleanup_search_engine">vce_cleanup_search_engine</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_init_string_search">vce_init_string_search</a>
</td></tr>
</table><br><br>
<a name="vce_initialize"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_initialize</th></tr>
<tr><th>概要</th><td>VCEを初期化する。</td></tr>
<tr><th>カテゴリ</th><td>core</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_initialize( void )</b></td>
<tr><th>返り値</th><td>正常に初期化できた場合は0、そうでない場合は負のエラーコード(vce.h)。
</td></tr>
<tr><th>詳細説明</th><td>VCEの関数を呼びだす前に必ず呼びださなければならない初期化関数である。
VCEの内部用メモリはこの関数で確保される．
またWindows環境においては、Winsockの初期化も同時に行なう。
UNIX 用では SIGPIPE をブロックする。
PS2 用VCEの場合は、アプリケーションでネットワークの初期化をする前に
本関数を呼びだしてから、
ソケットライブラリが初期化された時点で vce_set_socket_library_ok(1) を
呼びだすこと(サンプルを参照)
</td></tr>
<tr><th>使用例</th><td>// PS2 など、OS がソケットライブラリを提供していない場合のコード
int main()
{
    vce_initialize();

    // load inet libraries
    // load device dependent modules ..
    // Dialing ...

    while( wait_for_socket_init() );

    vce_set_socket_library_ok(1);

    t = vce_tcpcontext_create( ... );
    while(1){
        vce_heartbeat();
    }
}
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_finalize">vce_finalize</a>
<a href="#vce_set_socket_library_ok">vce_set_socket_library_ok</a>
</td></tr>
</table><br><br>
<a name="vce_initialize_limited"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_initialize_limited</th></tr>
<tr><th>概要</th><td>限られたメモリ使用量で VCE を初期化する</td></tr>
<tr><th>カテゴリ</th><td>core</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_initialize_limited( vce_limit_t *lim )</b></td>
<tr><th>arg 1</Th><td>vce_limit_t *lim</td></tr>
<tr><th></th><td>設定情報を含んだ vce_limit_t 構造体へのポインタ．
</td></tr>
<tr><th>返り値</th><td>正常に初期化できた場合は0、そうでない場合は負のエラーコード(vce.h)。
</td></tr>
<tr><th>詳細説明</th><td>vce_initialize と同じだが、 vce_limit_t 構造体を用いて、
メモリ使用量をチューニングできる。特にメモリ容量を限界までチューニング
したい環境において使用される。
vce_limit_t の各メンバはそれぞれ
<pre>
int max_tcpcontext  tcpcontext_t の最大個数
int max_taskgroup  taskgroup_t の最大個数
int max_conn  全体の conn_t の最大個数
int max_search  全体の検索エンジンの最大個数
int max_array  全体の配列エンジンの最大個数
int sendbuf_work_size  送信用ワーク領域のサイズ
int recvbuf_work_size  受信用ワーク領域のサイズ
</pre>
となっていて、0以上の値を指定することで設定可能。
-1 を指定するとデフォルト値を使用する。
すべての値をデフォルト値に設定するために
vce_init_limit_t 関数が用意されているのでそれを使用すること。
<BR>
max_array の最低値に関しては，VCE内部でも配列エンジンを使っているので
注意が必要である．VCEは内部で以下のように配列エンジンを使用する．
<ul>
<LI>conn,task処理用に2個，常時使用
<LI>tcpcontext は1個あたり4〜5個
<LI>switchcontext1個あたり3個
<LI>モニタリングクライアントは2個
<LI>モニタリングサーバーは5個 (うちtcpcontextが4個)
<LI>検索エンジンは1個あたり1個
<LI>taskgroup は1個
</ul>
これらのVCEのサービスは，配列が足りなくなると VCE_EARRAYを返す．
したがってVCEの各サービスの初期化関数が VCE_EARRAY を返したときは，
max_array の上限に注目してみるとよい．
また， max_array を1増やすごとに72バイトのメモリが確保される．
Linux/Win32環境では， max_array にデフォルト値の -1 を設定したときは
256が設定され， PS2環境では32が設定される．
<BR>
メモリを節約するという目的とは別に、デフォルトの最大値をもっと大きな値に
したいという場合にも本関数を使用できる。
典型的なのが、デフォルトの最大同時接続数1000 を、
もっと大きな値に変更する場合である。
その目的のためにも本関数を使用することができる。
ただし、ほとんどの linux/freeBSD  OS において、
カーネルの設定やユーザープロセス空間の limit によって最大接続数が
1024 以下に抑えられていることに注意が必要である。
この限界値を越えるには、カーネルの設定変更や
再コンパイル，シェルの設定変更が必要である。
Linux のチューニングについては <a href="linuxtune.html">こちら</a>を参照．
</td></tr>
<tr><th>使用例</th><td><pre>
int main(){
    // ゲームクライアント向けに共有メモリや検索エンジンを使わなくする
    vce_limit_t lim;
    lim.max_tcpcontext = 1;
    lim.max_taskgroup = -1;
    lim.max_conn = 1;
    lim.max_search = 0;
    lim.max_array = 0;
    lim.sendbuf_work_size = -1;
    lim.recvbuf_work_size = -1;
    vce_initialize_limited( &lim );
    vce_finalize();
}
</pre>
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_init_limit_t">vce_init_limit_t</a>
<a href="#vce_initialize">vce_initialize</a>
</td></tr>
</table><br><br>
<a name="vce_istore_init"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_istore_init</th></tr>
<tr><th>概要</th><td>一意な整数キーをもつデータをファイルに保存するistoreルーチンを初期化</td></tr>
<tr><th>カテゴリ</th><td>istore</td></tr>
<tr><th>対応OS</th><td>linux</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_istore_init( istore *is, char *dname , int dircheck )</b></td>
<tr><th>arg 1</Th><td>istore *is</td></tr>
<tr><th></th><td>vce_istore_save, vce_istore_load で使用する istore デスクリプタ。
</td></tr>
<tr><th>arg 2</Th><td>char *dname</td></tr>
<tr><th></th><td>データディレクトリ
</td></tr>
<tr><th>arg 3</Th><td>int dircheck</td></tr>
<tr><th></th><td>このフラグを0にすると、init時にディレクトリを用意しない。
これはアプリケーションの起動時間を短くする効果がある。
ダウンタイムに気をつかうアプリケーションでは効果的である。
ただしディレクトリが存在しない場合は、istore の動作に支障をきたす
ことになる。
通常1万個のディレクトリを初期化するにはディスクの速度によるが数分かかる。
</td></tr>
<tr><th>返り値</th><td>成功したら0、失敗したら負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>データディレクトリ以下に2段階、約10000個のディレクトリを作り、
その中に整数キーで検索されるファイルにデータを保存する。
vce_istore_init では、保存/取りだしルーチンで使われるデータや
データディレクトリを初期化する。
たとえば20045というファイルは TOPDIR/45/0/20045 という場所に保管される。
istoreの存在理由は、Linuxのext2ファイルシステムのように一つのディレクトリ
に多数のファイルを置くとファイルを見つけるまでの時間が極端に遅くなる
ようなシステムに大量のファイルを置くためである。
istoreルーチンはあくまで保存、取りだし専用であり検索性能はとても悪い。
<BR><BR>
注意： vce_istore_init は、トップディレクトリが存在しない場合は、
VCE_EMKDIR を返して異常終了する。ディレクトリを作成する場合は、
まずトップディレクトリを作成してから呼びだすこと。
トップディレクトリとは、vce_istore_initの第二引数で指定するディレクトリ
である。
</td></tr>
<tr><th>知られているバグやTODO</th><td>istoreはUNIXのファイル検索システムをそのまま使うので遅い。
ライトなコンテンツ向けなら十分だが、
MM RPG のようにシビアな速度が要求されるサービスで使うのはよくない。
また、ext3でも特に性能は変わらない(遅いことに変わりない)。
なお、現在はWin32環境ではistore関数は使えない。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_istore_load">vce_istore_load</a>
<a href="#vce_istore_save">vce_istore_save</a>
</td></tr>
</table><br><br>
<a name="vce_istore_load"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_istore_load</th></tr>
<tr><th>概要</th><td>istoreの読み出し用関数</td></tr>
<tr><th>カテゴリ</th><td>istore</td></tr>
<tr><th>対応OS</th><td>linux</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_istore_load( istore *is, unsigned int k, char *buf, int len )</b></td>
<tr><th>arg 1</Th><td>istore *is</td></tr>
<tr><th></th><td>istoreデスクリプタ
</td></tr>
<tr><th>arg 2</Th><td>unsigned int k</td></tr>
<tr><th></th><td>データ保存ファイルを決める整数キー値
</td></tr>
<tr><th>arg 3</Th><td>char *buf</td></tr>
<tr><th></th><td>保存データの先頭アドレス
</td></tr>
<tr><th>arg 4</Th><td>int len</td></tr>
<tr><th></th><td>保存データの最大長さ。
</td></tr>
<tr><th>返り値</th><td>Return 0 if successful, otherwize minus error code.
</td></tr>
<tr><th>詳細説明</th><td>This function is obsolete.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_istore_init">vce_istore_init</a>
<a href="#vce_istore_save">vce_istore_save</a>
</td></tr>
</table><br><br>
<a name="vce_istore_save"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_istore_save</th></tr>
<tr><th>概要</th><td>istoreの保存用関数</td></tr>
<tr><th>カテゴリ</th><td>istore</td></tr>
<tr><th>対応OS</th><td>linux</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_istore_save( istore *is, unsigned int k, char *buf, int len )</b></td>
<tr><th>arg 1</Th><td>istore *is</td></tr>
<tr><th></th><td>istore デスクリプタ(vce_istore_init)
</td></tr>
<tr><th>arg 2</Th><td>unsigned int k</td></tr>
<tr><th></th><td>データ保存ファイルを決めるキー値
</td></tr>
<tr><th>arg 3</Th><td>char *buf</td></tr>
<tr><th></th><td>保存するデータの先頭アドレス
</td></tr>
<tr><th>arg 4</Th><td>int len</td></tr>
<tr><th></th><td>保存するデータの長さ
</td></tr>
<tr><th>返り値</th><td>保存が成功した場合は保存できた長さ、失敗した場合は負のエラーコード。
</td></tr>
<tr><th>詳細説明</th><td>データをistoreのルールに基づいてディレクトリ内に保存する。
lenが0の場合は、ファイルを消去する。
その場合消去できなかったら VCE_EACCESSFILE を返す
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_istore_init">vce_istore_init</a>
<a href="#vce_istore_load">vce_istore_load</a>
</td></tr>
</table><br><br>
<a name="vce_iterate_int2_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_iterate_int2_search</th></tr>
<tr><th>概要</th><td>2整数の検索エンジンに登録されているすべてのエントリを処理する</td></tr>
<tr><th>カテゴリ</th><td>search</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_iterate_int2_search( int index, int (*callback)(void*))</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>検索エンジンを特定するためのサーチデスクリプタ
</td></tr>
<tr><th>arg 2</Th><td>int (*callback(void*))</td></tr>
<tr><th></th><td>処理内容を定義するコールバック関数．
コールバック関数の第一引数には，検索エンジンに登録されている
エントリデータへのポインタが代入される．
コールバック関数が負の値を返すと，
本関数はコールバック関数が返した値をそのまま返して途中で終了する．
</td></tr>
<tr><th>返り値</th><td>int値のサーチディスクリプタ
</td></tr>
<tr><th>詳細説明</th><td>検索エンジンに登録されているすべてのエントリに対して，
ある処理を実行したい場合に，本関数をつかって
コールバック関数を全エントリを引数として呼びだすことによって
この要求に応える．ruby言語のイテレータをイメージして使えばよい．
本関数の使用上の注意としては，イテレータ内で検索エンジンの登録状況
自体に影響を与えるような処理をしないことが必要である．
たとえば， vce_delete_int2_search 等を実行すると，呼びだし順番によっては，
検索エンジンが管理しているリスト構造が破壊されてしまうことになる．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_init_int2_search">vce_init_int2_search</a>
</td></tr>
</table><br><br>
<a name="vce_iterate_int4_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_iterate_int4_search</th></tr>
<tr><th>概要</th><td>4整数の検索エンジンに登録されているすべてのエントリを処理する</td></tr>
<tr><th>カテゴリ</th><td>search</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_iterate_int4_search( int index, int (*callback)(void*))</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>検索エンジンを特定するためのサーチデスクリプタ
</td></tr>
<tr><th>arg 2</Th><td>int (*callback(void*))</td></tr>
<tr><th></th><td>処理内容を定義するコールバック関数．
コールバック関数の第一引数には，検索エンジンに登録されている
エントリデータへのポインタが代入される．
コールバック関数が負の値を返すと，
本関数はコールバック関数が返した値をそのまま返して途中で終了する．
</td></tr>
<tr><th>返り値</th><td>int値のサーチディスクリプタ
</td></tr>
<tr><th>詳細説明</th><td>検索エンジンに登録されているすべてのエントリに対して，
ある処理を実行したい場合に，本関数をつかって
コールバック関数を全エントリを引数として呼びだすことによって
この要求に応える．ruby言語のイテレータをイメージして使えばよい．
本関数の使用上の注意としては，イテレータ内で検索エンジンの登録状況
自体に影響を与えるような処理をしないことが必要である．
たとえば， vce_delete_int4_search 等を実行すると，呼びだし順番によっては，
検索エンジンが管理しているリスト構造が破壊されてしまうことになる．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_init_int4_search">vce_init_int4_search</a>
</td></tr>
</table><br><br>
<a name="vce_limit_clear"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_limit_clear</th></tr>
<tr><th>概要</th><td>vce_limit_t型の構造体の初期化をする(-1のデフォルト値で初期化)</td></tr>
<tr><th>カテゴリ</th><td>core</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_limit_clear( vce_limit_t *t )</b></td>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>vce_initialize_limited 関数の引数として与えられるvce_limit_t型の
構造体の全部のメンバーに対して、デフォルト値である -1 を設定する。
この関数を使って vce_limit_t 型を初期化して vce_initialize_limited 関数を
呼び出すと、完全にデフォルトの設定が採用される。

</td></tr>
<tr><th>See also</th><td>
<a href="#vce_initialize_limited">vce_initialize_limited</a>
</td></tr>
</table><br><br>
<a name="vce_log_add_monitor_command"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_log_add_monitor_command</th></tr>
<tr><th>概要</th><td>VCE Logに関連したモニターコマンドを追加する</td></tr>
<tr><th>カテゴリ</th><td>log</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_log_add_monitor_command()</b></td>
<tr><th>arg 1</Th><td>int type</td></tr>
<tr><th></th><td>ログタイプ
</td></tr>
<tr><th>arg 2</Th><td>char *id</td></tr>
<tr><th></th><td>IDを表す文字列
</td></tr>
<tr><th>arg 3</Th><td>char *char_name</td></tr>
<tr><th></th><td>キャラクター名を表す文字列
</td></tr>
<tr><th>arg 4</Th><td>char *format</td></tr>
<tr><th></th><td>printf()と同様のフォーマット文字列
</td></tr>
<tr><th>返り値</th><td>正常終了ならばゼロ，そうでないならば負のエラーコードを返す．
</td></tr>
<tr><th>詳細説明</th><td>以下の二つのコマンドを追加する
set_logmask, get_log_types
</td></tr>
</table><br><br>
<a name="vce_log_add_type"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_log_add_type</th></tr>
<tr><th>概要</th><td>ログタイプを追加する</td></tr>
<tr><th>カテゴリ</th><td>log</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_log_add_type( int type, char *tag )</b></td>
<tr><th>arg 1</Th><td>int type</td></tr>
<tr><th></th><td>ログタイプ番号(0〜31の値)
</td></tr>
<tr><th>arg 2</Th><td>char *tag</td></tr>
<tr><th></th><td>ログタイプの名前を表す文字列
</td></tr>
<tr><th>返り値</th><td>正常終了ならばゼロ，そうでないならば負のエラーコードを返す．
</td></tr>
<tr><th>詳細説明</th><td>ログタイプを追加する。
ログタイプは、ログの種類を表す文字列で、検索のキーとして利用される。
</td></tr>
<tr><th>See also</th><td>
<a href="# vce_log_set_type_mask_by_name"> vce_log_set_type_mask_by_name</a>
<a href="#vce_log_set_type_mask">vce_log_set_type_mask</a>
</td></tr>
</table><br><br>
<a name="vce_log_get_types"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_log_get_types</th></tr>
<tr><th>概要</th><td>logtype をスペース区切で取得する</td></tr>
<tr><th>カテゴリ</th><td>log</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_log_get_types( char *buf, int buf_len )</b></td>
<tr><th>arg 1</Th><td>char *buf</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 2</Th><td>int buf_len</td></tr>
<tr><th></th><td></td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_log_add_type">vce_log_add_type</a>
<a href="#vce_log_set_type_mask">vce_log_set_type_mask</a>
<a href="#vce_log_set_type_mask_by_name">vce_log_set_type_mask_by_name</a>
</td></tr>
</table><br><br>
<a name="vce_log_gettime_long"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_log_gettime_long</th></tr>
<tr><th>概要</th><td>時間を表す文字列を取得する</td></tr>
<tr><th>カテゴリ</th><td>log</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_log_gettime_long( char *buf, int len )</b></td>
<tr><th>arg 1</Th><td>char *buf</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td></td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_log_gettime_normal">vce_log_gettime_normal</a>
<a href="#vce_log_gettime_short">vce_log_gettime_short</a>
</td></tr>
</table><br><br>
<a name="vce_log_gettime_normal"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_log_gettime_normal</th></tr>
<tr><th>概要</th><td>時間を表す文字列を取得する</td></tr>
<tr><th>カテゴリ</th><td>log</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_log_gettime_normal( char *buf, int len )</b></td>
<tr><th>arg 1</Th><td>char *buf</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td></td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_log_gettime_long">vce_log_gettime_long</a>
<a href="#vce_log_gettime_short">vce_log_gettime_short</a>
</td></tr>
</table><br><br>
<a name="vce_log_gettime_short"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_log_gettime_short</th></tr>
<tr><th>概要</th><td>時間を表す文字列を取得する</td></tr>
<tr><th>カテゴリ</th><td>log</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_log_gettime_short( char *buf, int len )</b></td>
<tr><th>arg 1</Th><td>char *buf</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td></td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_log_gettime_long">vce_log_gettime_long</a>
<a href="#vce_log_gettime_normal">vce_log_gettime_normal</a>
</td></tr>
</table><br><br>
<a name="vce_log_init"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_log_init</th></tr>
<tr><th>概要</th><td>VCE Logの初期化を行う</td></tr>
<tr><th>カテゴリ</th><td>log</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_log_init( printf_func_t printf_func )</b></td>
<tr><th>arg 1</Th><td>printf_func_t printf_func</td></tr>
<tr><th></th><td>printf_funcには、ログ表示をするための関数
printfと同じプロトタイプなので、vce_erroutを指定する場合は、(printf_func_t)vce_errout とキャストする必要があります。
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>VCE Logの初期化を行います。
</td></tr>
</table><br><br>
<a name="vce_log_parse"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_log_parse</th></tr>
<tr><th>概要</th><td></td></tr>
<tr><th>カテゴリ</th><td>log</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_log_parse( const char *line, int line_len, char *date, int date_len, char *type, int type_len, char *id, int id_len, char *name, int name_len, char *text, int text_len )</b></td>
<tr><th>arg 1</Th><td>const char *line</td></tr>
<tr><th></th><td>解析したいログデータの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int line_len</td></tr>
<tr><th></th><td>解析したいログデータの長さ
</td></tr>
<tr><th>arg 3</Th><td>char *date</td></tr>
<tr><th></th><td>日付が格納されるバッファの先頭アドレス
</td></tr>
<tr><th>arg 4</Th><td>int date_len</td></tr>
<tr><th></th><td>日付出力の長さ
</td></tr>
<tr><th>arg 5</Th><td>char *type</td></tr>
<tr><th></th><td>ログタイプが格納されるバッファの先頭アドレス
</td></tr>
<tr><th>arg 6</Th><td>int type_len</td></tr>
<tr><th></th><td>ログタイプ出力の長さ
</td></tr>
<tr><th>arg 7</Th><td>char *id</td></tr>
<tr><th></th><td>IDが格納されるバッファの先頭アドレス
</td></tr>
<tr><th>arg 8</Th><td>int id_len</td></tr>
<tr><th></th><td>ID出力の長さ
</td></tr>
<tr><th>arg 9</Th><td>char *name</td></tr>
<tr><th></th><td>nameが格納されるバッファの先頭アドレス
</td></tr>
<tr><th>arg 10</Th><td>int name_len</td></tr>
<tr><th></th><td>name出力の長さ
</td></tr>
<tr><th>arg 11</Th><td>char *text</td></tr>
<tr><th></th><td>textが格納されるバッファの先頭アドレス
</td></tr>
<tr><th>arg 12</Th><td>int text_len</td></tr>
<tr><th></th><td>text出力の長さ
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>VCEログフォーマットに基くログから各情報を取り出す。VCEログフォーマットについては、<a href="monitor.html">「VCEモニタリング」</a>を参照。
</td></tr>
</table><br><br>
<a name="vce_log_print"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_log_print</th></tr>
<tr><th>概要</th><td></td></tr>
<tr><th>カテゴリ</th><td>log</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_log_print( int type, char *id, char *char_name, char *format, ... )</b></td>
<tr><th>arg 1</Th><td>int type</td></tr>
<tr><th></th><td>ログタイプ
</td></tr>
<tr><th>arg 2</Th><td>char *id</td></tr>
<tr><th></th><td>IDを表す文字列
</td></tr>
<tr><th>arg 3</Th><td>char *char_name</td></tr>
<tr><th></th><td>キャラクター名を表す文字列
</td></tr>
<tr><th>arg 4</Th><td>char *format</td></tr>
<tr><th></th><td>printf()と同様のフォーマット文字列
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_log_vprint">vce_log_vprint</a>
</td></tr>
</table><br><br>
<a name="vce_log_set_gettime_func"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_log_set_gettime_func</th></tr>
<tr><th>概要</th><td>時間を取得する関数を指定する</td></tr>
<tr><th>カテゴリ</th><td>log</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_log_set_gettime_func( gettime_func_t gettime )</b></td>
<tr><th>arg 1</Th><td>gettime_func_t gettime</td></tr>
<tr><th></th><td></td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_log_gettime_long">vce_log_gettime_long</a>
<a href="#vce_log_gettime_normal">vce_log_gettime_normal</a>
<a href="#vce_log_gettime_short">vce_log_gettime_short</a>
</td></tr>
</table><br><br>
<a name="vce_log_set_type_mask"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_log_set_type_mask</th></tr>
<tr><th>概要</th><td>表示するログタイプを設定する</td></tr>
<tr><th>カテゴリ</th><td>log</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_log_set_type_mask( unsigned int mask )</b></td>
<tr><th>arg 1</Th><td>unsigned int mask</td></tr>
<tr><th></th><td>表示するログタイプ
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>maskにはログタイプに対応するビットを立てた数値を指定する。
</td></tr>
<tr><th>See also</th><td>
<a href="# vce_log_set_type_mask_by_name"> vce_log_set_type_mask_by_name</a>
<a href="#vce_log_add_type">vce_log_add_type</a>
</td></tr>
</table><br><br>
<a name="vce_log_set_type_mask_by_name"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_log_set_type_mask_by_name</th></tr>
<tr><th>概要</th><td>表示するログタイプを設定する</td></tr>
<tr><th>カテゴリ</th><td>log</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_log_set_type_mask_by_name( char *name, int on_off )</b></td>
<tr><th>arg 1</Th><td>char *name</td></tr>
<tr><th></th><td>表示するログタイプの名前
</td></tr>
<tr><th>arg 2</Th><td>int on_off</td></tr>
<tr><th></th><td>表示する/表示しない。マイナスなら反転させる
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td></td></tr>
<tr><th>See also</th><td>
<a href="# vce_log_set_type_mask"> vce_log_set_type_mask</a>
<a href="#vce_log_add_type">vce_log_add_type</a>
</td></tr>
</table><br><br>
<a name="vce_log_vprint"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_log_vprint</th></tr>
<tr><th>概要</th><td>VCEログフォーマットでログを出力する(va_list版)</td></tr>
<tr><th>カテゴリ</th><td>log</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_log_vprint( int type, char *id, char *char_name, char *format, va_list va )</b></td>
<tr><th>arg 1</Th><td>int type</td></tr>
<tr><th></th><td>ログタイプ
</td></tr>
<tr><th>arg 2</Th><td>char *id</td></tr>
<tr><th></th><td>IDを表す文字列
</td></tr>
<tr><th>arg 3</Th><td>char *char_name</td></tr>
<tr><th></th><td>キャラクター名を表す文字列
</td></tr>
<tr><th>arg 4</Th><td>char *format</td></tr>
<tr><th></th><td>printf()と同様のフォーマット文字列
</td></tr>
<tr><th>arg 5</Th><td>va_list va</td></tr>
<tr><th></th><td>可変引数リスト
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_log_print">vce_log_print</a>
</td></tr>
</table><br><br>
<a name="vce_logwriter_connect"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_logwriter_connect</th></tr>
<tr><th>概要</th><td>ログライターをrsvに接続する</td></tr>
<tr><th>カテゴリ</th><td>logwriter</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>logwriter_t *vce_logwriter_connect( char *addr, int port, int id )</b></td>
<tr><th>arg 1</Th><td>char *addr</td></tr>
<tr><th></th><td>接続先のアドレス
</td></tr>
<tr><th>arg 2</Th><td>int port</td></tr>
<tr><th></th><td>接続先のポート
</td></tr>
<tr><th>arg 3</Th><td>int id</td></tr>
<tr><th></th><td>Log writerを識別するためのID。通常は、自分のサービスポートを指定します
</td></tr>
<tr><th>返り値</th><td>作成されたlogwriterが返される。失敗した場合は、NULLが返る。
</td></tr>
<tr><th>詳細説明</th><td>この関数を呼んだあとに、vce_logwriter_poll()を繰り返すことにより、ログライターがrsvにログを書き込めるようになります。
ただし、それまでのログも一部はバッファにため込まれ、接続した瞬間に書き出されます。
admsvの検索機能と連係させるには、IDには、サービスポート(admcli.exeのプロセスWindowのPortの項目にでる数値)を指定してください。この値をもとに、admsvはバインディングを行います。
</td></tr>
<tr><th>See also</th><td>
<a href="# vce_logwriter_poll"> vce_logwriter_poll</a>
<a href="#vce_logwriter_init">vce_logwriter_init</a>
</td></tr>
</table><br><br>
<a name="vce_logwriter_init"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_logwriter_init</th></tr>
<tr><th>概要</th><td>Log writerを初期化する</td></tr>
<tr><th>カテゴリ</th><td>logwriter</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_logwriter_init( int num )</b></td>
<tr><th>arg 1</Th><td>int num</td></tr>
<tr><th></th><td>Log writerの数を指定する。通常は、一つで十分
</td></tr>
<tr><th>返り値</th><td>正常終了ならばゼロ，そうでないならば負のエラーコードを返す．
</td></tr>
<tr><th>詳細説明</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_logwriter_connect">vce_logwriter_connect</a>
</td></tr>
</table><br><br>
<a name="vce_logwriter_poll"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_logwriter_poll</th></tr>
<tr><th>概要</th><td></td></tr>
<tr><th>カテゴリ</th><td>logwriter</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_logwriter_poll</b></td>
<tr><th>返り値</th><td>正常終了ならばゼロ，そうでないならば負のエラーコードを返す．
</td></tr>
<tr><th>詳細説明</th><td>vce_logwriter_connect()を呼んだ後に、この関数を定期的に呼ぶことで接続や、切断された際の再接続を行います。
vce_heartbeat()の度に呼んで下さい。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_logwriter_connect">vce_logwriter_connect</a>
</td></tr>
</table><br><br>
<a name="vce_logwriter_printf"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_logwriter_printf</th></tr>
<tr><th>概要</th><td></td></tr>
<tr><th>カテゴリ</th><td>logwriter</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_logwriter_printf( logwriter_t *w, const char *format, ... )</b></td>
<tr><th>arg 1</Th><td>logwriter_t *w</td></tr>
<tr><th></th><td>ログを書き込むlogwriter
</td></tr>
<tr><th>arg 2</Th><td>char *format</td></tr>
<tr><th></th><td>フォーマット文字列
</td></tr>
<tr><th>返り値</th><td>正常終了ならばゼロ，そうでないならば負のエラーコードを返す．
</td></tr>
<tr><th>詳細説明</th><td>ログをrsvに書き込む。
接続されていない場合は、バッファに入る限りはバッファにため込み、vce_logwriter_pollで接続した瞬間に書き込む。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_logwriter_poll">vce_logwriter_poll</a>
<a href="#vce_logwriter_vprintf">vce_logwriter_vprintf</a>
</td></tr>
</table><br><br>
<a name="vce_logwriter_vprintf"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_logwriter_vprintf</th></tr>
<tr><th>概要</th><td></td></tr>
<tr><th>カテゴリ</th><td>logwriter</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_logwriter_vprintf( logwriter_t *w, const char *format, va_list va )</b></td>
<tr><th>arg 1</Th><td>logwriter_t *w</td></tr>
<tr><th></th><td>ログを書き込むlogwriter
</td></tr>
<tr><th>arg 2</Th><td>char *format</td></tr>
<tr><th></th><td>フォーマット文字列
</td></tr>
<tr><th>arg 3</Th><td>va_list va</td></tr>
<tr><th></th><td>可変引数リスト
</td></tr>
<tr><th>返り値</th><td>正常終了ならばゼロ，そうでないならば負のエラーコードを返す．
</td></tr>
<tr><th>詳細説明</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_logwriter_poll">vce_logwriter_poll</a>
<a href="#vce_logwriter_printf">vce_logwriter_printf</a>
</td></tr>
</table><br><br>
<a name="vce_mainloop"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_mainloop</th></tr>
<tr><th>概要</th><td>VCEのメインループ関数。</td></tr>
<tr><th>カテゴリ</th><td>core</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_mainloop(void)</b></td>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>この関数を呼びだすことにより、CPUをVCEに渡す。
この関数から戻ることはない。vce_set_mainloop_callback関数によって
コールバック関数が定義されている場合は、
この関数の中から永久的にその関数が呼びだされ続ける。
またその関数が0以外を返した場合は、vce_mainloopはその関数が返した値を
そのまま返し、終了する。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_set_mainloop_callback">vce_set_mainloop_callback</a>
</td></tr>
</table><br><br>
<a name="vce_make_binary_array_from_hex"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_make_binary_array_from_hex</th></tr>
<tr><th>概要</th><td>16進数文字列を変換して、バイナリデータを含む配列を作る。</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_make_binary_array_from_hex( char *out, int outlen, const char *hex )</b></td>
<tr><th>arg 1</Th><td>char *out</td></tr>
<tr><th></th><td>バイナリデータ出力先の先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int outlen</td></tr>
<tr><th></th><td>入力データの長さ(偶数でない場合は、0をうしろに単に足したものを出力する)
</td></tr>
<tr><th>arg 3</Th><td>char *hex</td></tr>
<tr><th></th><td>入力データ。
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>"788ab0d8ce8df6" のような文字列から、バイナリデータの配列を作る。
2文字で1バイトを生成するため、奇数の文字数のデータが指定されたときには、
最後に0を単純に足したものを生成して出力する。
通常は、偶数文字数のテキストを指定して呼びだすこと。
vce_make_hex_from_binary_array の逆関数．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_make_hex_from_binary_array">vce_make_hex_from_binary_array</a>
</td></tr>
</table><br><br>
<a name="vce_make_binary_array_from_line"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_make_binary_array_from_line</th></tr>
<tr><th>概要</th><td>ASCIIテキストの1行からバイナリデータの配列を出力する</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_make_binary_array_from_line( const char *line, int linelen, char *out, int *outlen, int *uselen )</b></td>
<tr><th>arg 1</Th><td>char *line</td></tr>
<tr><th></th><td>入力行
</td></tr>
<tr><th>arg 2</Th><td>int linelen</td></tr>
<tr><th></th><td>入力行の長さ。
</td></tr>
<tr><th>arg 3</Th><td>char *out</td></tr>
<tr><th></th><td>出力バッファ
</td></tr>
<tr><th>arg 4</Th><td>int *outlen</td></tr>
<tr><th></th><td>出力バッファの長さ。値結果引数で、まず 最大長さを与えて呼びだし、
関数が返る時には、実際に使用した長さを代入して返す。
</td></tr>
<tr><th>arg 5</Th><td>int *uselen</td></tr>
<tr><th></th><td>実際にテキストの行を読んだ長さを返す。
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>"\r\n" と "\n" のどちらでおわってるかわからない行から
バイナリ配列をつくる。
成功した場合は、実際に配列を埋めた長さを outlen で返し、
入力行を実際に読んだ長さを uselen で返す。
</td></tr>
</table><br><br>
<a name="vce_make_hex_from_binary_array"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_make_hex_from_binary_array</th></tr>
<tr><th>概要</th><td>バイナリデータ配列から，単一のhex の文字列を作る</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_make_hex_from_binary_array( char *out, int outlen, const char *buf,int len, int folding)</b></td>
<tr><th>arg 1</Th><td>char *out</td></tr>
<tr><th></th><td>出力先バッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int outlen</td></tr>
<tr><th></th><td>出力先バッファの長さ
</td></tr>
<tr><th>arg 3</Th><td>char *buf</td></tr>
<tr><th></th><td>入力バッファの先頭アドレス
</td></tr>
<tr><th>arg 4</Th><td>int len</td></tr>
<tr><th></th><td>入力バッファの長さ
</td></tr>
<tr><th>arg 5</Th><td>int folding</td></tr>
<tr><th></th><td>32文字(入力の16バイト)ごとに折りかえすかどうかのフラグ．
折りかえすなら1，そうでないなら0．
折りかえさない場合は，どんなに入力が長くても1個の，
改行を含まない文字列になる．
また folding が 1 のときは，文字列の末尾に改行記号が UNIX 方式で入る．
</td></tr>
<tr><th>返り値</th><td>出力先がいっぱいになった場合は、 VCE_EFULLを返す。
そうでない場合は出力の文字数を返す(ヌル文字は含まない)
</td></tr>
<tr><th>詳細説明</th><td>変換結果は、1バイトが2文字になるので，成功した場合は，
出力は常に入力の2倍の文字数になる．
たとえば "abc" は "616263" となる．
この関数は vce_make_hex_text_from_buffer 関数のベース関数である．
</td></tr>
<tr><th>See also</th><td>
<a href="#hextext">hextext</a>
<a href="#vce_make_hex_text_from_buffer">vce_make_hex_text_from_buffer</a>
</td></tr>
</table><br><br>
<a name="vce_make_hex_text_from_buffer"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_make_hex_text_from_buffer</th></tr>
<tr><th>概要</th><td>バイナリデータ配列から、 hextext 形式のASCIIテキストを出力する。</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_make_hex_text_from_buffer( const char *buf , int len , char *out , int outlen )</b></td>
<tr><th>arg 1</Th><td>char *buf</td></tr>
<tr><th></th><td>入力となるバイナリデータの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>入力データの長さ
</td></tr>
<tr><th>arg 3</Th><td>char *out</td></tr>
<tr><th></th><td>出力先の先頭アドレス
</td></tr>
<tr><th>arg 4</Th><td>int outlen</td></tr>
<tr><th></th><td>出力する最大長さ(バイト数)
</td></tr>
<tr><th>返り値</th><td>出力先がいっぱいになった場合は、 VCE_EFULLを返す。
そうでない場合は出力した文字数を返す(ヌル文字は含まない)
</td></tr>
<tr><th>詳細説明</th><td>変換結果は、1バイトが2文字になる。
先頭のヘッダは、そのバッファをデコードするために必要な情報が記述されている。
中身の正当性をチェックするために、SHA-1によるチェックサムの値と、
長さが含まれている。読みこみルーチンではこれらすべての値が正しいことを
確認する。
変換した文字列は，
vce_make_binary_array_from_hex 関数で元に戻すことができる．
</td></tr>
<tr><th>See also</th><td>
<a href="#hextext">hextext</a>
<a href="#vce_extract_data_from_hex_text">vce_extract_data_from_hex_text</a>
<a href="#vce_make_binary_array_from_hex">vce_make_binary_array_from_hex</a>
</td></tr>
</table><br><br>
<a name="vce_makecstr"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_makecstr</th></tr>
<tr><th>概要</th><td>ヌル終端されていないバッファからC言語の文字列を作る</td></tr>
<tr><th>カテゴリ</th><td>text</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>char * vce_makecstr( char *out, int outlen, char *in, int inlen )</b></td>
<tr><th>arg 1</Th><td>char *out</td></tr>
<tr><th></th><td>出力のC言語文字列が格納されるバッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int outlen</td></tr>
<tr><th></th><td>出力の最大長さ。終端のヌル文字も含む長さ。
つまり10を指定すると9文字プラスヌル文字が格納され得る。
</td></tr>
<tr><th>arg 3</Th><td>char *in</td></tr>
<tr><th></th><td>入力のバッファの先頭アドレス
</td></tr>
<tr><th>arg 4</Th><td>int inlen</td></tr>
<tr><th></th><td>入力の長さ。ヌル終端されていないのでこの値が10なら10文字が格納されている。
</td></tr>
<tr><th>返り値</th><td>out の値をそのまま返す
</td></tr>
<tr><th>詳細説明</th><td>プロトコルの処理などでは「長さ+中身」というデータの持ちかたを
する時が多いが、 printf などで出力したい場合にはどうしてもC言語方式の
文字列に変換する必要がある。本関数では、「長さ+中身」からヌル終端の
C文字列への変換を行なう。
</td></tr>
</table><br><br>
<a name="vce_monitor_client_add"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_client_add</th></tr>
<tr><th>概要</th><td>モニタークライアントに，接続先を1個追加する.</td></tr>
<tr><th>カテゴリ</th><td>monitor</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_monitor_client_add( monitor_ent_t *m )</b></td>
<tr><th>arg 1</Th><td>monitor_ent_t *m</td></tr>
<tr><th></th><td>設定情報を格納している構造体へのポインタ
</td></tr>
<tr><th>返り値</th><td>追加に成功したらゼロ，失敗したら負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>モニタークライアントに，新しく接続先を追加する．
実際の接続は vce_monitor_client_connect が行う.
設定情報を格納する構造体を初期化するには，
vce_monitor_ent_init 関数を使うと便利である．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_monitor_client_add">vce_monitor_client_add</a>
<a href="#vce_monitor_client_enable">vce_monitor_client_enable</a>
</td></tr>
</table><br><br>
<a name="vce_monitor_client_call"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_client_call</th></tr>
<tr><th>概要</th><td>モニターしているプロセスに，コマンドを送信する</td></tr>
<tr><th>カテゴリ</th><td>monitor</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_monitor_client_call( int id, int serial, char *s )</b></td>
<tr><th>arg 1</Th><td>int id</td></tr>
<tr><th></th><td>モニター設定のID
</td></tr>
<tr><th>arg 2</Th><td>int serial</td></tr>
<tr><th></th><td>対応づけをするためのシリアル
</td></tr>
<tr><th>arg 3</Th><td>char *s</td></tr>
<tr><th></th><td>送信する文字列
</td></tr>
<tr><th>返り値</th><td>送信に成功したらプラスの値，失敗したらゼロ以下を返す
</td></tr>
<tr><th>詳細説明</th><td>引数に指定された文字列を，
そのまま，モニターしているプロセスに送信する．
成功したら，送信したバイト数を返す．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_monitor_client_add">vce_monitor_client_add</a>
<a href="#vce_monitor_client_callable">vce_monitor_client_callable</a>
<a href="#vce_monitor_client_enable">vce_monitor_client_enable</a>
</td></tr>
</table><br><br>
<a name="vce_monitor_client_callable"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_client_callable</th></tr>
<tr><th>概要</th><td>モニターしているプロセスに，コマンドを送信できるか調べる</td></tr>
<tr><th>カテゴリ</th><td>monitor</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_monitor_client_callable( int id )</b></td>
<tr><th>arg 1</Th><td>int id</td></tr>
<tr><th></th><td>調べる対象のモニター設定のID
</td></tr>
<tr><th>返り値</th><td>送信できるならプラスの値，そうでないならゼロ以下の値を返す．
かならず，この返り値が 0 <B>よりも大きいかどうか</B>
を調べること．
</td></tr>
<tr><th>詳細説明</th><td>指定したIDをもつモニター先プロセスに対して，
コマンドが送信可能かどうかしらべる．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_monitor_client_add">vce_monitor_client_add</a>
<a href="#vce_monitor_client_call">vce_monitor_client_call</a>
<a href="#vce_monitor_client_enable">vce_monitor_client_enable</a>
</td></tr>
</table><br><br>
<a name="vce_monitor_client_connect"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_client_connect</th></tr>
<tr><th>概要</th><td>モニターエントリと接続する.</td></tr>
<tr><th>カテゴリ</th><td>monitor</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_monitor_client_connect( int id )</b></td>
<tr><th>arg 1</Th><td>int id</td></tr>
<tr><th></th><td>対象のモニター設定のID
</td></tr>
<tr><th>返り値</th><td>追加に成功したらゼロ，失敗したら負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>モニタークライアント追加されているモニターエントリと接続する.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_monitor_client_add">vce_monitor_client_add</a>
<a href="#vce_monitor_client_delete">vce_monitor_client_delete</a>
<a href="#vce_monitor_client_disconnect">vce_monitor_client_disconnect</a>
<a href="#vce_monitor_client_enable">vce_monitor_client_enable</a>
</td></tr>
</table><br><br>
<a name="vce_monitor_client_connected"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_client_connected</th></tr>
<tr><th>概要</th><td>クライアントと接続されているかを調べる.</td></tr>
<tr><th>カテゴリ</th><td>monitor</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_monitor_client_connected( int id )</b></td>
<tr><th>arg 1</Th><td>int id</td></tr>
<tr><th></th><td>対象のモニター設定のID
</td></tr>
<tr><th>返り値</th><td>接続されていたら1，接続さてていなければ0を返す
</td></tr>
<tr><th>詳細説明</th><td>クライアントと接続されているかを調べる.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_monitor_client_add">vce_monitor_client_add</a>
<a href="#vce_monitor_client_delete">vce_monitor_client_delete</a>
<a href="#vce_monitor_client_disconnect">vce_monitor_client_disconnect</a>
<a href="#vce_monitor_client_enable">vce_monitor_client_enable</a>
</td></tr>
</table><br><br>
<a name="vce_monitor_client_delete"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_client_delete</th></tr>
<tr><th>概要</th><td>モニタークライアントを解放する</td></tr>
<tr><th>カテゴリ</th><td>monitor</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_monitor_client_delete( monitor_ent_t *m )</b></td>
<tr><th>arg 1</Th><td>int id</td></tr>
<tr><th></th><td>対象のモニター設定のID
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>モニターエントリ構造体を削除し，これまでモニタリングしていた対象
を今後モニタリングしないようにする．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_monitor_client_add">vce_monitor_client_add</a>
<a href="#vce_monitor_client_enable">vce_monitor_client_enable</a>
</td></tr>
</table><br><br>
<a name="vce_monitor_client_disable"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_client_disable</th></tr>
<tr><th>概要</th><td>モニター用クライアントを停止し，資源を解放する</td></tr>
<tr><th>カテゴリ</th><td>monitor</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_monitor_client_disable(void)</b></td>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>vce_monitor_client_enable 関数によって初期化された
モニタークライアントを停止し解放する．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_monitor_client_enable">vce_monitor_client_enable</a>
</td></tr>
</table><br><br>
<a name="vce_monitor_client_disconnect"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_client_disconnect</th></tr>
<tr><th>概要</th><td>モニターエントリとの接続を閉じる.</td></tr>
<tr><th>カテゴリ</th><td>monitor</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_monitor_client_disconnect( int id )</b></td>
<tr><th>arg 1</Th><td>int id</td></tr>
<tr><th></th><td>対象のモニター設定のID
</td></tr>
<tr><th>返り値</th><td>追加に成功したらゼロ，失敗したら負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>モニタークライアント追加されているモニターエントリとの接続を閉じる.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_monitor_client_add">vce_monitor_client_add</a>
<a href="#vce_monitor_client_delete">vce_monitor_client_delete</a>
<a href="#vce_monitor_client_disconnect">vce_monitor_client_disconnect</a>
<a href="#vce_monitor_client_enable">vce_monitor_client_enable</a>
</td></tr>
</table><br><br>
<a name="vce_monitor_client_enable"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_client_enable</th></tr>
<tr><th>概要</th><td>モニター用クライアントを初期化し，有効にする</td></tr>
<tr><th>カテゴリ</th><td>monitor</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_monitor_client_enable( int maxmonitor )</b></td>
<tr><th>arg 1</Th><td>int maxmonitor</td></tr>
<tr><th></th><td>最大モニター数．
</td></tr>
<tr><th>返り値</th><td>成功したらゼロ，失敗したら負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>モニター用クライアントを初期化する．
初期化しただけでは何の通信も行なわない．
この関数を使って初期化をした後に，
vce_monitor_client_add 関数を使って接続先を指定して始めて
モニターされるリモートサーバに接続する．
モニターされるリモートサーバは，
vce_monitor_server_enable 関数によってあらかじめモニターできる
状態になっている必要がある．
モニター機能の詳細に関しては，
<a href="monitor.html">「VCEモニタリング」</a>
を参照．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_monitor_client_add">vce_monitor_client_add</a>
<a href="#vce_monitor_server_enable">vce_monitor_server_enable</a>
</td></tr>
</table><br><br>
<a name="vce_monitor_client_set_replywatcher"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_client_set_replywatcher</th></tr>
<tr><th>概要</th><td>モニター用クライアントに，サーバからの返答を処理する関数を設定する</td></tr>
<tr><th>カテゴリ</th><td>monitor</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_monitor_client_set_replywatcher( void (*w)(int id, int serial, int result, char*data,int len))</b></td>
<tr><th>arg 1</Th><td>void (*w)(int id, char*data, int len )</td></tr>
<tr><th></th><td>コールバック関数へのポインタ．
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>モニターしているプロセスからの返答に反応するための
コールバック関数を設定する．
このコールバック関数は，
モニターしているプロセスから何か文字列が返ってきたら，
それをそのまま引数に渡して呼びだされる．
返り値の文字列のフォーマットは，
<a href="monitor.html">「VCEモニタリング」</a>を参照．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_monitor_client_enable">vce_monitor_client_enable</a>
</td></tr>
</table><br><br>
<a name="vce_monitor_ent_init"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_ent_init</th></tr>
<tr><th>概要</th><td>モニタークライアントの設定情報構造体を初期化する</td></tr>
<tr><th>カテゴリ</th><td>monitor</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_monitor_ent_init( monitor_ent_t *m, int id, char *host, unsigned short port, char *pass )</b></td>
<tr><th>arg 1</Th><td>monitor_ent_t *m</td></tr>
<tr><th></th><td>設定対象となる構造体へのポインタ
</td></tr>
<tr><th>arg 2</Th><td>int id</td></tr>
<tr><th></th><td>設定のID番号
</td></tr>
<tr><th>arg 3</Th><td>char *host</td></tr>
<tr><th></th><td>モニターするホスト名
</td></tr>
<tr><th>arg 4</Th><td>unsigned short port</td></tr>
<tr><th></th><td>モニターするプロセスのモニターポート番号
</td></tr>
<tr><th>arg 5</Th><td>char *pass</td></tr>
<tr><th></th><td>モニターするプロセスのモニターキー
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>モニタークライアントに新しく接続先を追加するときに使う，
設定用構造体を初期化する．
単純に値を代入していくだけである．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_monitor_client_add">vce_monitor_client_add</a>
<a href="#vce_monitor_client_enable">vce_monitor_client_enable</a>
</td></tr>
</table><br><br>
<a name="vce_monitor_server_add_command"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_server_add_command</th></tr>
<tr><th>概要</th><td>モニター用サーバーにコマンドを追加する</td></tr>
<tr><th>カテゴリ</th><td>monitor</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_monitor_server_add_command( char* name, int argc, int (*callback)( conn_t _c, int argc, char **argv), char *desc )</b></td>
<tr><th>arg 1</Th><td>char *name</td></tr>
<tr><th></th><td>コマンドの名前
</td></tr>
<tr><th>arg 2</Th><td>int argc</td></tr>
<tr><th></th><td>コマンドの引数の数、インデックス0の引数にコマンド名が入るため、引数のないコマンドならば１を指定する.
-1の場合は、引数の数によるチェックを行わない.
</td></tr>
<tr><th>arg 3</Th><td> int (*callback)( conn_t _c, int argc, char **argv )</td></tr>
<tr><th></th><td>コマンドが呼ばれた際に使用する、コールバック関数を指定する.
</td></tr>
<tr><th>arg 4</Th><td> char *desc</td></tr>
<tr><th></th><td>コマンドを説明する文字列
</td></tr>
<tr><th>返り値</th><td>成功したらゼロ，失敗したら負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>モニタサーバーにコマンドを追加する.
各コマンドは、main関数のようなコールバック関数に関連づけられ、モニタクライアントからコマンドが呼ばれた際に、その関数をよびだすことで実現される.
基本的なコマンドは、vce_monitor_server_add_standard_commands()を呼ぶことでまとめて追加することができる.
また、基本的なコマンドのためのコールバック用の関数として、以下のものが用意されている。上記の関数を使わず個別に登録する場合には、この関数を利用する。
vce_monitor_command_ping,
vce_monitor_command_suicide,
vce_monitor_command_prof,
vce_monitor_command_netstat,
vce_monitor_command_netinfo,
vce_monitor_command_get_conn,
vce_monitor_command_get_pid,
vce_monitor_command_get_port
</td></tr>
</table><br><br>
<a name="vce_monitor_server_add_stantdard_commands"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_server_add_stantdard_commands</th></tr>
<tr><th>概要</th><td>標準モニタコマンドを追加する</td></tr>
<tr><th>カテゴリ</th><td>monitor</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_monitor_server_add_standard_commands()</b></td>
<tr><th>返り値</th><td>成功したらゼロ，失敗したら負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>基本的なコマンド(netstat、netinfo、ping、suicide、prof、get_conn、get_port、get_pid) を追加する.
これらのコマンドが標準で追加されないのは、
セキュリティ上これらのコマンドを組み込みたくない場合があるかもしれないからである。
その場合は、必要なコマンドだけ個別に追加していく。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_monitor_server_add_command">vce_monitor_server_add_command</a>
</td></tr>
</table><br><br>
<a name="vce_monitor_server_disable"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_server_disable</th></tr>
<tr><th>概要</th><td>モニター用サーバを無効にする</td></tr>
<tr><th>カテゴリ</th><td>monitor</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_monitor_server_disable(void)</b></td>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>モニター用サーバーを停止し，メモリを解放する．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_monitor_server_enable">vce_monitor_server_enable</a>
</td></tr>
</table><br><br>
<a name="vce_monitor_server_enable"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_server_enable</th></tr>
<tr><th>概要</th><td>モニター用サーバーを有効にする</td></tr>
<tr><th>カテゴリ</th><td>monitor</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_monitor_server_enable( int listen_port, int maxcon, char *key )</b></td>
<tr><th>arg 1</Th><td>int listen_port</td></tr>
<tr><th></th><td>待ちうけポート番号を指定する．
0を指定するとデフォルトポート番号の9099になる．
</td></tr>
<tr><th>arg 2</Th><td>int maxcon</td></tr>
<tr><th></th><td>最大の監視クライアント数
</td></tr>
<tr><th>arg 3</Th><td>char *key</td></tr>
<tr><th></th><td>アクセス制限用パスワード文字列
</td></tr>
<tr><th>返り値</th><td>成功したらゼロ，失敗したら負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>リモートモニタリング用プロトコルの待ちうけを有効にする．
この関数を呼びだすことによって，
リモートからプロセスを監視することが可能になる．
リモートからプロセスを監視するには，
本関数で初期化するモニタリング用サーバと対になる，
モニタリング用クライアントを用いると簡単である．
モニタリング用プロトコルは，
内部で RIJNDAEL ブロック暗号を16バイトの鍵長で使用して，
デコードされたデータをtext パーサを用いてコールバック関数を呼びだす．
そして文字列のコマンドラインを用いてコマンドを発行する．
VCE に付属の swp もこの関数を使ってリモートメンテナンスできるように
なっている．したがって swp をリモートメンテナンスするための
プログラムである swpadm はモニター用クライアントを使用している．
ゲームサーバーにリモートモニター機能をつけたい場合などは，
一連のモニタリングルーチンを使用すると便利である．
モニタールーチンに関する詳細は，
<a href="monitor.html">「VCEモニタリング」</a>を参照．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_monitor_client_enable">vce_monitor_client_enable</a>
</td></tr>
</table><br><br>
<a name="vce_monitor_server_reply"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_server_reply</th></tr>
<tr><th>概要</th><td>モニタプロトコル用の返信を行う</td></tr>
<tr><th>カテゴリ</th><td>monitor</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_monitor_server_reply( conn_t _c, int result, char *output )</b></td>
<tr><th>arg 1</Th><td>conn_t _c</td></tr>
<tr><th></th><td>返信するコネクション
</td></tr>
<tr><th>arg 2</Th><td>int result</td></tr>
<tr><th></th><td>返り値の値(負の値の場合は、エラーコード)
</td></tr>
<tr><th>arg 3</Th><td> char *output</td></tr>
<tr><th></th><td>返信する文字列
</td></tr>
<tr><th>返り値</th><td>成功したらゼロ，失敗したら負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>コマンドに対する返答を返すのに利用する。
</td></tr>
</table><br><br>
<a name="vce_profiler_cleanup"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_profiler_cleanup</th></tr>
<tr><th>概要</th><td>プロファイラを解放する</td></tr>
<tr><th>カテゴリ</th><td>profiler</td></tr>
<tr><th>対応OS</th><td>linux,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_profiler_cleanup( void )</b></td>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>VCE のプロファイラが使っているメモリをすべて解放する．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_profiler_init">vce_profiler_init</a>
</td></tr>
</table><br><br>
<a name="vce_profiler_in"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_profiler_in</th></tr>
<tr><th>概要</th><td>コードのある部分のプロファイリングを開始する(タイマー起動)</td></tr>
<tr><th>カテゴリ</th><td>profiler</td></tr>
<tr><th>対応OS</th><td>linux,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_profiler_in( char *tag )</b></td>
<tr><th>arg 1</Th><td>char *tag</td></tr>
<tr><th></th><td>タグ名を格納したバッファの先頭アドレス
</td></tr>
<tr><th>返り値</th><td>成功したらゼロを返す．失敗したら負のエラーコードを返す．
</td></tr>
<tr><th>詳細説明</th><td>タグを指定してタイマーを起動する．
本関数で開始したタイマーは，vce_profiler_out 関数を使って終了させることを
忘れるといつまでの開始したままになってしまう．
タイマーを開始したまま再び開始しようとすると，
エラー(VCE_EALREADY)が返される．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_profiler_init">vce_profiler_init</a>
<a href="#vce_profiler_out">vce_profiler_out</a>
</td></tr>
</table><br><br>
<a name="vce_profiler_init"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_profiler_init</th></tr>
<tr><th>概要</th><td>gettimeofday を使ったプロファイラ</td></tr>
<tr><th>カテゴリ</th><td>profiler</td></tr>
<tr><th>対応OS</th><td>linux,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_profiler_init( int max_tags )</b></td>
<tr><th>arg 1</Th><td>int max_tags</td></tr>
<tr><th></th><td>タグの最大数
</td></tr>
<tr><th>返り値</th><td>初期化に成功したらゼロ，失敗したら負のエラーコード
</td></tr>
<tr><th>詳細説明</th><td>VCE ではgettimeofday を使って，
数十マイクロ秒の精度をもつプロファイリングを行なうことができるが，
本関数はプロファイラの初期化を行なう．
max_tags 引数を用いて，最大でいくつの時間計測を行なうかを決定する．
これはvce_profiler_[in|out] 関数で指定するタグの種類数の事である．
VCE プロファイラは vce_profiler_init するときに，配列エンジンと
検索エンジンを1個づつ必要とするため， vce_initialize_limited 関数
を使っている場合は注意が必要である．
<BR><BR>
VCE のプロファイラは「タグ」を使って動作する，
アプリケーションレベルの実行時間計測を実装している．
つまり，vce_profiler_in 関数を使ってタイマーを起動し，
vce_profiler_out 関数で終了する．
双方の関数ではおなじ「タグ」文字列を指定し，
組となって動作する．したがって，複数の return を持つようなルーチン
を profile するには，注意が必要である．
また，各タグは独立しているので，
同時に複数のプロファイルをすることも可能である．
<BR><BR>
VCE にこのようなプロファイリング機構を導入している理由は，
<ul>
<LI>動的に値をリセットしたり，取りだしたりする機能が標準の
プロファイラに存在しない
<LI>標準のプロファイリングは移植性に乏しい
</ul>
といったような事がある．
</td></tr>
<tr><th>使用例</th><td><pre>
  int main(){
  vce_profiler_init(100);
  subroutine();
  }
  void subroutine()
  {
      vce_profiler_in( "subroutine"); // ここでタイマー開始
      if( ... ){
          vce_profiler_out( "subroutine" ); // ここでもout必要
          return;
      }
      vce_profiler_out( "subroutine"); // ここでもout必要
      return;
  }
</pre>  
</td></tr>
<tr><th>知られているバグやTODO</th><td>vce_profiler_[in|out] 関数でgettimeofdayを直接使用しているが，
おそらくこれによって標準のプロファイリングよりも若干遅くなる．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_initialize_limited">vce_initialize_limited</a>
<a href="#vce_profiler_cleanup">vce_profiler_cleanup</a>
<a href="#vce_profiler_in">vce_profiler_in</a>
<a href="#vce_profiler_out">vce_profiler_out</a>
</td></tr>
</table><br><br>
<a name="vce_profiler_out"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_profiler_out</th></tr>
<tr><th>概要</th><td>vce_profiler_in で起動したタイマーを止める</td></tr>
<tr><th>カテゴリ</th><td>profiler</td></tr>
<tr><th>対応OS</th><td></td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_profiler_out( char *tag )</b></td>
<tr><th>arg 1</Th><td>char *tag</td></tr>
<tr><th></th><td>タグ名を格納したバッファの先頭アドレス
</td></tr>
<tr><th>返り値</th><td>エラーの場合は負のエラーコード，
成功したらゼロ
</td></tr>
<tr><th>詳細説明</th><td>vce_profiler_in で指定したタグと同じタグを指定して，
タイマーを停止させる．
タイマーの計測結果は，プロファイラの中に蓄積され，
回数や平均時間などが再計算される．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_profiler_in">vce_profiler_in</a>
<a href="#vce_profiler_init">vce_profiler_init</a>
</td></tr>
</table><br><br>
<a name="vce_profiler_save_stats"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_profiler_save_stats</th></tr>
<tr><th>概要</th><td>VCEプロファイラの状態をファイルに出力する</td></tr>
<tr><th>カテゴリ</th><td>profiler</td></tr>
<tr><th>対応OS</th><td>linux,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_profiler_save_stats( char *path )</b></td>
<tr><th>arg 1</Th><td>char *path</td></tr>
<tr><th></th><td>ファイルのパス名
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>VCE の vce_read_simple_config_file 関数が認識するフォーマットと同じ
フォーマットを使って，現在の状態を出力する．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_profiler_init">vce_profiler_init</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_acceptwatcher_deny"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_acceptwatcher_deny</th></tr>
<tr><th>概要</th><td>すべてのコネクションを拒否するTCP(conn_t)のaccept監視関数</td></tr>
<tr><th>カテゴリ</th><td>watcher</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_protocol_acceptwatcher_deny( conn_t c )</b></td>
<tr><th>arg 1</Th><td>conn_t c</td></tr>
<tr><th></th><td>サーバの tcpcontext が新規に accept した(受けいれた)コネクションを
あらわす conn_t
</td></tr>
<tr><th>返り値</th><td>この関数は常に-1を返す。
</td></tr>
<tr><th>詳細説明</th><td>この関数は vce_tcpcontext_create の引数に指定される。
この関数を指定すると、すべてのコネクションを拒否するため
クライアントが接続できなくなる。
したがってデバッグ用と言える。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_acceptwatcher_noop">vce_protocol_acceptwatcher_noop</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_acceptwatcher_noop"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_acceptwatcher_noop</th></tr>
<tr><th>概要</th><td>すべてのコネクションを受けいれる TCP(conn_t)のaccept 監視関数</td></tr>
<tr><th>カテゴリ</th><td>watcher</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_protocol_acceptwatcher_noop( conn_t c )</b></td>
<tr><th>arg 1</Th><td>conn_t c</td></tr>
<tr><th></th><td>サーバの tcpcontext が新規に accept した(受けいれた)コネクションを
あらわす conn_t
</td></tr>
<tr><th>返り値</th><td>この関数は常に0を返すので、すべてのコネクションを受けいれる。
</td></tr>
<tr><th>詳細説明</th><td>この関数は vce_tcpcontext_create の引数に指定される。
0を返すとデフォルトの動作と同じであるため、
NULL を指定したのと同じことになる。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_acceptwatcher_deny">vce_protocol_acceptwatcher_deny</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_acceptwatcher_vec0"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_acceptwatcher_vec0</th></tr>
<tr><th>概要</th><td>パケットベクトライザがaccept()したときのデフォルトコールバック関数</td></tr>
<tr><th>カテゴリ</th><td>watcher</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_protocol_acceptwatcher_vec0( conn_t ct )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>新規にacceptされたコネクションをあらわす conn_t
</td></tr>
<tr><th>返り値</th><td>うまくいったら0、失敗したら負のエラーコードをかえす。
</td></tr>
<tr><th>詳細説明</th><td>本関数は通常、アプリケーションから直接使われることはない。
VCEに付属の"swp"において、クライアントからの接続要求を
accept()関数によって受けいれたときに、その事実をサーバに伝えるために
使用される。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_closewatcher_noop"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_closewatcher_noop</th></tr>
<tr><th>概要</th><td>何もしない、コネクション close 監視関数</td></tr>
<tr><th>カテゴリ</th><td>watcher</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_protocol_closewatcher_noop( conn_t c )</b></td>
<tr><th>arg 1</Th><td>conn_t c</td></tr>
<tr><th></th><td>閉じられようとしているコネクション(閉じる直前)
</td></tr>
<tr><th>返り値</th><td>この関数は常に0を返す。
</td></tr>
<tr><th>詳細説明</th><td>vce_tcpcontext_create の引数に指定される close監視関数のひとつである。
実際には何の処理もしないため、NULL を指定するのと同じ結果になる。
ただし、
明示的に指定することによって、プログラムソースが読みやすくなるという利点が
ある。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_closewatcher_vec0"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_closewatcher_vec0</th></tr>
<tr><th>概要</th><td>パケットベクトライザがEOFを検出したときに呼ばれるコールバック関数</td></tr>
<tr><th>カテゴリ</th><td>watcher</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_protocol_closewatcher_vec0( conn_t ct )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>EOFが検出されたコネクションをあらわすconn_t
</td></tr>
<tr><th>返り値</th><td>正常に終了したら0、失敗したら負のエラーコード
</td></tr>
<tr><th>詳細説明</th><td>本関数は通常はアプリケーションから直接呼びだされることはない。
VCEに付属の "swp" プログラムにおいて、クライアントとの接続にEOFを検出
したときにその事実をサーバに送信するために使用される。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_parser_bin16"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_parser_bin16</th></tr>
<tr><th>概要</th><td>bin16 プロトコルのレコードを取りだしてコールバック関数を呼びだす</td></tr>
<tr><th>カテゴリ</th><td>parser</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_protocol_parser_bin16( conn_t c )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>レコードがきているかどうか検査する対象のコネクション構造体。
</td></tr>
<tr><th>返り値</th><td>データがまだ足りない場合は0、レコードがみつかってコールバックを
呼びだせたら、コールバックの返り値をそのまま返す。
</td></tr>
<tr><th>詳細説明</th><td>vce_protocol_parser_bin16 関数は、conn_t (circ_tではない) 用の
レコード検出関数である。
bin16 と呼ばれるプロトコルのレコードを取りだす。
レコードを検出するたびに、
vce_tcpcontext_create 関数の呼びだし時に指定しているコールバック関数を
呼びだす。
VCEのアプリケーションにおいては、アプリケーションの特性上、
<B>小さいパケットを多く処理する</b>ことが多いので，
bin16プロトコルを使うことが多くなるだろう．
<BR><BR>
<B>bin16プロトコルの内容</B><BR>
bin16プロトコルを使う場合、
ソケットを流れる1レコードは以下のようなフォーマットになっている。
C言語風に書けば以下のようなコードになる．
<pre>
struct packet
{
unsigned short content_length;
char buf[content_length];
}
</pre>
となる。つまり10バイトのデータを送ると、(10 + sizeof(unsigned short)) で
12バイトのデータが送信されることになる。
<BR><BR>
<B>コールバック関数の定義</B><BR>
コールバック関数の定義は
<pre>
int callback( conn_t *c, char *data, int len )
</pre>
である。<code>char *data</code>にレコードの内容
<code>buf[content_length]</code>
へのポインタが、<code>int len</code>
に <code>content_length </code>が代入される。
<code>conn_t *c </code>には、入力元を特定できるコネクションが代入される。
<BR><BR>

</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_parser_bin32">vce_protocol_parser_bin32</a>
<a href="#vce_protocol_parser_text">vce_protocol_parser_text</a>
<a href="#vce_protocol_unparser_bin16">vce_protocol_unparser_bin16</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_vecprotocol_parser_bin16">vce_vecprotocol_parser_bin16</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_parser_bin32"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_parser_bin32</th></tr>
<tr><th>概要</th><td>bin32プロトコルのレコードを取りだしてコールバック関数を呼びだす</td></tr>
<tr><th>カテゴリ</th><td>parser</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_protocol_parser_bin32( conn_t c )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>レコード検査をする対象となるコネクション構造体(conn_t)
</td></tr>
<tr><th>返り値</th><td>データがまだ足りない場合は0、レコードがみつかってコールバックを呼びだせ
たら、コールバックの返り値をそのまま返す。
</td></tr>
<tr><th>詳細説明</th><td>本関数は、 conn_t 用のレコード検出関数であり、32ビットまでのレコード長に
対応している。実際にはそれほど長いデータレコードを使用することは
性能上問題の原因にしかならないので、
BIN32DATA_MAX までの長さしか検出できない。
それより長いレコードが入力されようとした場合、
それはサーバーに対するクラッキング行為であるとして
プロトコルエラーを返す(VCEはその場合コネクションを切断する)
BIN32DATA_MAX は vce.h で定義されている。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_parser_bin16">vce_protocol_parser_bin16</a>
<a href="#vce_protocol_unparser_bin32">vce_protocol_unparser_bin32</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_parser_text"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_parser_text</th></tr>
<tr><th>概要</th><td>プロトコルを1行単位で取りだしてコールバック関数を呼びだす</td></tr>
<tr><th>カテゴリ</th><td>parser</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_protocol_parser_text( conn_t c )</b></td>
<tr><th>arg 1</Th><td>conn_t c</td></tr>
<tr><th></th><td>レコード取りだし対象となるコネクション
</td></tr>
<tr><th>返り値</th><td>データがまだ足りない場合は0、レコードがみつかってコールバックを
呼びだせたら、コールバックの返り値をそのまま返す。
</td></tr>
<tr><th>詳細説明</th><td>行単位のレコードをテキスト行解析により取りだす。
テキストプロトコルの場合は、暗号化をしない場合、tcpdump などのプログラム
により、
悪意がなくてもプロトコルの中身が解析されてしまうので注意が必要である。
改行のデリミタとなる文字列は "\n" と "\r\n" の2種である。
また、 コールバックに入力されるデータはヌル終端されている C 言語の文字列
* ではない * 。 そのため、 vce_makecstr 関数などを用いて、
C言語の文字列に変換する必要がある。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_parser_bin16">vce_protocol_parser_bin16</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_parser_through"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_parser_through</th></tr>
<tr><th>概要</th><td>レコード境界を切らずにコールバックを呼びだすプロトコルパーサ</td></tr>
<tr><th>カテゴリ</th><td>parser</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_protocol_parser_through( conn_t ct )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>データを受けとるTCPコネクション(conn_t)
</td></tr>
<tr><th>返り値</th><td>コールバック関数の返り値をそのまま返す。
したがって、コールバック関数が負の値を返した場合はVCEによって自動的に
接続が切断される。
</td></tr>
<tr><th>詳細説明</th><td>各種プロトコルの中には、
レコードという考えかたがないものもある。
そのようなプロトコルのために、データ処理を一切せずに、
ソケットからの入力データをそのままコールバック関数に渡すパーサが必要である。
vce_protocol_parser_through はまさにそのために使用される。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_parser_bin16">vce_protocol_parser_bin16</a>
<a href="#vce_protocol_unparser_through">vce_protocol_unparser_through</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_parser_vec0"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_parser_vec0</th></tr>
<tr><th>概要</th><td>パケットベクトライザがクライアントからのデータを受けるためのパーザ</td></tr>
<tr><th>カテゴリ</th><td>parser</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_protocol_parser_vec0( conn_t ct )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>パーズ対象となるTCPコネクションをあらわす conn_t
</td></tr>
<tr><th>返り値</th><td>成功したら0、失敗したら負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>指定されたconn_t コネクションに入力されているデータをベクトライズして、
ベクトライズに対応しているサーバにつながっているソケットに対して書きこむ。
通常アプリケーションは、VCEに附属している汎用のパケットベクトライザ swp
を使用するため、この関数を直接使うことはない。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vp">vp</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_parser_vecmain_client"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_parser_vecmain_client</th></tr>
<tr><th>概要</th><td>パケットベクトライザがサーバからのデータを処理するためのパーザ</td></tr>
<tr><th>カテゴリ</th><td>parser</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_protocol_parser_vecmain_client( conn_t ct )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>処理対象のコネクション
</td></tr>
<tr><th>返り値</th><td>成功なら0、失敗なら負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>本関数は通常アプリケーションから使われることはなく、
VCE に添付の "swp" プログラムから呼びだされる。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_parser_vecmain_server"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_parser_vecmain_server</th></tr>
<tr><th>概要</th><td>パケットベクトライズ対応サーバのデータ受信用パーサ</td></tr>
<tr><th>カテゴリ</th><td>parser</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_protocol_parser_vecmain_server( conn_t ct )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>パース対象となるTCPコネクション
</td></tr>
<tr><th>返り値</th><td>成功したら0、失敗したら負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>vce_protocol_parser_vecmain_server は、
vce_tcpcontext_create 関数の呼びだし時に、
パーサとして登録される。
この関数を登録することで， "swp" 中継を使ったバックエンドを実装
することができる．

本関数は、コネクションからのデータ入力をみて、
その中身を解析し、仮想回路(circ_t)の情報を取りだす。
取りだした結果仮想回路にデータが来ているようであれば、
ベクトライズ用bin16パーサなどのパーサを呼びだす。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_pcallback_dump"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_pcallback_dump</th></tr>
<tr><th>概要</th><td>普通のTCPコネクション用の、データをダンプするコールバック</td></tr>
<tr><th>カテゴリ</th><td>pcallback</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_protocol_pcallback_dump( conn_t ct, char *data, int len )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>入出力対象となるTCPコネクション。仮想回路(circ_t)ではない。
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>入力データへの先頭アドレス
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>入力データの長さ(バイト数)
</td></tr>
<tr><th>返り値</th><td>送信しないので常に0を返す
</td></tr>
<tr><th>詳細説明</th><td>conn_tに入力されたデータをすべて vce_dump_buffer 関数を使って
ダンプする。アプリケーションのデバッグ用に作られた関数である。
<BR>
この関数は「プロトコルコールバック関数」である．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_pcallback_echo_bin16">vce_protocol_pcallback_echo_bin16</a>
<a href="#vce_protocol_pcallback_noop">vce_protocol_pcallback_noop</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_pcallback_echo_bin16"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_pcallback_echo_bin16</th></tr>
<tr><th>概要</th><td>conn_t上のbin16プロトコル用の、エコー・コールバック関数</td></tr>
<tr><th>カテゴリ</th><td>pcallback</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_protocol_pcallback_echo_bin16( conn_t ct, char *data, int len )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>エコーする対象となるコネクション。仮想回路(circ_t)ではない。
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>受信データの先頭アドレス
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>受信データの長さ(バイト数)
</td></tr>
<tr><th>返り値</th><td>入出力に失敗すると負のエラーコード(vce.h)を、成功すると
送信バイト数を返す。
</td></tr>
<tr><th>詳細説明</th><td>vce_tcpcontext_set_conn_parser 関数の呼びだし時に指定する，
プロトコルコールバック関数である。

本関数は、デフォルトでVCEに附属している
コールバック関数で、入力された文字列を単純に出力にエコーバックする。

本関数を使うためには、 vce_tcpcontext_set_conn_parser の呼びだし時に、
vce_protocol_parser_bin16 関数をプロトコルパーサとして登録しておく
必要がある。<BR>

実際のアプリケーションにおいては、独自のコールバック関数を
定義してクライアントからの入力を処理するが、本関数はテストのために
使用することができる。<BR>
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_pcallback_dump">vce_protocol_pcallback_dump</a>
<a href="#vce_protocol_pcallback_noop">vce_protocol_pcallback_noop</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_vecprotocol_pcallback_echo_bin16">vce_vecprotocol_pcallback_echo_bin16</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_pcallback_echo_text"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_pcallback_echo_text</th></tr>
<tr><th>概要</th><td>conn_t 上の行指向テキストプロトコル用のエコーコールバック関数</td></tr>
<tr><th>カテゴリ</th><td>pcallback</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_protocol_pcallback_echo_text(conn_t ct, char *data, int len )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>入力を受けるコネクション
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>入力データの先頭アドレス
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>入力データの長さ
</td></tr>
<tr><th>返り値</th><td>入出力に失敗すると負のエラーコード、成功すると送信バイト数を返す
</td></tr>
<tr><th>詳細説明</th><td>入力をそのまま出力にコピーして text プロトコルで書きだす。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_pcallback_echo_bin16">vce_protocol_pcallback_echo_bin16</a>
<a href="#vce_protocol_unparser_text">vce_protocol_unparser_text</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_pcallback_noop"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_pcallback_noop</th></tr>
<tr><th>概要</th><td>普通のTCPコネクション用の、何もしないプロトコルコールバック関数</td></tr>
<tr><th>カテゴリ</th><td>pcallback</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_protocol_pcallback_noop( conn_t ct ,char *data , int len )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>入出力対象となるコネクション。仮想回路(circ_t)ではない。
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>入力データの先頭アドレス
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>入力データの長さ(バイト数)
</td></tr>
<tr><th>返り値</th><td>送信しないので常に0を返す
</td></tr>
<tr><th>詳細説明</th><td>本関数は vce_tcpcontext_set_conn_parser の呼びだし時に指定する
プロトコルコールバック関数である．
本関数は単にデータを捨てて何もしない．
<BR>
アプリケーションは実際には本関数を使用することはなく、
独自のプロトコルコールバック関数を定義して入力データの処理をすることになる。
サーバーを一時的に「殺す」ために使える．
<BR>
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_pcallback_dump">vce_protocol_pcallback_dump</a>
<a href="#vce_protocol_pcallback_echo_bin16">vce_protocol_pcallback_echo_bin16</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_unparser_bin16"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_unparser_bin16</th></tr>
<tr><th>概要</th><td>bin16 プロトコルのレコードを、コネクションに対して書きこむ</td></tr>
<tr><th>カテゴリ</th><td>parser</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_protocol_unparser_bin16( conn_t ct, char *data , int len  )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>書きこみ対象のコネクション
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>処理すべきデータへのポインタ
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>処理すべきデータの長さ
</td></tr>
<tr><th>返り値</th><td>成功したら書きこめたバイト数を返し、
失敗したら負のエラーコードを返す。
レコードに必要な情報を同時に送信するので、書きこめたバイト数は、
書きこもうとしたバイト数より2バイト多い。
レコードの内容については、 vce_protocol_parser_bin16 を参照。
</td></tr>
<tr><th>詳細説明</th><td>本関数は、 conn_t に対して，
bin16プロトコルのレコードを送りだすためのフォーマッタ関数である．
つまり，データに常に2バイトのヘッダをくっつけて書きだす．
<B>送信バイト数</B><BR><BR>
bin16プロトコルは、All or Nothing な送信をする。つまり、
20バイト送ろうとして、送信バッファに残り10バイトしかなかったので
10バイトしか送れなかったということはなく、負のエラーコードか22か、
どちらかの返り値しかない。
これは、不完全なレコードを送ることをしない、
というVCEのポリシーの現れである。
</td></tr>
<tr><th>使用例</th><td>  // エコーサーバを実装するコールバック関数の例
  int callback( conn_t ct, char *data, int len )
  {
      return vce_protocol_unparser_bin16( ct,data,len );
  }
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_parser_bin16">vce_protocol_parser_bin16</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_unparser_bin32"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_unparser_bin32</th></tr>
<tr><th>概要</th><td>BIN32プロトコルのレコードをひとつ、コネクション(conn_t)に書きこむ</td></tr>
<tr><th>カテゴリ</th><td>parser</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_protocol_unparser_bin32( conn_t ct, char *data, int len )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>書きこみ対象のコネクション
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>書きこむデータレコードの内容をさすポインタ
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>書きこむデータレコードの長さ(バイト)
</td></tr>
<tr><th>返り値</th><td>成功したら書きこめたバイト数を返し、
失敗したら負のエラーコードを返す。
レコードに必要な情報を同時に送信するので、書きこめたバイト数は、
書きこもうとしたバイト数より4バイト多い。
</td></tr>
<tr><th>詳細説明</th><td>BIN32プロトコルは、BIN16の限界である64キロバイトより大きいデータレコードを
送りたいときに使用されるアンパーサである。
BIN32によって大きいデータを送信できるが、定数 BIN32DATA_MAX で規定されている
データ長よりも長いデータは送信できない。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_parser_bin32">vce_protocol_parser_bin32</a>
<a href="#vce_protocol_unparser_bin16">vce_protocol_unparser_bin16</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_unparser_text"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_unparser_text</th></tr>
<tr><th>概要</th><td>テキストプロトコルのレコード(1行)をコネクションに書きこむ</td></tr>
<tr><th>カテゴリ</th><td>parser</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_protocol_unparser_text( conn_t ct, char *data, int len )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>書きこむ対象となるコネクション
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>書きこむデータへのポインタ
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>書きこむデータの長さ
</td></tr>
<tr><th>返り値</th><td>成功したらデータの長さプラス1，失敗したら負のエラーコード．
</td></tr>
<tr><th>詳細説明</th><td>改行記号である"\n" や "\r"もエスケープなどの処理を一切せずに
そのまま書きこむので注意が必要である。
また、データの末尾に "\n" を追加して送信するので、
送信バイト数は、成功の場合 len よりも1多い値となる。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_unparser_bin16">vce_protocol_unparser_bin16</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_unparser_through"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_unparser_through</th></tr>
<tr><th>概要</th><td>TCPコネクションにデータをそのまま書き出す</td></tr>
<tr><th>カテゴリ</th><td>parser</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_protocol_unparser_through( conn_t ct, char *data, int len)</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>データを出力するコネクション
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>出力するデータの先頭アドレス
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>出力するデータの長さ(バイト数)
</td></tr>
<tr><th>返り値</th><td>書きこめたデータの長さ。エラーの場合は負のエラーコード
</td></tr>
<tr><th>詳細説明</th><td>本関数は，何の処理もせずにデータをconn_tに書きこむ．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_parser_through">vce_protocol_parser_through</a>
<a href="#vce_protocol_unparser_bin16">vce_protocol_unparser_bin16</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_read_plain_text_file"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_read_plain_text_file</th></tr>
<tr><th>概要</th><td>プレインテキストファイルを読みこむ</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_read_plain_text_file( const char *filename, int (*callback)(char*,in,char*))</b></td>
<tr><th>arg 1</Th><td>char *filename</td></tr>
<tr><th></th><td>読みこむファイル名
</td></tr>
<tr><th>arg 2</Th><td>int (*callback) (char *filename,int lineno,char *line )</td></tr>
<tr><th></th><td>引数処理のためのコールバック関数
</td></tr>
<tr><th>返り値</th><td>ファイルが読みこめない場合 VCE_EACCESSFILE を返す。
成功したら0を返す。またコールバック関数が負を返したら、
その値をそのまま返す。
</td></tr>
<tr><th>詳細説明</th><td>入力テキストファイルの各行を読みこむごとにコールバック関数を呼びだし、
実際の入力データの処理はそのコールバック関数で実行する。
本関数は行番号などデバッグに役立つ情報を付加してコールバック関数を呼びだし、
コールバック関数が負を返したら処理を中断する。
vce_read_simple_config_file 関数をさらに単純にしたものである。
なお、空行は読みとばされる。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_read_simple_config_file">vce_read_simple_config_file</a>
</td></tr>
</table><br><br>
<a name="vce_read_simple_config_file"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_read_simple_config_file</th></tr>
<tr><th>概要</th><td>単純なテキスト設定ファイルをコールバック関数を使って読みこむ</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_read_simple_config_file( const char *filename, int ( *callback ) ( char *,int,char *,char *) )</b></td>
<tr><th>arg 1</Th><td>char *filename</td></tr>
<tr><th></th><td>読みこむファイル名
</td></tr>
<tr><th>arg 2</Th><td>int (*callback) (char *filename,int lineno,char *param, char *value)</td></tr>
<tr><th></th><td>ファイルの中身を処理するためのコールバック関数
</td></tr>
<tr><th>返り値</th><td>ファイルが読みこめない場合 VCE_EACCESSFILE を返す。
成功したら0を返す。またコールバック関数が負を返したら、
その値をそのまま返す。
</td></tr>
<tr><th>詳細説明</th><td>vce_read_simple_config_file は入力ファイルを1行づつ読みこみ、
各行に
<pre>
PARAMNAME=VALUE
</pre>
という形式(イコール'='でパラメータと値を並べたもの)を発見するごとに
指定されたコールバック関数を呼びだす。
イコールの前後では空白文字は存在できない．
またPARAMNAME は必ず行頭からはじまらなければならない．
文字列のエスケープには対応していないので，
改行をデータ中に入れることはできない．
コールバック関数のプロトタイプは
<pre>
int (*callback)(char *filename, int lineno, char *param, char *value )
</pre>
であり、 filename は設定ファイル名、 lineno は入力ファイルの中の行番号、
char *param はパラメータ名、 char *value は設定値である。
value に改行記号は含まれない。
また、 "\r\n" で終わる行も "\n" で終わる行も同じように読みこむことができる。
<BR>
1行の長さを最大32キロバイトと仮定している。
それを越える長さの行があった場合は、
越える分については読みこまれない。
また、コールバック関数が負を返すと、
本関数も負を返す。返り値は、コールバック関数が返した値と同じである。
本関数は，標準入出力(stdioのFILE構造体)をそのまま使用するので，
標準入出力が使用できない環境では動作しない．
</td></tr>
<tr><th>See also</th><td>
<a href="#swp">swp</a>
<a href="#vce_copy_cstring_upto">vce_copy_cstring_upto</a>
<a href="#vp">vp</a>
</td></tr>
</table><br><br>
<a name="vce_replace_malloc_funcs"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_replace_malloc_funcs</th></tr>
<tr><th>概要</th><td>VCE が使うmalloc関数を置きかえる</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_replace_malloc_funcs( void*(*a)(size_t), void*(*r)(void*,size_t), void(*f)(void*))</b></td>
<tr><th>arg 1</Th><td>void * (*a)(size_t)</td></tr>
<tr><th></th><td>メモリ割りあて関数へのポインタ。NULLを指定すると置きかえない。
</td></tr>
<tr><th>arg 2</Th><td>void*(*a)(void*,size_t)</td></tr>
<tr><th></th><td>メモリ再割りあて関数へのポインタ。NULLを指定すると置きかえない。
</td></tr>
<tr><th>arg 3</Th><td>void (*f)(void*)</td></tr>
<tr><th></th><td>メモリ解放関数へのポインタ。NULLを指定すると置きかえない。
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>VCEがメモリ割りあて/解放に使う関数を置きかえる。
アプリケーションによっては、メモリ管理を一元化したい場合や、
メモリ関係の性能監視のために malloc/free 関数を再定義したい場合がある。
本関数ではそのような場合に関数ポインタを指定することで
置きかえることができる。
デフォルトでは、 割りあて関数は malloc, 解放関数は free となっている。
本関数は、 vce_initialize 関数より前に呼びだすことが可能である。
</td></tr>
</table><br><br>
<a name="vce_save_statlog"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_save_statlog</th></tr>
<tr><th>概要</th><td></td></tr>
<tr><th>カテゴリ</th><td>log</td></tr>
<tr><th>対応OS</th><td>linux,win32,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_save_statlog( char *path )</b></td>
<tr><th>arg 1</Th><td>char *path</td></tr>
<tr><th></th><td>ログを出力するファイルのパス
</td></tr>
<tr><th>返り値</th><td>正常に終了したら0を、異常終了したら負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>VCEの動作状況を統計したテキストファイルを出力する。
VCEがチューニングモードで動作しているときは、
精密な時間計測の結果も出力される(Version 1.0で対応)。
</td></tr>
</table><br><br>
<a name="vce_scandir"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_scandir</th></tr>
<tr><th>概要</th><td>UNIXのディレクトリをスキャンする。  拡張子を指定できる。</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_scandir( char *path, char *suf, int (*callback)(char *path) );</b></td>
<tr><th>arg 1</Th><td>char *path</td></tr>
<tr><th></th><td>ディレクトリのパス
</td></tr>
<tr><th>arg 2</Th><td>char *suf</td></tr>
<tr><th></th><td>拡張子。この拡張子をもつファイルだけをスキャンする。
ただし "" を指定するとすべてのファイルをスキャンする。
ディレクトリも含む。ドットを含むこと。例： ".bmp"
</td></tr>
<tr><th>arg 3</Th><td>int (*callback)(char *path)</td></tr>
<tr><th></th><td>1個ファイルをみつけるごとにこのコールバック関数を呼びだす。
</td></tr>
<tr><th>返り値</th><td>ディレクトリがみつからないなどエラーの場合は負のエラーコード。
正常な場合は、ゼロを返す．
</td></tr>
<tr><th>詳細説明</th><td>ディレクトリをスキャンして、コールバック関数を呼びだす。
ディレクトリの中のすべてのファイルを検索して読みこむ場合などに
使用できる。現在は移植性の高いディレクトリ操作がないため、
windows環境では本関数は使用できない。
また、再帰的な読みこみは行なわない。
callback関数の引数 path には、ファイルのディレクトリ名を含むパス名が入る。
callback 関数が負を返すと、その場で終了し、返された値をそのまま本関数の
返り値として返す。callback が0以上を返せば処理は継続される。
</td></tr>
</table><br><br>
<a name="vce_set_heartbeat_wait_flag"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_set_heartbeat_wait_flag</th></tr>
<tr><th>概要</th><td>vce_heartbeat の sleep時間 調節機構をon/off する</td></tr>
<tr><th>カテゴリ</th><td>core</td></tr>
<tr><th>対応OS</th><td></td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_set_heartbeat_wait_flag( int flag )</b></td>
<tr><th>arg 1</Th><td>int flag</td></tr>
<tr><th></th><td>0なら調節機構を off,1 なら on になる。
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>vce_heartbeat の sleep 時間調整機構を操作する。
flag に1を設定すると、vce_heartbeat は、
最高100ミリ秒、
ネットワークからの入力がない場合 select で待つようになる。
デフォルトでこの機能は off である
(なぜなら、ちゃんとしたアプリケーションならその機構をアプリケーションの
側で持っていることが多いから)。
このループ速度調整機能は，最低速度を100ミリ秒としているが，
現在の実装では，実際には数十分かけてその速度に落ちつくことになる．
つまり，VCEは急激にループ速度を変更することはせず，
パケットを受けるとループ速度を2倍にし，
パケットを受けないと非常にゆっくりとしたペースで速度を落としていく．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_heartbeat">vce_heartbeat</a>
</td></tr>
</table><br><br>
<a name="vce_set_internal_timer"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_set_internal_timer</th></tr>
<tr><th>概要</th><td>VCE の内部タイマを更新する</td></tr>
<tr><th>カテゴリ</th><td></td></tr>
<tr><th>対応OS</th><td>other</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_set_internal_timer( time_t t, unsigned int microsec )</b></td>
<tr><th>arg 1</Th><td>time_t t</td></tr>
<tr><th></th><td>設定する時刻(秒)。
</td></tr>
<tr><th>arg 2</Th><td>unsigned int microsec</td></tr>
<tr><th></th><td>設定する時刻(マイクロ秒)．
0から999999の間を指定する．それより大きい値を指定すると，
(microsec mod 1000000) を値として採用する．
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>Windows, PS2 やその他組みこみ用の OS 上で動作する VCE では、
time() や gettimeofday() などUNIXライクな方法では
現在時刻を取得できない場合がある。
このようなシステムにおいて、正確な「秒」によるタイムアウトを実現
するためには、
アプリケーションが何らかの方法で時刻と等価な値
(1秒に1づつ増えれば数値の意味は問わない)を更新し続けるようにするのがよい。
本関数は、TCPコネクションのタイムアウトやログ出力に使われる VCE の
内部タイマを 1秒に1回(複数回でもよい)更新するための関数である。
linux,win32 環境ではこの関数を使用しても何も起こらず
VCE_ESUPPORT がセットされる。
</td></tr>
</table><br><br>
<a name="vce_set_mainloop_callback"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_set_mainloop_callback</th></tr>
<tr><th>概要</th><td>vce_mainloopから呼びだすコールバック関数を設定する。</td></tr>
<tr><th>カテゴリ</th><td>core</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_set_mainloop_callback( int (*f)(void) )</b></td>
<tr><th>arg 1</Th><td>int (*f)(void)</td></tr>
<tr><th></th><td>コールバック関数へのポインタ
</td></tr>
<tr><th>返り値</th><td>戻り値はない。常に成功する。
</td></tr>
<tr><th>詳細説明</th><td>vce_mainloopから定期的に呼びだされるコールバック関数。
vce_mainloopを呼びだすと通常永久ループに入るが、
vce_mainloopを利用しつつもアプリケーションで並行に処理をしたい場合は
この関数を使用する。VCEが通常の負荷の状態のときは、
約10ミリ秒に1回以上のタイミングで呼びだされることになる。
<BR>
また、コールバック関数が0以外を返すとvce_mainloopが終了する。
</td></tr>
<tr><th>使用例</th><td><pre>
  #include "vce.h"
  int callbk( void )
  {
      printf( "callback function is called.\n" );
  }
  int main( int argc, char **argv )
  {
      // 何らかのコード
      vce_set_mainloop_callback( callbk );
      vce_mainloop();
  }
</pre>
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_heartbeat">vce_heartbeat</a>
<a href="#vce_mainloop">vce_mainloop</a>
</td></tr>
</table><br><br>
<a name="vce_set_read_write_log_mode"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_set_read_write_log_mode</th></tr>
<tr><th>概要</th><td>VCEによるread/writeシステムコールの使用をログするかを設定する</td></tr>
<tr><th>カテゴリ</th><td>core</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_set_read_write_log_mode( int mode )</b></td>
<tr><th>arg 1</Th><td>int mode</td></tr>
<tr><th></th><td>1ならログする、0ならログしない。
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>ログ出力をするように設定すると、 vce_errout と同じストリームに対して、
何番(ディスクリプタ)のストリームに対して何バイト出力したかの値と、
実際のデータのダンプ(16進数)を出力する。
この出力はVCEのバージョンによって変化するかもしれないため、
あくまで人間が目視でデバッグするために使うのが望ましい。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_set_verbose_mode">vce_set_verbose_mode</a>
</td></tr>
</table><br><br>
<a name="vce_set_socket_library_ok"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_set_socket_library_ok</th></tr>
<tr><th>概要</th><td>VCE の下層の socket ライブラリが初期化できたことを VCE に通知する。</td></tr>
<tr><th>カテゴリ</th><td>core</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_set_socket_library_ok( int flag )</b></td>
<tr><th>arg 1</Th><td>int flag</td></tr>
<tr><th></th><td>初期化フラグ。初期化できていたら1、そうでないなら0。
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>VCE は socket ライブラリに依存しているが、
UNIX 以外のアーキテクチャの場合、socket ライブラリはアプリケーションの
初期化時、 vce_initialize や vce_tcpcontext_create
の呼びだし時には初期化されていない可能性がある。
ところがこれらの関数(入出力はしないがメモリ確保をする関数)はできるだけ
プログラムの呼びだし時に行っておきたい。
本関数を使うことによって、アプリケーションがメインループに入った後に、
入出力をするようにできる。
具体的には、 flag が0の時は、 vce_heartbeat は何もしない。また
send/recv/accept/bind/listen/connect/socket/shutdown/close
などといった処理はすべて呼びださない。
なお POSIX(Linux,FreeBSD) 環境においては、
このフラグは最初から1に設定されているので、
本関数を呼びだす必要はない。
Win32 環境においては、
VCE 内部で winsock の初期化が成功したら自動的に1 に設定される。
PS2 環境においては、デフォルト値は0なので、
USB Ether もしくは modem などのデバイスの
初期化が終了した時点で vce_set_socket_library_ok(1) を呼びだす必要がある。
VCE が内部的に保存しているこのフラグの値は、
vce_initialize の呼びだし後に意味をもつので、
アプリケーションはまず vce_initialize を呼びださなければならない。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_initialize">vce_initialize</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_set_verbose_mode"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_set_verbose_mode</th></tr>
<tr><th>概要</th><td>verboseモード(うるさいモード)の設定をする</td></tr>
<tr><th>カテゴリ</th><td>core</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_set_verbose_mode( int mode )</b></td>
<tr><th>arg 1</Th><td>int mode</td></tr>
<tr><th></th><td>1以上なら verboseモードとなる。 0なら通常モード。
-1なら、「絶対に出力しない」モード。
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>verbose モードの設定は、動的に変更できる。
この関数は、 vce_initialize 関数の出力もverboseにできるように、
vce_initialize 関数の呼びだし前に呼びだすことができるようにできている。<BR>
モードを1にするとVCEライブラリの中に埋めこまれている、
冗長なメッセージも出力されるため、
遅い回線を通してエラーメッセージを見るときは注意が必要である。
</td></tr>
<tr><th>知られているバグやTODO</th><td>TODO verbose モードの仕様は、
アプリケーションとVCE自体の出力を自由に調整できるように、
柔軟に設定をできるようにしていく予定である。
現在はmodeの値は0か1のみが使える。
</td></tr>
</table><br><br>
<a name="vce_sha1_buffer_checksum"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_sha1_buffer_checksum</th></tr>
<tr><th>概要</th><td>バイナリデータ配列のSHA-1チェックサムを求める。</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_sha1_buffer_checksum( const char *buf , int len , char *out , int outlen )</b></td>
<tr><th>arg 1</Th><td>char *buf</td></tr>
<tr><th></th><td>チェックサムを計算するデータを含むバッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>チェックサムを計算するデータの長さ。
</td></tr>
<tr><th>arg 3</Th><td>char *out</td></tr>
<tr><th></th><td>出力バッファの先頭アドレス
</td></tr>
<tr><th>arg 4</Th><td>int outlen</td></tr>
<tr><th></th><td>出力バッファの最大長さ(バイト数)
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>あるメモリ領域のチェックサムを求めるために使用する。
出力は40桁のASCII 16進数文字列である。
"0a4479cd9f99dd9384482fffffcfe923884491af"
という感じの文字列が出力される。
</td></tr>
<tr><th>See also</th><td>
<a href="#hextext">hextext</a>
<a href="#vce_sha1_file_checksum">vce_sha1_file_checksum</a>
</td></tr>
</table><br><br>
<a name="vce_sha1_file_checksum"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_sha1_file_checksum</th></tr>
<tr><th>概要</th><td>ファイルのSHA-1チェックサムを求める。</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_sha1_file_checksum( const char *path , char *out , int len )</b></td>
<tr><th>arg 1</Th><td>char *path</td></tr>
<tr><th></th><td>ファイルの位置を示すpath
</td></tr>
<tr><th>arg 2</Th><td>char *out</td></tr>
<tr><th></th><td>チェックサムの出力バッファの先頭アドレス
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>出力の最大長さ(バイト数)。
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>ファイルのSHA-1チェックサムを求める。SHA-1 は Secure Hash Algorithm の略で、
堅牢なハッシュアルゴリズムとされる。
ファイルの中身が壊れていないかどうかを効果的に調べることができる。
</td></tr>
<tr><th>See also</th><td>
<a href="#hextext">hextext</a>
<a href="#vce_sha1_buffer_checksum">vce_sha1_buffer_checksum</a>
</td></tr>
</table><br><br>
<a name="vce_show_array_usage"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_show_array_usage</th></tr>
<tr><th>概要</th><td>VCE配列の状態をすべて出力する。</td></tr>
<tr><th>カテゴリ</th><td>array</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_show_array_usage( int index , int show_all )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>配列を特定するための配列デスクリプタ
</td></tr>
<tr><th>arg 2</Th><td>int show_all</td></tr>
<tr><th></th><td>各要素についても情報を表示するなら1、そうでないなら0。
0のほうが出力される文字数はかなり少ない。
</td></tr>
<tr><th>返り値</th><td>現在使用中の要素数を返す
</td></tr>
<tr><th>詳細説明</th><td>デバッグ用の関数。配列を指定し、その配列の管理している要素についての
情報をログに対して出力する。
<BR>
注意： エラー出力を抑える設定でビルドされている VCE ライブラリを
リンクしている場合は，本関数は VCE_ESUPPORT を返して何も出力しない．
</td></tr>
<tr><th>知られているバグやTODO</th><td>本関数は、標準エラー出力を使用して出力するため、
標準エラー出力の利用できないWin32GUI環境の場合、
本関数の呼びだしは無意味となる。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_init_array">vce_init_array</a>
</td></tr>
</table><br><br>
<a name="vce_snprintf"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_snprintf</th></tr>
<tr><th>概要</th><td>libc の snprintf の wrapper</td></tr>
<tr><th>カテゴリ</th><td>text</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_snprintf( char *out, int len, const char *format, ... )</b></td>
<tr><th>arg 1</Th><td>char *out</td></tr>
<tr><th></th><td>文字列を出力するバッファの先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>バッファの長さ
</td></tr>
<tr><th>arg 3</Th><td>char *format</td></tr>
<tr><th></th><td>フォーマット文字列
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>UNIX のlibc(glibc) に含まれている snprintf は、
UNIX 以外の環境では、異なるインターフェイスを持っていたり、
そもそも存在しなかったりする。 snprintf はバッファオーバーフロー攻撃を
防ぐためには必要不可欠な関数なので、 VCE ではこれらのプラットフォームの
コードを安全にするために、 vce_snprintf を使うことを推奨する。
</td></tr>
<tr><th>知られているバグやTODO</th><td>linux,win32 以外の環境においてはこの関数は
sprintf と同等の機能しか持っていない．
(バッファ管理のミスによりバッファーオーバーフロー攻撃される可能性がある)。
そのためアプリケーション側で対処する必要がある．
</td></tr>
</table><br><br>
<a name="vce_strcmptail"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_strcmptail</th></tr>
<tr><th>概要</th><td>文字列の末尾を比較する。</td></tr>
<tr><th>カテゴリ</th><td>text</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_strcmptail( char *s1, char *s2 )</b></td>
<tr><th>arg 1</Th><td>char *s1</td></tr>
<tr><th></th><td>ひとつめの文字列
</td></tr>
<tr><th>arg 2</Th><td>char *s2</td></tr>
<tr><th></th><td>ふたつめの文字列
</td></tr>
<tr><th>返り値</th><td>一致しているなら0、一致していないなら非0を返す
</td></tr>
<tr><th>詳細説明</th><td>文字列の末尾を比較する。
</td></tr>
</table><br><br>
<a name="vce_strerror"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_strerror</th></tr>
<tr><th>概要</th><td>VCEエラーコードを文字列に変換する。</td></tr>
<tr><th>カテゴリ</th><td>err</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>char *vce_strerror( int ecode );</b></td>
<tr><th>arg 1</Th><td>int ecode</td></tr>
<tr><th></th><td>エラーコード。 vce.h で定義されている。
</td></tr>
<tr><th>返り値</th><td>文字列へのポインタ。
</td></tr>
<tr><th>詳細説明</th><td>vce.h に定義されているエラーコードを，同様に定義されている
文字列に変換する．
サイレントモードでコンパイルされているVCEの場合は，
本関数は空の文字列を返すし，LAST_ERROR に VCE_ESUPPORTを設定する．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_last_error">vce_get_last_error</a>
</td></tr>
</table><br><br>
<a name="vce_strerror_close_reason"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_strerror_close_reason</th></tr>
<tr><th>概要</th><td>VCEエラーコード(CLOSE_REASON)を文字列に変換する。</td></tr>
<tr><th>カテゴリ</th><td>err</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>char *vce_strerror_close_reason( CLOSE_REASON reason );</b></td>
<tr><th>arg 1</Th><td>CLOSE_REASON reason</td></tr>
<tr><th></th><td>CLOSE_REASON エラーコード。 vce.h で定義されている。
</td></tr>
<tr><th>返り値</th><td>文字列へのポインタ。
</td></tr>
<tr><th>詳細説明</th><td>vce.h に定義されているエラーコード(CLOSE_REASON)を，同様に定義されている
文字列に変換する．
サイレントモードでコンパイルされているVCEの場合は，
本関数は空の文字列を返す．
</td></tr>
</table><br><br>
<a name="vce_strlenmax"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_strlenmax</th></tr>
<tr><th>概要</th><td>最大値指定つき strlen</td></tr>
<tr><th>カテゴリ</th><td>text</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_strlenmax( char *s, int max )</b></td>
<tr><th>arg 1</Th><td>char *s</td></tr>
<tr><th></th><td>長さを調べる文字列の先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int max</td></tr>
<tr><th></th><td>長さの最大値
</td></tr>
<tr><th>返り値</th><td>max バイト以内にヌル終端文字が見つかった場合は、
そのヌル文字を含まない文字列の長さを返す。
ヌル終端文字が見つからない場合は、 -1 を返す(あふれている)。
</td></tr>
<tr><th>詳細説明</th><td>C ライブラリが提供している strlen 関数は、
ヌル終端されていないバッファに対して使うと、
バッファをオーバーランして、SIGSEGV を引きおこす。
本関数ではその問題に対処するために、
バッファをスキャンする最大バイト数を指定できる。
バイナリプロトコルを定義するときに文字列データを使う必要があるときには、
strlen を使用せず本関数を使用するべきである。
なお、 gen.rb が出力するコードでは、本関数を使用している。
</td></tr>
</table><br><br>
<a name="vce_strncat"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_strncat</th></tr>
<tr><th>概要</th><td>文字列を文字列に付けたす。</td></tr>
<tr><th>カテゴリ</th><td>text</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_strncat( char *out, int outlen, char *append )</b></td>
<tr><th>arg 1</Th><td>char *out</td></tr>
<tr><th></th><td>伸ばされる文字列の先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int outlen</td></tr>
<tr><th></th><td>伸ばされる文字列の最大長さ(最後のヌル文字の分を含む)
</td></tr>
<tr><th>arg 3</Th><td>char *append</td></tr>
<tr><th></th><td>付けたす文字列の先頭アドレス
</td></tr>
<tr><th>返り値</th><td>成功したら付けたされた後の文字列の長さ(0以上)を、
付けたすことができなかった場合は負(VCE_EFULL)を返す。
</td></tr>
<tr><th>詳細説明</th><td>結果は All or nothing の原則にしたがい、
勝手にデータを壊して中途半端な文字列を生成することはない。
</td></tr>
</table><br><br>
<a name="vce_strncpy"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_strncpy</th></tr>
<tr><th>概要</th><td>C言語文字列をコピーする</td></tr>
<tr><th>カテゴリ</th><td>text</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_strncpy( char *to, int to_len, const char *from, int from_len )</b></td>
<tr><th>arg 1</Th><td>char *to</td></tr>
<tr><th></th><td>文字列のコピー先の先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int to_len</td></tr>
<tr><th></th><td>文字列のコピー先のバッファの長さ
</td></tr>
<tr><th>arg 3</Th><td>const char *from</td></tr>
<tr><th></th><td>文字列のコピー元の先頭アドレス
</td></tr>
<tr><th>arg 4</Th><td>int from_len</td></tr>
<tr><th></th><td>コピーする文字数
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>UNIX のlibc(glibc) に含まれている strncpy は、
出力先バッファの長さ制限を持たないため，
セグメンテーション違反をひきおこす原因となる．
VCE ではこの問題に対処するために，出力先バッファの長さを指定できる
文字列コピールーチンとして， vce_strncpy 関数を用意した．
vce_strncpy は from の長さ，from_len, (to_len-1)のうち，短いほうの長さ分だけ
fromからtoへコピーし，最後にヌル終端を付け加える仕様となっている．
</td></tr>
</table><br><br>
<a name="vce_switchcontext_cleanup"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_switchcontext_cleanup</th></tr>
<tr><th>概要</th><td>スイッチコンテキストを解放する</td></tr>
<tr><th>カテゴリ</th><td></td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_switchcontext_cleanup( switchcontext_t sw )</b></td>
<tr><th>arg 1</Th><td>switchcontext_t sw</td></tr>
<tr><th></th><td>解放するスイッチコンテキスト
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>vce_switchcontext_create 関数で確保、
初期化した スイッチコンテキストを解放する。
vce_switchcontext_create 関数で関連付けている tcpcontext は解放しない。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_switchcontext_create">vce_switchcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_switchcontext_create"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_switchcontext_create</th></tr>
<tr><th>概要</th><td>コネクションスイッチをわりあて、初期化する</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>switchcontext_t vce_switchcontext_create( vprent_t *st, int num, tcpcontext_t fectx, tcpcontext_t svctx, int rjbuf_size, SW_ACCEPTER_POLICY accepter_policy )</b></td>
<tr><th>arg 1</Th><td>vprent_t *st</td></tr>
<tr><th></th><td>スイッチ表の先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int num</td></tr>
<tr><th></th><td>スイッチ表のエントリ数
</td></tr>
<tr><th>arg 3</Th><td>tcpcontext_t fectx</td></tr>
<tr><th></th><td>フロントエンド(クライアント側用)の通信に使う tcpcontext_t
</td></tr>
<tr><th>arg 4</Th><td>tcpcontext_t svctx</td></tr>
<tr><th></th><td>本体サーバとの通信に使う tcpcontext_t
</td></tr>
<tr><th>arg 5</Th><td>int rjbuf_size</td></tr>
<tr><th></th><td>コネクションスイッチ中に、スイッチ元に送りすぎてしまって返ってきた
分のデータをためておく一時バッファのサイズ
</td></tr>
<tr><th>arg 6</Th><td>SW_ACCEPTER_POLICY accepter_policy</td></tr>
<tr><th></th><td>クライアントからのコネクションを accept したときに、
どの本体サーバに circ_t を accept させるかのポリシーを設定する。
<ul>
<LI>SW_ACCEPTER_POLICY_TOP  スイッチエントリ表のいちばん上が常に accept.
<LI>SW_ACCEPTER_POLICY_RANDOM  ランダムに選ばれたものが accept.
<LI>SW_ACCEPTER_POLICY_SEQUENTIAL  表の上から順番に accept.
</ul>
</td></tr>
<tr><th>返り値</th><td></td></tr>
<tr><th>詳細説明</th><td>スイッチコンテキストを初期化する。
スイッチコンテキストは、フロントエンド用の TCPcontext と、
バックエンドの本体サーバ用の TCPcontext とスイッチ表の情報をもとに
結びつける。
VCE に付属の swp プログラムはこれに
依存している。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_switchcontext_cleanup">vce_switchcontext_cleanup</a>
</td></tr>
</table><br><br>
<a name="vce_switchtable_read_from_file"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_switchtable_read_from_file</th></tr>
<tr><th>概要</th><td>コネクションスイッチングテーブルをテキストファイルから読みこむ</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_switchtable_read_from_file( char *fn, vprent_t *sw, int *num )</b></td>
<tr><th>arg 1</Th><td>char *fn</td></tr>
<tr><th></th><td>入力ファイル名。
</td></tr>
<tr><th>arg 2</Th><td>vprent_t *sw</td></tr>
<tr><th></th><td>表を読みこむ構造体の配列
</td></tr>
<tr><th>arg 3</Th><td>int *num</td></tr>
<tr><th></th><td>値結果引数。配列の最大数を渡し、実際に埋めた要素数を返す。
</td></tr>
<tr><th>返り値</th><td>成功したら0、失敗したら負のエラーコードを返す。
配列の要素数が足りない場合は、途中まで読みこむことはせずに、
エラーを返す。
</td></tr>
<tr><th>詳細説明</th><td>vce.h で定義されている vprent_t 構造体の配列に、
ファイルからデータを読みこむ。
<B>設定ファイルの書式</B><BR>
<pre>
server=192.168.1.231,8001
server=192.168.1.231,8002
server=192.168.1.230,8003
server=foo.bar.baz.com,8004
</pre>
行頭に"コマンド=" が来てそのあとに設定値が続く、 vce_read_simple_config_file
関数の形式である。
<UL>
<LI>"server" ディレクティブ<BR>
値の各トークンは','で区切る。空白文字等は1文字も入れてはならない。
1個目のフィールドはサーバの IP アドレスである。
IPアドレスは重複してもよい。
2個目のフィールドはサーバの TCP ポート番号である。
<font color="red">ポート番号は重複してはならない。</font>
VCE のコネクションスイッチングでは、
TCPサーバのポート番号を識別 ID として使用し、
それはスイッチに参加している全サーバ間で一意性を保つという仕様と
なっているからである。
この理由は、bind されている port 番号は、VCE やアプリケーション層ではなく、
UNIX の標準的なツール (netstat や lsof)などでも見わけることができるため
メンテナンス性が飛躍的に高まるからである。
たとえば、ポートスキャンツールを使って全プロセスの生存を確認したりできる。
また、 すでに tcpcontext に設定されているポート番号との比較により、
「自分がどのサーバなのか」をまちがいなく自動的に判別できるという利点
もある。
スイッチングを利用するような環境ではサーバの台数が
かなり多くなるため、このような仕様となっている。
</UL>
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_switchcontext_create">vce_switchcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_switchtable_show"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_switchtable_show</th></tr>
<tr><th>概要</th><td>コネクションスイッチングテーブルの内容を表示する</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_switchtable_show( const switchent_t *sw, int num )</b></td>
<tr><th>arg 1</Th><td>switchent_t *sw</td></tr>
<tr><th></th><td>表示したいスイッチング表(配列)の先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>int num</td></tr>
<tr><th></th><td>スイッチングテーブルの要素数
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>スイッチングテーブルの内容を vce_errout を用いて出力する。
それ以外の入出力は一切しない。
したがってサイレントモードでビルドされているVCEの場合は，
何も出力されない(VCE_ESUPPORTがセットされる)．
また本関数はテキスト出力をするが、
そのフォーマットは予告なく変更されることがあるのでスクリプト等で処理
することはできない。
外部スクリプト等でバージョン独立性の高い処理をしたい場合は、
switchent_t 構造体の配列を自前で出力するルーチンを書くべきである。
本関数はいわゆる "quick debug" 用である。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_switchtable_read_from_file">vce_switchtable_read_from_file</a>
</td></tr>
</table><br><br>
<a name="vce_taskcontext_cleanup"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_taskcontext_cleanup</th></tr>
<tr><th>概要</th><td>タスクを解放する</td></tr>
<tr><th>カテゴリ</th><td>task</td></tr>
<tr><th>対応OS</th><td>linux,win32,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_taskcontext_cleanup( taskcontext_t tp )</b></td>
<tr><th>arg 1</Th><td>taskcontext_t tp</td></tr>
<tr><th></th><td>解放したいタスク
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>タスクを解放する。
解放すると、コールバック関数は二度と呼ばれなくなる。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_taskcontext_create">vce_taskcontext_create</a>
<a href="#vce_taskgroup_create">vce_taskgroup_create</a>
</td></tr>
</table><br><br>
<a name="vce_taskcontext_create"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_taskcontext_create</th></tr>
<tr><th>概要</th><td>タスクを生成する。</td></tr>
<tr><th>カテゴリ</th><td>task</td></tr>
<tr><th>対応OS</th><td>linux,win32,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>taskcontext_t vce_taskcontext_create( taskgroup_t tp, VCEI64 interval_us, int (*callback)( taskcontext_t tp, char *work, int len ), char *wk, int len )</b></td>
<tr><th>arg 1</Th><td>taskgroup_t tp</td></tr>
<tr><th></th><td>作られたタスクが所属するタスクグループ
</td></tr>
<tr><th>arg 2</Th><td>VCEI64 interval_us</td></tr>
<tr><th></th><td>タスクのコールバック関数が呼びだされる間隔(microseconds)．
</td></tr>
<tr><th>arg 3</Th><td>int (*callback)( taskcontext_t tp, char * work, int len )</td></tr>
<tr><th></th><td>タスクのコールバック関数。
tp には、タスク自体が入る。work はワークメモリ領域のポインタ。
len はワーク領域の長さ。
このコールバック関数は、0をかえすと次回も呼びだされる。
0より小さい値を返すと、2度と呼びだされることはなく、自動的に cleanup される。
</td></tr>
<tr><th>arg 4</Th><td>char *wk</td></tr>
<tr><th></th><td>ワーク領域を初期化するバッファの先頭アドレス。
NULL を指定すると、ワーク領域をもつタスクの場合はゼロ初期化する。
ワーク領域のないタスクの場合は何もしない。
</td></tr>
<tr><th>arg 5</Th><td>int len</td></tr>
<tr><th></th><td>ワーク領域の長さ。
</td></tr>
<tr><th>返り値</th><td></td></tr>
<tr><th>詳細説明</th><td>タスクグループに属するタスクを生成する。
生成時に、ワーク領域を初期化することができる。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_taskgroup_create">vce_taskgroup_create</a>
</td></tr>
</table><br><br>
<a name="vce_taskcontext_get_elapsed_time"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_taskcontext_get_elapsed_time</th></tr>
<tr><th>概要</th><td>taskcontext_t を初期化してから現在までに経過した時間を得る</td></tr>
<tr><th>カテゴリ</th><td>task</td></tr>
<tr><th>対応OS</th><td>linux,win32,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>VCEI64 vce_taskcontext_get_elapsed_time( taskcontext_t )</b></td>
<tr><th>arg 1</Th><td>taskcontext_t t</td></tr>
<tr><th></th><td>経過時間を取得したいタスク
</td></tr>
<tr><th>返り値</th><td>経過時間(マイクロ秒を VCEI64 型に入れたもの)
</td></tr>
<tr><th>詳細説明</th><td>タスク初期化後に経過した時間をマイクロ秒で得る。
マイクロ秒である理由は UNIX における timeval の最高精度がマイクロ秒
だからである。実際の精度はマイクロ秒よりも粗いので注意が必要である。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_taskcontext_create">vce_taskcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_taskcontext_get_id"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_taskcontext_get_id</th></tr>
<tr><th>概要</th><td>タスク の ID を得る</td></tr>
<tr><th>カテゴリ</th><td>task</td></tr>
<tr><th>対応OS</th><td>linux,win32,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_taskcontext_get_id( taskcontext_t tp )</b></td>
<tr><th>arg 1</Th><td>taskcontext_t tp</td></tr>
<tr><th></th><td>ID を取得したい タスク
</td></tr>
<tr><th>返り値</th><td>ID は整数値で返される。
</td></tr>
<tr><th>詳細説明</th><td>すべてのタスクは、異なる ID をもつ。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_taskcontext_create">vce_taskcontext_create</a>
<a href="#vce_taskgroup_create">vce_taskgroup_create</a>
</td></tr>
</table><br><br>
<a name="vce_taskcontext_get_workmem"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_taskcontext_get_workmem</th></tr>
<tr><th>概要</th><td>タスクが持っているワーク領域を取得する</td></tr>
<tr><th>カテゴリ</th><td>task</td></tr>
<tr><th>対応OS</th><td>linux,win32,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void *vce_taskcontext_get_workmem( taskcontext_t tp )</b></td>
<tr><th>arg 1</Th><td>taskcontext_t tp</td></tr>
<tr><th></th><td>ワーク領域を取りだしたいタスク
</td></tr>
<tr><th>返り値</th><td>ワーク領域へのポインタ。
ワーク領域がない場合は、
NULLポインタを返す。
</td></tr>
<tr><th>詳細説明</th><td>ワーク領域へのポインタを返すが、
サイズに関してはあらかじめ vce_taskgroup_create
関数で設定しているので、ここでは取りだせない。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_taskcontext_create">vce_taskcontext_create</a>
<a href="#vce_taskgroup_create">vce_taskgroup_create</a>
</td></tr>
</table><br><br>
<a name="vce_taskgroup_cleanup"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_taskgroup_cleanup</th></tr>
<tr><th>概要</th><td>タスクグループを解放する</td></tr>
<tr><th>カテゴリ</th><td>task</td></tr>
<tr><th>対応OS</th><td>linux,win32,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_taskgroup_cleanup( taskgroup_t tp )</b></td>
<tr><th>arg 1</Th><td>taskgroup_t tp</td></tr>
<tr><th></th><td>解放したいタスクグループ
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>タスクグループを解放すると、すべてのタスクが停止する。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_taskgroup_create">vce_taskgroup_create</a>
</td></tr>
</table><br><br>
<a name="vce_taskgroup_create"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_taskgroup_create</th></tr>
<tr><th>概要</th><td>VCE 内にタスクグループを初期化する。</td></tr>
<tr><th>カテゴリ</th><td>task</td></tr>
<tr><th>対応OS</th><td>linux,win32,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>taskgroup_t vce_taskgroup_create( VCEI64 granu_us, int num, int worksize, int per_loop, char *name )</b></td>
<tr><th>arg 1</Th><td>VCEI64 granu_us</td></tr>
<tr><th></th><td>タイマーチェックの解像度を設定する(マイクロ秒)。
VCE はここで指定されているマイクロ秒ごとに、
そのタスクグループに属するタスクについて、
呼びだし時期がきているかどうか調べる。これを「インターバルチェック」という。
</td></tr>
<tr><th>arg 2</Th><td>int num</td></tr>
<tr><th></th><td>タスクグループに属するタスクの最大個数。
</td></tr>
<tr><th>arg 3</Th><td>int worksize</td></tr>
<tr><th></th><td>各タスクのコールバック関数に引数として渡されるワークメモリ領域のサイズ。
VCE 内部で1個のバッファを分割しているので、
アラインメントが悪い場合は性能に関する警告が表示される場合がある。
</td></tr>
<tr><th>arg 4</Th><td>int per_loop</td></tr>
<tr><th></th><td>1回のインターバルチェックで時刻チェックをするアクティブなタスクの個数。
1回のインターバルチェックで全部のタスクについてチェックすると、
ある1回の vce_heartbeat のときに負荷が集中することになる。
それを均一化するために、1回のインターバルチェックで時刻をチェックする
アクティブなタスクの数を制限できる。
タスクはラウンドロビンで、前から順番に処理される。
したがって、 たとえば アクティブなタスク が 1000 で per_loop が 10 の場合、
100 回の vce_heartbeat 呼びだしごとに1周、チェックがまわってくることになる。
この設定は、呼びだし頻度や性能と直結しているので注意が必要である。
</td></tr>
<tr><th>arg 5</Th><td>char *name</td></tr>
<tr><th></th><td>タスクの名前
</td></tr>
<tr><th>返り値</th><td>初期化に成功したら有効なポインタ、 失敗したらヌルポインタを返す
返り値はポインタだが， taskgroup_t にtypedef されている．
</td></tr>
<tr><th>詳細説明</th><td>VCE が持っているコールバックベースのタスク管理機構を初期化する。
目的に応じて各パラメータを設定することが性能上重要である。
以下に、アプリケーションの目的ごとにガイドラインを示す。
<ul>
<LI>サーバー集中型のゲームアプリケーションにおける、 NPCの動作<BR>
granu=0 num=数千〜数万, per_loop=数百〜1000
<LI>各クライアントに対して ping/pong を撃つ場合<BR>
granu=100*1000, num=2000, per_loop=10<BR>
</ul>
通常の Intel マシンの場合、
vce_heartbeat ごとに 10000 以上のタスクの時刻チェックをするような設定に
してしまうと性能低下を招く恐れがあり、
おそらくその設定は適切でない。
そこでタスクの設定に関するパフォーマンスチューニングを可能にするために、
vce_taskgroup_get_stat 関数でコールバック関数の呼びだし回数や
チェック回数を取得できるようにした。
これにより vce_heartbeat 関数の前後で取得した値を比較することができる。
</td></tr>
<tr><th>知られているバグやTODO</th><td>本関数はマイクロ秒単位のタイマが利用できる環境でしか精密には動作しない．
したがって linux,win32 以外の環境ではは精密には動作しない．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_heartbeat">vce_heartbeat</a>
<a href="#vce_set_verbose_mode">vce_set_verbose_mode</a>
<a href="#vce_taskcontext_create">vce_taskcontext_create</a>
<a href="#vce_taskgroup_cleanup">vce_taskgroup_cleanup</a>
</td></tr>
</table><br><br>
<a name="vce_taskgroup_get_stat"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_taskgroup_get_stat</th></tr>
<tr><th>概要</th><td>タスクグループの統計情報を得る</td></tr>
<tr><th>カテゴリ</th><td>task</td></tr>
<tr><th>対応OS</th><td>linux,win32,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_taskgroup_get_stat( taskgroup_t tp, taskgroup_stat_t *s )</b></td>
<tr><th>arg 1</Th><td>taskgroup_t tp</td></tr>
<tr><th></th><td>情報を取りだしたいタスクグループ
</td></tr>
<tr><th>arg 2</Th><td>taskgroup_stat_t *s</td></tr>
<tr><th></th><td>取りだした情報を格納する構造体の先頭アドレス。
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>taskgroup_stat_t 構造体のポインタ。
構造体のメンバの意味は、
<ul>
<LI>total_taskgroup_check_count<BR>
そのタスクグループのインターバルチェックをした回数。
<LI>total_taskcontext_check_count<BR>
各タスクに対して時刻のチェックをした回数。
<LI>total_taskcontext_call_count<BR>
各タスクのコールバックを呼びだした回数。
<LI>inuse_num<BR>
そのグループのタスクの何個が使用されてるか。
<LI>max_num<BR>
そのグループに存在し得るタスク。
</ul>
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_taskgroup_create">vce_taskgroup_create</a>
</td></tr>
</table><br><br>
<a name="vce_taskgroup_set_scan_log_mode"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_taskgroup_set_scan_log_mode</th></tr>
<tr><th>概要</th><td>タスクのデバッグログ出力を調節する．</td></tr>
<tr><th>カテゴリ</th><td>task</td></tr>
<tr><th>対応OS</th><td>linux,win32,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_taskgroup_set_scan_log_mode( taskgroup_t tp, int v )</b></td>
<tr><th>arg 1</Th><td>taskgroup_t tp</td></tr>
<tr><th></th><td>設定対象の taskgroup
</td></tr>
<tr><th>arg 2</Th><td>int v</td></tr>
<tr><th></th><td>0なら出力なし，非ゼロならあり
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>タスクグループは複数のタスクを管理していて，
ラウンドロビン(順繰り)方式でタスクを起動していく．
多くのアプリケーションにおいて，すべてのタスクが正しい頻度で
起動されるかを調べるために，本当に期待した頻度で全タスクの
スキャンが完了しているかを知りたいことが多い．
本関数は，あるタスクグループに属しているすべてのタスクコンテキストの
スキャンが終了するたびに1回づつ，スキャンが完了したことを示すログ
を出力する．現在は以下のような文字列を出力する．
<pre>
[task TASKNAME scan complete]
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_taskgroup_create">vce_taskgroup_create</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_add_circ_ipv4_filter"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_add_circ_ipv4_filter</th></tr>
<tr><th>概要</th><td>サーバのTCPコンテキストに接続できるcirc_tのIPアドレスをフィルタする</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_tcpcontext_add_circ_ipv4_filter( tcpcontext_t tp, const char *net, const char *mask, int policy )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>フィルタを追加するTCPコンテキスト
</td></tr>
<tr><th>arg 2</Th><td>char *net</td></tr>
<tr><th></th><td>送信元クライアントのネットワークアドレス。
"192.168.1.0"のような文字列を指定する。
内部でDNSを使用するのでFQDN を指定してもよい。
なおDNSは初期化時に１回だけなので負荷は少ない。
</td></tr>
<tr><th>arg 3</Th><td>char *mask</td></tr>
<tr><th></th><td>ネットマスクを指定する。 "255.255.255.0" のような文字列を指定する。
</td></tr>
<tr><th>arg 4</Th><td>int policy</td></tr>
<tr><th></th><td>FILTER_POLICY_ACCEPT, FILTER_POLICY_DENY, FILTER_POLICY_LOG を OR 演算
することによって指定する。通常は、
<pre>
FILTER_POLICY_ACCEPT
FILTER_POLICY_DENY
FILTER_POLICY_ACCEPT | FILTER_POLICY_LOG
FILTER_POLICY_DENY | FILTER_POLICY_LOG
</pre>
の4種類のうちのどれかである。ほかにもオプションを付けていく場合は、
OR演算子で連結していく。
</td></tr>
<tr><th>返り値</th><td>成功した場合は0、失敗した場合は負のエラーコードを返す。
</td></tr>
<tr><th>詳細説明</th><td>基本的な動作は、 vce_tcpcontext_add_conn_ipv4_filter と同じだが、
中継サーバに接続する仮想回路に対する設定である点が異なる。
</td></tr>
<tr><th>知られているバグやTODO</th><td>現在のIPフィルタ設定の最大個数は、128個までとなっている。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_add_conn_ipv4_filter">vce_tcpcontext_add_conn_ipv4_filter</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_add_ipv4_filter"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_add_ipv4_filter</th></tr>
<tr><th>概要</th><td>サーバのTCPコンテキストに接続できるconn_tのIPアドレスをフィルタする</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_tcpcontext_add_conn_ipv4_filter( tcpcontext_t tp, const char *net, const char *mask, int policy )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>フィルタを追加するTCPコンテキスト
</td></tr>
<tr><th>arg 2</Th><td>char *net</td></tr>
<tr><th></th><td>送信元ネットワークアドレス。 "192.168.1.0" のような文字列を指定する。
FQDNを指定すると内部でDNSを使用して名前を解決する。
なおDNSは初期化時に１回だけなので負荷は少ない。
アクセスチェック時に DNS を引きなおすことはない。
</td></tr>
<tr><th>arg 3</Th><td>char *mask</td></tr>
<tr><th></th><td>ネットマスクを指定する。 "255.255.255.0" のような文字列を指定する。
</td></tr>
<tr><th>arg 4</Th><td>int policy</td></tr>
<tr><th></th><td>FILTER_POLICY_ACCEPT, FILTER_POLICY_DENY, FILTER_POLICY_LOG を OR 演算
することによって指定する。通常は、
<pre>
 FILTER_POLICY_ACCEPT
 FILTER_POLICY_DENY
 FILTER_POLICY_ACCEPT | FILTER_POLICY_LOG
 FILTER_POLICY_DENY | FILTER_POLICY_LOG
</pre>
の4種類のうちのどれかである。ほかにもオプションを付けていく場合は、
OR演算子で連結していく。
</td></tr>
<tr><th>返り値</th><td>成功した場合は0、失敗した場合は負のエラーコードを返す。
</td></tr>
<tr><th>詳細説明</th><td>TCPコンテキストのIPソースアドレスフィルターの動作については、
tcp のカテゴリ説明を参照。
重要な点は、
フィルタをひとつも設定していない状態ではすべての接続を受けいれるが、
ひとつでも設定した時点で、デフォルトの動作が変化してすべての接続を
受けいれなくなる点である。これは設定ミスによるセキュリティホールを
最小限に食いとめるためである。
</td></tr>
<tr><th>知られているバグやTODO</th><td>現在IPフィルタは、128個まで設定できるようになっている。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_add_circ_ipv4_filter">vce_tcpcontext_add_circ_ipv4_filter</a>
<a href="#vce_tcpcontext_delete_circ_ipv4_filter">vce_tcpcontext_delete_circ_ipv4_filter</a>
<a href="#vce_tcpcontext_delete_conn_ipv4_filter">vce_tcpcontext_delete_conn_ipv4_filter</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_circ_iterate"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_circ_iterate</th></tr>
<tr><th>概要</th><td>tcpcontext_t が保持している仮想回路(circ_t)の各要素を関数で処理する</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_tcpcontext_circ_iterate( tcpcontext_t tt, int (*func)(circ_t c) )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tt</td></tr>
<tr><th></th><td>処理したい tcpcontext_t
</td></tr>
<tr><th>arg 2</Th><td> int (*func)( circ_t c )</td></tr>
<tr><th></th><td>tcpcontext_t が持っている各 circ_t に対して、指定した関数を呼びだす。
</td></tr>
<tr><th>返り値</th><td>tcpcontext_t が仮想回路に対応していないなどの場合は負のエラーコード、
正常終了の場合はゼロを返す。
</td></tr>
<tr><th>詳細説明</th><td>コールバック関数の引数には、仮想回路の各要素が与えられる。
コールバック関数が負を返すとループを途中で終了する。
0以上の値を返すとループを継続する．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_conn_iterate">vce_tcpcontext_conn_iterate</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_cleanup"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_cleanup</th></tr>
<tr><th>概要</th><td>TCPコンテキストを解放する。</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_tcpcontext_cleanup( tcpcontext_t tp )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>解放するTCPコンテキストへのポインタ。 vce_tcpcontext_createの返り値である。
サーバーコンテキストもクライアントコンテキストも同様に解放できる。
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>VCEライブラリ中に保存されているTCPコンテキストの構造体を1個解放する。
VCEライブラリが管理できる tcpcontext 構造体の数は制限があるので、
vce_tcpcontext_cleanup 関数で解放せずに vce_tcpcontext_create を
くりかえすと、資源が足りなくなり VCE_EFULL を返すようになる。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_clear_circ_ipv4_filter"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_clear_circ_ipv4_filter</th></tr>
<tr><th>概要</th><td>TCPコンテキストに設定されているcirc_t用のIPフィルタ設定を初期化する</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_tcpcontext_clear_circ_ipv4_filter( tcpcontext_t tp )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>設定を抹消するTCPコンテキスト
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>TCPコンテキストに設定されている、仮想回路(circ_t)のIPフィルタ設定を初期化し、
デフォルトの状態に戻す。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_add_circ_ipv4_filter">vce_tcpcontext_add_circ_ipv4_filter</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_clear_conn_ipv4_filter"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_clear_conn_ipv4_filter</th></tr>
<tr><th>概要</th><td>TCPコンテキストに設定されているconn_t用のIPフィルタ設定を初期化する</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_tcpcontext_clear_conn_ipv4_filter( tcpcontext_t tp )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>設定を抹消するTCPコンテキスト
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>TCPコンテキストに設定されている、通常のコネクション(conn_t)に対する
IPソースアドレスフィルタを初期化し、デフォルトの状態に戻す。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_add_conn_ipv4_filter">vce_tcpcontext_add_conn_ipv4_filter</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_conn_iterate"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_conn_iterate</th></tr>
<tr><th>概要</th><td>tcpcontext が保持しているすべてのconn_tに対して関数で処理する</td></tr>
<tr><th>カテゴリ</th><td></td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_tcpcontext_conn_iterate( tcpcontext_t tt, int (*f)(conn_t c))</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tt</td></tr>
<tr><th></th><td>処理したい tcpcontext_t
</td></tr>
<tr><th>arg 2</Th><td>int (*f)(conn_t c)</td></tr>
<tr><th></th><td>各要素に対して呼びだされるコールバック関数
</td></tr>
<tr><th>返り値</th><td>引数が不正などの場合は負のエラーコード、正常終了の場合はゼロを返す
</td></tr>
<tr><th>詳細説明</th><td>コールバック関数の引数には、コネクション(conn_t)の各要素が与えられる。
コールバック関数が負を返すとループを途中で終了する。
0以上の値を返すとループを継続する．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_circ_iterate">vce_tcpcontext_circ_iterate</a>
<a href="#vce_tcpcontext_get_all_connection">vce_tcpcontext_get_all_connection</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_connect"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_connect</th></tr>
<tr><th>概要</th><td>リモートにあるVCEサーバに接続し、TCPコネクションを1個確立する。</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>conn_t vce_tcpcontext_connect( tcpcontext_t tp, const char *hostname, unsigned short port );</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>設定情報を格納しているTCPコンテキスト。
</td></tr>
<tr><th>arg 2</Th><td>char *hname</td></tr>
<tr><th></th><td>どのホストに接続するのか、IPアドレスを名前か番号で指定する。
</td></tr>
<tr><th>arg 3</Th><td>unsigned short port</td></tr>
<tr><th></th><td>上記で指定したホストのどのポートに接続するのかを指定する。
</td></tr>
<tr><th>返り値</th><td>成功なら新しくTCPコンテキストの中に割りあてられたコネクション管理
構造体(conn_t)を返す。
失敗なら無効なconn_tを返す。
無効かどうかを知るには vce_conn_is_valid 関数を使用する。
エラーの内容を得るには、
vce_get_last_error を使う。
</td></tr>
<tr><th>詳細説明</th><td>言うまでもなくconnectはクライアントソケットにだけ許された機能なので、
クライアントコンテキストの場合のみ利用可能である。
また vce_tcpcontext_connect 関数は、内部で conn_t を1個割りあてて初期化
するときに tcpcontext_t から、parser と callback の情報をコピーするので、
vce_tcpcontext_connect の呼びだし以前に vce_tcpcontext_set_parser を
呼びだしておく必要がある。
なお，クライアントから connect をするときには，
tcpcontext がノンブロッキングモードに設定されている場合と，
そうでない場合で成功確認方法が異なる．
これについては<a href="connect.html">クライアントからの接続</a>
を参照．
</td></tr>
<tr><th>使用例</th><td><pre>
  t = vce_tcpcontext_create( 0, ... );
  conn_t connection = vce_tcpcontext_connect( t,  "www.ce-lab.net", 80 );
</pre>
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_is_valid">vce_conn_is_valid</a>
<a href="#vce_conn_writable">vce_conn_writable</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_count_connections"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_count_connections</th></tr>
<tr><th>概要</th><td>tcpcontext に属するコネクションの数を数える</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_tcpcontext_count_connections( tcpcontext_t t, int *conn, int *circ )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t t</td></tr>
<tr><th></th><td>数を調査したい対象となる tcpcontext
</td></tr>
<tr><th>arg 2</Th><td>int *conn</td></tr>
<tr><th></th><td>conn_t コネクションの数を返すためのバッファの先頭アドレス．
NULL を指定すると，無視される．
</td></tr>
<tr><th>arg 3</Th><td>int *circ</td></tr>
<tr><th></th><td>circ_t コネクションの数を返すためのバッファの先頭アドレス．
NULL を指定すると，無視される．
</td></tr>
<tr><th>返り値</th><td>正常終了ならばゼロ，そうでないならば負のエラーコードを返す．
</td></tr>
<tr><th>詳細説明</th><td>1個の tcpcontext が管理しているコネクションの数を数える．
conn_t と circ_t を別々に数える．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_get_all_circuit">vce_tcpcontext_get_all_circuit</a>
<a href="#vce_tcpcontext_get_all_connection">vce_tcpcontext_get_all_connection</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_create"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_create</th></tr>
<tr><th>概要</th><td>TCPコンテキストを初期化する。</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>tcpcontext_t vce_tcpcontext_create( int flag, const char *bindaddr, unsigned short port, int maxcon, size_t rblen, size_t wblen, int timeout, VCE_BLOCK_CIPHER cipher, int shkeylen , int nonblock_connect, int nodelay, size_t statebuf_size )</b></td>
<tr><th>arg 1</Th><td>int flag</td></tr>
<tr><th></th><td>TCPcontext の基本的性質を設定するフラグ。
1にするとIPv4のサーバーコンテキスト、0にするとクライアントコンテキストになる。
</td></tr>
<tr><th>arg 2</Th><td>char *bindaddr</td></tr>
<tr><th></th><td>ソケットを bindするIPアドレス。クライアントの場合もサーバーの場合も、
通常は "0.0.0.0"を指定すれば十分である。
特定のアドレスからのみ接続を受けいれたい場合は、IPアドレスを指定する。
例： "192.168.1.11"
</td></tr>
<tr><th>arg 3</Th><td> unsigned short port</td></tr>
<tr><th></th><td>ソケットをbindするポート番号。
1024より小さくするためにはroot権限が必要である(UNIX)。
VCEを用いたアプリケーションの場合は、
7000よりも大きい適当な番号にしておけば問題ない。
</td></tr>
<tr><th>arg 4</Th><td>int maxcon</td></tr>
<tr><th></th><td>最大接続数。VCEはOSの限界までの接続数をサポートするが、
この引数によってVCEが接続を許す本数をそれより小さい本数に制限する
ことができる。この制限は、アクセス不能攻撃を防ぐためには有効である。
ちなみに、OSの限界値は、Linuxでは1000本程度、
win32ではメモリ次第もしくは64本である。
どちらもある程度チューニングが可能である。<BR>
ただし、チューニングして非常に多くのコネクション(2000本以上とか)を
1マシンで同時に使うのは性能やセキュリティの面で薦められない。<BR>
この引数の限界は存在しないが、 VCE は vce_initialize 時に、
前もって最大のコネクション数を決めてから各 tcpcontext_t に割りふるように
なっているので、たとえば maxcon に 1200 を指定しても 1000 本のコネクション
しか割りあてられない(Linuxでのデフォルト限界値は1000)。
この場合は、 vce_initialize_limited 関数を使用して、
最大接続限界をそれより大きな値にしてやることが必要である。
</td></tr>
<tr><th>arg 5</Th><td>size_t rblen</td></tr>
<tr><th></th><td>ネットワークからの読みこみバッファの最大長。
この最大長は、1個のTCPコネクションの読みこみバッファの長さである。
VCEが独自に定義している仮想回路(circ)の読みこみバッファの長さではない。
暗号化コネクションを使う場合は、この値を1024以上にしておく必要がある。
</td></tr>
<tr><th>arg 6</Th><td>size_t wblen</td></tr>
<tr><th></th><td>書きこみバッファの数。これはTCPコネクション(ソケット)の書きこみバッファ
であり、仮想回路の書きこみバッファではない。
暗号化コネクションを使う場合は
この値は1024以上を指定しなければならない。
特に，swpを使う場合はパフォーマンスのため最低でも1MBを指定すること．
</td></tr>
<tr><th>arg 7</Th><td>int timeout</td></tr>
<tr><th></th><td>接続のタイムアウト時間(秒)。
一定時間、あるTCPコネクションに対して書きこみも読みこみもしなかった
場合、自動的にコネクションを切断する(shutdown/close).
これをタイムアウトという。タイムアウトした後にそのコネクションに
書きこみしようとした場合は、エラーが返る。
</td></tr>
<tr><th>arg 8</Th><td>VCE_BLOCK_CIPHER cipher</td></tr>
<tr><th></th><td>暗号化コネクションを利用したい場合は、
VCE_BLOCK_CIPHER_BLOWFISH,VCE_BLOCK_CIPHER_RIJNDAEL,VCE_BLOCK_CIPHER_TWOFISH
のいずれかの値を指定する。利用しない場合は、
VCE_BLOCK_CIPHER_NONE を指定する。
暗号強度と性能に関しては<a href="bench.html">こちら</a>を参照.
</td></tr>
<tr><th>arg 9</Th><td>int shkeylen</td></tr>
<tr><th></th><td>共有鍵の長さ。鍵交換の結果、サーバとクライアントがコーディングキーとして
使う鍵の長さを指定する。この鍵が長いほど、
暗号解読攻撃に対する耐性が強い。<BR>
VCE_BLOCK_CIPHER_BLOWFISH を使う場合は、4以上56以下の値を指定する。<BR>
チャットやゲームアプリケーションなどでは8を指定すれば十分である。<BR>
VCE_BLOCK_CIPHER_RIJNDAEL を使う場合は、16,24,32 のいずれかを指定する。<BR>
チャットやゲームアプリケーションなどでは16を指定すれば十分である。<BR>
VCE_BLOCK_CIPHER_TWOFISH を使う場合は、16,24,32 のいずれかを指定する。<BR>
チャットやゲームアプリケーションなどでは16を指定すれば十分である。  <BR>
デコードとエンコードのための時間は、キーの長さの1乗に比例して長くなる。<BR>

</td></tr>
<tr><th>arg 10</Th><td>int nonblock_connect</td></tr>
<tr><th></th><td>nonblock_connect は、クライアントコンテキスト専用で、
新しくconnect()システムコールを用いて接続を構築するときに、
TCPコネクションが完成するまでブロックするかどうかを指定する。
1だとブロックしない(nonblock)、0だとブロックする。
ブロックするようにすれば、
アプリケーションのプログラムを多少単純にすることができる。
ただし，VCEのアプリケーション開発においては，
「ノンブロッキング接続」が推奨される．
ゲームクライアントなどのアプリケーションにおいては，
確実にノンブロッキングモードを使用するべきである．
この理由については，<a href="connect.html">クライアントの接続について</a>
が参考になるだろう．
</td></tr>
<tr><th>arg 11</Th><td>nodelay</td></tr>
<tr><th></th><td>ソケットに対してTCP_NODELAY オプションを使うかどうかを指定する。
nodelayを1にすると TCP_NODELAY オプションをつけ、0にすると付けない。
TCP_NODELAYオプションによって、OSがTCPパケットをネットワークに送りこむ
までの溜め時間が短かくなる。(Negelアルゴリズムのキャンセル)
ただし、小さなパケットを連続で送る場合は、
ネットワーク利用効率が下がるので注意が必要である。
特に小さなパケットを高速にやりとりしたい場合以外は、0にするべきである。
</td></tr>
<tr><th>arg 12</Th><td>size_t statebuf_size</td></tr>
<tr><th></th><td>状態をもつプロトコルの場合、この引数に0より大きい値を指定し、
状態管理のための領域をVCEに管理させることができる。
ベクトライザを使う場合は vce_circ_get_state, 使わない場合は
vce_conn_get_state 関数を使用することにより、
状態管理領域へのポインタを取得することができる。
</td></tr>
<tr><th>返り値</th><td>成功したら TCPコンテキストへのポインタを返す。
失敗したらヌルポインタを返す。
</td></tr>
<tr><th>詳細説明</th><td>TCPコンテキストの実体をVCE内部に(128個まで)初期化し、
通信に必要なすべての初期化を行なう。
この関数が返す tcpcontext_t 型は、今後の処理
(現在は vce_tcpcontext_cleanupのみ)で使用する。
VCE は vce_tcpcontext_connect など新規コネクションを初期化するような
処理をするときに tcpcontext_t の設定をコピーして使用するため、
vce_tcpcontext_connect の後に vce_tcpcontext_set_??? のような関数を
使って設定を変更しても、
connect で得られたコネクションには設定が反映されない。
したがってコーディング時には、できるだけ tcpcontext の設定は
vce_tcpcontext_create の直後に集中させるようにすることが大切である。
またブロック暗号を使用する場合は、
8バイトや16バイトといったブロックの長さに丸めて通信されるので、
短かいデータを送信する場合は、限界性能に微妙に影響が出る場合がある。
ただし TCP のヘッダが40バイトあることを考えると、
その部分に凝るのはそれほど意味があるとは思えない。
<BR>
<B>送受信バッファを小さくするときの注意</B><BR>
PS2 などのメモリが少ない環境において，
使用メモリを極限まで節約するために，
tcpcontext の「受信バッファ量」と「送信バッファ量」
を小さくしたいことは多い．
ところが，このふたつの量を小さくしていくと，
様々な問題が起こり得る．
「送信バッファ」に関しては，
1回のプロトコル送信で送信したい量よりも小さくすると，
その送信が失敗するので，アプリケーションが1回のプロトコルで送りたい
量を下回らないようにする必要がある．
「受信バッファ」に関しても同様だが，
暗号を使う場合に独特の注意点がある．
それは，VCEは，heartbeatが呼びだされてから次の heartbeat
が呼びだされるまでの間に conn_write (circ_write) された
データに関しては，ひとつにまとめて暗号化することがある点だ．
たとえば，次のheartbeat呼びだしまでの期間に，
サーバーが1KBのデータを20回送ると， 20KBが1個の塊として暗号化され，
クライアントの読みこみバッファが10KBしかなかったとすると，
そのバッファを使って暗号を解読することができなくなる．
暗号解読は読みこみバッファの空きを使って処理されるからである．
ちなみに，暗号化の最大パックサイズは32KBバイトなので，
受信側の読み込みバッファが32KB+8以上あれば，
どんな場合でも間違いなく暗号を解読できる．
送信する速度と，
受信側の読みこみバッファの量は，関係があるのである．
したがって，「バルク転送をしたい場合は，
受信側に十分な(32KB以上の)読みこみバッファを用意せよ．」
ということになる．
</td></tr>
<tr><th>使用例</th><td><pre>
  #include "vce.h"

  int my_callback( conn_t ct, char *data , int len )
  {
      データ処理。
      if( 正常修了 ) return 0;  else return -1;
  }

  int main( int argc, char **argv )
  {
      tcpcontext_t *t = vcetcpcontext_create(
      1,      // サーバ
      6667,   // ポート 6667
      10,     // 最大接続数
      1024, 1024,  // 読み書きバッファー長
      60 * 60,   // 1時間で接続タイムアウト
      VCE_BLOCK_CIPHER_BLOWFISH,   // 暗号を使用
      8,         // 8バイト(64ビット)の鍵を使用
      0,         // ブロッキング
      0,         // NODELAY は指定しない
      0          // 状態のないプロトコル
      );
      ...
  }
</pre>
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_circ_get_state">vce_circ_get_state</a>
<a href="#vce_conn_get_state">vce_conn_get_state</a>
<a href="#vce_initialize">vce_initialize</a>
<a href="#vce_initialize_limited">vce_initialize_limited</a>
<a href="#vce_tcpcontext_cleanup">vce_tcpcontext_cleanup</a>
<a href="#vce_tcpcontext_connect">vce_tcpcontext_connect</a>
<a href="#vce_tcpcontext_set_circ_acceptwatcher">vce_tcpcontext_set_circ_acceptwatcher</a>
<a href="#vce_tcpcontext_set_circ_closewatcher">vce_tcpcontext_set_circ_closewatcher</a>
<a href="#vce_tcpcontext_set_circ_parser">vce_tcpcontext_set_circ_parser</a>
<a href="#vce_tcpcontext_set_conn_acceptwatcher">vce_tcpcontext_set_conn_acceptwatcher</a>
<a href="#vce_tcpcontext_set_conn_closewatcher">vce_tcpcontext_set_conn_closewatcher</a>
<a href="#vce_tcpcontext_set_conn_parser">vce_tcpcontext_set_conn_parser</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_delete_circ_ipv4_filter"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_delete_circ_ipv4_filter</th></tr>
<tr><th>概要</th><td>circ_t に対して設定されているIPフィルタを取りのぞく</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_tcpcontext_delete_circ_ipv4_filter( tcpcontext_t tp, const char *net, const char *mask )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>フィルタを削除するTCPコンテキスト
</td></tr>
<tr><th>arg 2</Th><td>char *net</td></tr>
<tr><th></th><td>削除するフィルタのネットワークアドレス
</td></tr>
<tr><th>arg 3</Th><td>char *mask</td></tr>
<tr><th></th><td>削除するフィルタのネットマスク
</td></tr>
<tr><th>返り値</th><td>成功したら0、失敗したら負のエラーコードを返す。
</td></tr>
<tr><th>詳細説明</th><td>vce_tcpcontext_add_circ_ipv4_filter 関数で指定したフィルタの設定と
全く同じ設定値を用いて、フィルタを取りのぞく。
設定値がみつからない場合や引数が無効な場合は、負のエラーコードを返す。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_add_circ_ipv4_filter">vce_tcpcontext_add_circ_ipv4_filter</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_delete_conn_ipv4_filter"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_delete_conn_ipv4_filter</th></tr>
<tr><th>概要</th><td>conn_tに対して設定されているIPフィルタを取りのぞく</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_tcpcontext_delete_conn_ipv4_filter( tcpcontext_t tp, const char *net, const char *mask )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>フィルタを削除するTCPコンテキスト
</td></tr>
<tr><th>arg 2</Th><td>char *net</td></tr>
<tr><th></th><td>削除するフィルタのネットワークアドレス
</td></tr>
<tr><th>arg 3</Th><td>char *mask</td></tr>
<tr><th></th><td>削除するフィルタのネットマスク
</td></tr>
<tr><th>返り値</th><td>成功したら0、失敗した負のエラーコードを返す。
</td></tr>
<tr><th>詳細説明</th><td>vce_tcpcontext_add_conn_ipv4_filter 関数で設定したフィルタの設定と
全く同じ設定値を用いて、フィルタを取りのぞく。
設定値がみつからない場合や引数が無効な場合は、負のエラーコードを返す。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_add_conn_ipv4_filter">vce_tcpcontext_add_conn_ipv4_filter</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_enable_accept"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_enable_accept</th></tr>
<tr><th>概要</th><td>新規に accept しないようにする</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_tcpcontext_enable_accept( tcpcontext_t tp, int flag )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>操作対象となるTCPcontext
</td></tr>
<tr><th>arg 2</Th><td>int flag</td></tr>
<tr><th></th><td>1にすると今後も新規に accept する。
0にすると今後は accept しない。
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>サーバを人為的に終了させるときなどに、
新たなユーザがログインしてこないように、
新規に accept しないようにしたいことがある。
本関数はそのために使用する。
verbose モードのときはログを出力する(verbose mode only)。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_close_all_conn">vce_tcpcontext_close_all_conn</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_get_all_circuit"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_get_all_circuit</th></tr>
<tr><th>概要</th><td>tcpcontext に属するすべての仮想回路を得る</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_tcpcontext_get_all_circuit( tcpcontext_t tt , circ_t *a, int max);</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tt</td></tr>
<tr><th></th><td>処理対象のtcpcontext
</td></tr>
<tr><th>arg 2</Th><td>circ_t *a</td></tr>
<tr><th></th><td>配列を出力する先頭アドレス
</td></tr>
<tr><th>arg 3</Th><td>int max</td></tr>
<tr><th></th><td>配列の最大要素数
</td></tr>
<tr><th>返り値</th><td>配列を埋めた数を返す(0以上の値)。
</td></tr>
<tr><th>詳細説明</th><td>ひとつのtcpcontext に属する仮想回路を配列にコピーして出力する。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_count_connections">vce_tcpcontext_count_connections</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_get_all_connection"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_get_all_connection</th></tr>
<tr><th>概要</th><td>tcpcontext に属するすべてのコネクションを得る</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_tcpcontext_get_all_connection( tcpcontext_t t , conn_t *a, int max);</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t t</td></tr>
<tr><th></th><td>処理対象のtcpcontext
</td></tr>
<tr><th>arg 2</Th><td>conn_t *a</td></tr>
<tr><th></th><td>配列を出力する先頭アドレス
</td></tr>
<tr><th>arg 3</Th><td>int max</td></tr>
<tr><th></th><td>配列の最大要素数
</td></tr>
<tr><th>返り値</th><td>配列を埋めた数を返す(0以上の値)。
</td></tr>
<tr><th>詳細説明</th><td>ひとつのtcpcontext に属するコネクションを配列にコピーして出力する。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_count_connections">vce_tcpcontext_count_connections</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_get_stat"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_get_stat</th></tr>
<tr><th>概要</th><td>tcpcontext の統計情報を取得する</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_tcpcontext_get_stat( tcpcontext_t tp, tcpcontext_stat_t *s )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>情報を取得する tcpcontext
</td></tr>
<tr><th>arg 2</Th><td>tcpcontext_stat_t *s</td></tr>
<tr><th></th><td>情報を格納するための構造体(tcpcontext_stat_t)の先頭アドレス
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>TCPコンテキストが内部的に管理している統計情報を取得する。
この情報はデバッグやログなど幅広く活用される。
以下はtcpcontext_stat_t構造体メンバの説明である。
<ul>
<LI>current_conn, current_circ<BR>
現在活動中のコネクションの数。 current_conn は conn_t の数で、
current_circ は circ_t の数である。
<LI>recv_byte, send_byte<BR>
合計の送受信バイト数
<LI>recv_syscall, recv_syscall_e<BR>
recv()システムコールの呼びだし回数。 _e はエラー呼びだしの回数
<LI>accept_syscall, accept_syscall_e, send_syscall, send_syscall_e,
connect_syscall, connect_syscall_e<BR>
各システムコールの呼びだし回数。
<LI>conn_write<BR>
vce_conn_write の呼びだし回数
<LI>conn_timeout<BR>
conn_t がタイムアウトした回数。
<LI>tcpcontext_connect<BR>
vce_tcpcontext_connect が成功した回数。
</ul>
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_stat">vce_conn_get_stat</a>
<a href="#vce_get_stat">vce_get_stat</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_is_circ_mode"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_is_circ_mode</th></tr>
<tr><th>概要</th><td>TCPコンテキストが、仮想回路用か普通のコネクション用かを調べる</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_tcpcontext_is_circ_mode( tcpcontext_t tp )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>調査対象となる TCPコンテキスト
</td></tr>
<tr><th>返り値</th><td>circ(仮想回路)用のTCPコンテキストだったら1、そうでないなら0を返す。
</td></tr>
<tr><th>詳細説明</th><td>VCEをRuby,Javaなどの言語で利用できるようにするための拡張ライブラリを作る
場合に、TCPコンテキストのポインタからTCPコンテキストの種類を得るための
関数である。通常のアプリケーションからは使うことは少ないだろう
(あらかじめ種類はアプリケーションプログラム側でわかっているはずなので。)
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_protocol_set_maxlength"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_protocol_set_maxlength</th></tr>
<tr><th>概要</th><td>パーサーが分割する最大の長さを設定する。</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_tcpcontext_protocol_set_maxlength(tcpcontext_t ct,int maxlength,int(*errcall)(conn_t ct))</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t t</td></tr>
<tr><th></th><td>設定情報を格納しているTCPコンテキスト。
</td></tr>
<tr><th>arg 2</Th><td>int max_length</td></tr>
<tr><th></th><td>分割する最大のレコード長。
</td></tr>
<tr><th>arg 3</Th><td>int(*errcall)(conn_t ct))</td></tr>
<tr><th></th><td>制限に達した時に呼ばれるコールバック関数。負の値を返せば接続を拒否できる。
NULLの場合は呼ばれず接続を拒否する。
</td></tr>
<tr><th>返り値</th><td>無し
</td></tr>
<tr><th>詳細説明</th><td>　ストリームからレコード単位に分割するときに
先頭に格納されてる長さの情報を受信したときにチェックする。
プログラムがクラックされ、異常に長いレコードを連続で受信し、バッファや帯域を
圧迫させる行為を防ぐ事が出来る。
</td></tr>
<tr><th>知られているバグやTODO</th><td>TODO 現在は16bitパーサーでしかチェックしていない。
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_reset_compress"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_reset_compress</th></tr>
<tr><th>概要</th><td>TCPコンテキストに対して、圧縮解凍機能をOFFにする</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_tcpcontext_reset_compress( tcpcontext_t tp )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>圧縮解凍機能解除するTCPコンテキストのポインタ
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>圧縮機能を解除する。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_set_compress">vce_tcpcontext_set_compress</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_accept_max"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_accept_max</th></tr>
<tr><th>概要</th><td>一分間あたりの接続数を制限する</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_tcpcontext_set_accept_max(tcpcontext_t t,int con_max,int (*accept_warning)(tcpcontext_t t))</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t t</td></tr>
<tr><th></th><td>設定情報を格納しているTCPコンテキスト。
</td></tr>
<tr><th>arg 2</Th><td>int con_max</td></tr>
<tr><th></th><td>一分間で許容する最大の接続数
</td></tr>
<tr><th>arg 3</Th><td>int (*accept_warning)(tcpcontext_t t)</td></tr>
<tr><th></th><td>制限に達した時に呼ばれるコールバック関数。負の値を返せば接続を拒否できる。
NULLの場合は呼ばれず接続を拒否する。
</td></tr>
<tr><th>返り値</th><td>無し
</td></tr>
<tr><th>詳細説明</th><td>DDoS対策として接続数を制限するときに使う関数。
接続が来てVCE内のあらゆる処理をする前に判断されるので
低負荷でブロックする事ができる。（conn構造体も作られない）
設定した制限値が10だとすれば10本までは接続を通し、
その後は6秒毎に一本ずつ許可数が増えていくようになっている。
con_maxにゼロを設定すれば許可無しとなる。
</td></tr>
<tr><th>使用例</th><td><pre>
  //一分間で10本の接続を許可する
  vce_tcpcontext_set_accept_max(t,10,0);
</pre>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_circ_acceptwatcher"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_circ_acceptwatcher</th></tr>
<tr><th>概要</th><td>TCPコネクションに対して、仮想回路の新規接続監視関数を設定する。</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_tcpcontext_set_circ_acceptwatcher( tcpcontext_t tp, int (*aw)(circ_t) )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>設定対象となるTCPコンテキスト
</td></tr>
<tr><th>arg 2</Th><td>int (*aw)(circ_t c )</td></tr>
<tr><th></th><td>新規接続監視関数へのポインタ。 circ_t はあたらしく接続を受けいれた
circ_t である．
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>TCPcontextが新しい仮想回路を受けいれるたびにこの関数(aw)を呼びだすように
設定する。アプリケーションにおいて新規接続をすべてログしたり、
状態バッファを初期化したりしたいときに役だてることができる。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_circ_closewatcher"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_circ_closewatcher</th></tr>
<tr><th>概要</th><td>TCPコンテキストに対して、仮想回路がcloseしたときの監視関数を設定する</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_tcpcontext_set_circ_closewatcher( tcpcontext_t tp, int (*cw)(circ_t,CLOSE_REASON) )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>設定対象となるTCPコンテキスト
</td></tr>
<tr><th>arg 2</Th><td>int (*cw)(circ_t c, CLOSE_REASON reason )</td></tr>
<tr><th></th><td>close監視関数へのポインタ。reasonはクローズされた理由． vce.hで
列挙体は定義されている．
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>仮想回路が切断されたときに呼びだされるコールバック関数を設定する。
アプリケーション以外の理由で強制的に切断されたときの処理などに使用する
ことができる。
クローズの理由を reason 引数から推定することができる．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_tcpcontext_set_conn_closewatcher">vce_tcpcontext_set_conn_closewatcher</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_circ_finalizer"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_circ_finalizer</th></tr>
<tr><th>概要</th><td>TCPコンテキストに対して、仮想回路のファイナライザを指定する。</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_tcpcontext_set_circ_finalizer( tcpcontext_t tp, void (*fin)(circ_t) )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>ファイナライザを指定するTCPコンテキストのポインタ
</td></tr>
<tr><th>arg 2</Th><td>void *fin(circ_t to_be_finalized )</td></tr>
<tr><th></th><td>ファイナライザ関数へのポインタ。 to_be_finalized は、
解放されようとしている仮想回路をあらわす。
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>TCPコンテキストが管理している仮想回路が解放されようとしているときに
1回だけ呼びだされるファイナライザを指定する。
この関数は主にRubyやJavaなど、他の言語用のwrapperライブラリのために
用意されている。アプリケーションからは、closewatcher を使うので十分である。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_tcpcontext_set_conn_finalizer">vce_tcpcontext_set_conn_finalizer</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_circ_hiwater_acceptwatcher"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_circ_hiwater_acceptwatcher</th></tr>
<tr><th>概要</th><td>TCPコンテキストに，仮想回路の接続数が多いとき用のaccept監視関数をセットする</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_tcpcontext_set_circ_hiwater_acceptwatcher( tcpcontext_t tp, int water, int (*aw)(circ_t, int))</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>設定対象となるTCPcontext
</td></tr>
<tr><th>arg 2</Th><td>int water</td></tr>
<tr><th></th><td>高水位を示す数．
この数値を越えるとデフォルトのものにかわって，
本関数で設定した接続監視関数が呼びだされる．
</td></tr>
<tr><th>arg 3</Th><td>int (*aw)(circ_t *c, int num )</td></tr>
<tr><th></th><td>高水位状態のとき用の接続監視関数．
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>本関数は， vce_tcpcontext_set_conn_hiwater_acceptwatcher 関数の
circ_t版である．詳細な動作については，
その関数とまったく同様の動作をする．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_tcpcontext_set_conn_hiwater_acceptwatcher">vce_tcpcontext_set_conn_hiwater_acceptwatcher</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_circ_parser"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_circ_parser</th></tr>
<tr><th>概要</th><td>TCPコネクションが仮想回路に対して使うパーサ関数を設定する。</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_tcpcontext_set_circ_parser( tcpcontext_t tp, int (*parser)(circ_t), int (*pcallback)(circ_t,char*,int))</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>設定対象となるTCPコンテキスト
</td></tr>
<tr><th>arg 2</Th><td>int (*parser)(circ_t c)</td></tr>
<tr><th></th><td>パーサ関数へのポインタ
</td></tr>
<tr><th>arg 3</Th><td>int (*circcallback)(circ_t circ, char *data , int len )</td></tr>
<tr><th></th><td>パーサが呼びだすコールバック関数へのポインタ
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>仮想回路にデータが来た場合にそれをパースして仮想回路用のコールバック
関数を呼びだすためのパーサと、そのパーサが呼びだすコールバック関数を
同時に設定する。現在は、標準のパーサとして、
<pre>
vce_vecprotocol_parser_bin16
vce_vecprotocol_parser_text
vce_vecprotocol_parser_through
</pre>
がVCEに含まれている。
また、VCEに標準添付されているコールバック関数は
<pre>
vce_vecprotocol_pcallback_echo_bin16  仮想回路上でbin16プロトコルを使う
vce_vecprotocol_pcallback_echo_text  仮想回路上で改行レコードを使う
vce_vecprotocol_pcallback_echo_through 仮想回路上でデータをそのままecho
</pre>
がある。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_circ_switchresultwatcher"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_circ_switchresultwatcher</th></tr>
<tr><th>概要</th><td>コネクションスイッチの結果を検出するための関数を設定</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_tcpcontext_set_circ_switchresultwatcher( tcpcontext_t t,int (*w)(circ_t,int,int,char*,int))</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t t</td></tr>
<tr><th></th><td>設定する対象となる tcpcontext_t
</td></tr>
<tr><th>arg 2</Th><td>int (*w)(circ_t c, int result, int dest_sv_id, char *data, int len)</td></tr>
<tr><th></th><td>結果検出用のコールバック関数。
result 無事にswitchできたら0、そうでないなら
SWITCH_RESULT 列挙型の値が入る。SWITCH_RESULT は vce.h で定義されている。
dest_sv_id は、どのサーバに移動させようとしたかのID。
data,len は、 vce_circ_switch のときに指定した引数がそのまま入る。
コールバック関数は 0を返すこと。
このコールバック関数は、
コネクションスイッチングによりほかのサーバに移動してしまった
コネクションの後始末するためのものである。
コネクションスイッチ後は closewatcher は呼ばれないので、
必要な後かたづけはこの関数内で実装するべきである。
</td></tr>
<tr><th>返り値</th><td></td></tr>
<tr><th>詳細説明</th><td>vce_circ_switch 関数をノンブロッキングにするために、
その結果を受けとるためのコールバック関数が必要である。
本関数ではそのコールバック関数を tcpcontext_t に対して設定する。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_circ_switch">vce_circ_switch</a>
<a href="#vce_tcpcontext_set_circ_switchwatcher">vce_tcpcontext_set_circ_switchwatcher</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_circ_switchwatcher"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_circ_switchwatcher</th></tr>
<tr><th>概要</th><td>新しくコネクションスイッチしてきた circ_t を検出する関数を設定</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_tcpcontext_set_circ_switchwatcher( tcpcontext_t t, int (*sw)( circ_t, int, char *,int))</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t t</td></tr>
<tr><th></th><td>設定対象となる tcpcontext_t
</td></tr>
<tr><th>arg 2</Th><td>int (*sw)(circ_t c, int from_id, char *data, int len )</td></tr>
<tr><th></th><td>コールバック関数。
あたらしくスイッチされてきたコネクションがあると呼びだされる。
</td></tr>
<tr><th>返り値</th><td>成功したら0、失敗したら負のエラーコードを返す。
</td></tr>
<tr><th>詳細説明</th><td>本関数の働きは acceptwatcher と類似で、
ほかのサーバからスイッチしてきた circ_t コネクションが tcpcontext
内部で新規に割りあてられてからすぐに呼びだされる。
c は、そうして新規に割りあてられた circ_t である。
from_id は、どのサーバからスイッチしてきたかを示す ID で、
スイッチ設定ファイルの先頭のフィールドの値である。
data と len は、スイッチするときに付帯状況としてスイッチ元の
サーバが付けた情報である。
スイッチするときにはこのような付帯状況を付けないと、
アプリケーションにとっては意味がないからである。<BR><BR>
コールバック関数が負を返すと、そのスイッチを受けいれない。
この機能は、
アプリケーションが同時ログイン人数制限など
いろいろな制限を課すことに使うことができる。
また0を返すと、そのスイッチを受けいれる。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_circ_switch">vce_circ_switch</a>
<a href="#vce_tcpcontext_set_circ_switchresultwatcher">vce_tcpcontext_set_circ_switchresultwatcher</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_compress"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_compress</th></tr>
<tr><th>概要</th><td>TCPコンテキストに対して、圧縮解凍機能を初期化し、ワークサイズを指定する</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_tcpcontext_set_compress( tcpcontext_t tp , unsigned long size )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>圧縮解凍を行うTCPコンテキストのポインタ
</td></tr>
<tr><th>arg 2</Th><td>unsigned long size</td></tr>
<tr><th></th><td>圧縮解凍のためのワークサイズ
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>圧縮機能を使用する場合、この関数で初期化、ワークバッファのサイズの指定を
行う。
ワークサイズには、送受信するときのデータの最大値(圧縮前のサイズ)を指定する。
32MBまでの値を設定できる。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_reset_compress">vce_tcpcontext_reset_compress</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_conn_acceptwatcher"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_conn_acceptwatcher</th></tr>
<tr><th>概要</th><td>TCPコンテキストに対して、指定されたaccept監視関数を使うように設定する</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_tcpcontext_set_conn_acceptwatcher( tcpcontext_t tp, int (*aw)(conn_t) )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>設定対象となるTCPコンテキスト
</td></tr>
<tr><th>arg 2</Th><td>int (*aw)(conn_t c)</td></tr>
<tr><th></th><td>accept監視関数。conn_t cには、新規に受けいれられようとしている
コネクションが入る。
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>サーバーコンテキストが新しい接続を受けいれたときに、
この関数が1回呼びだされる。
アプリケーション開発者はこの関数を置きかえることによって、
接続を受けいれた場合にログを出力したり、アドレス制限をかけたりできる。
このコールバック関数が負を返すと、
VCEは接続受けいれ拒否と判断し、closeする。
暗号化コネクションを使用しているときは、暗号ネゴシエーションが終了してから、
acceptwatcher が呼びだされる。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_tcpcontext_set_closewatcher">vce_tcpcontext_set_closewatcher</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_conn_call_parser_per_heartbeat"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_conn_call_parser_per_heartbeat</th></tr>
<tr><th>概要</th><td>1回の heartbeat で各コネクションのパーサが呼びだされる回数を調整する</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_tcpcontext_set_conn_call_parser_per_heartbeat( tcpcontext_t tt, int v )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tt</td></tr>
<tr><th></th><td>設定対象の tcpcontext_t
</td></tr>
<tr><th>arg 2</Th><td>int v</td></tr>
<tr><th></th><td>回数(0以上)．負を指定したときの動作は不定．
</td></tr>
<tr><th>返り値</th><td></td></tr>
<tr><th>詳細説明</th><td>デフォルトの状態では、プロトコル・パーサは、 vce_heartbeat 関数の中で、
ネットワークからの入力を確認して1レコード分の情報がそろっている事が
確認されると、1回だけコールバック関数を呼びだす。
本関数を使ってその最大回数を制御することができる．
引数 v で指定した回数まで， 1回の heartbeat で複数回のコールバックが
呼びだされるようになる．
本関数は，クライアントおよびサーバーの性能チューンにおいてまず
注目される点である．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_heartbeat">vce_heartbeat</a>
<a href="#vce_tcpcontext_set_conn_parser">vce_tcpcontext_set_conn_parser</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_conn_closewatcher"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_conn_closewatcher</th></tr>
<tr><th>概要</th><td>TCPコンテキストに対して、指定されたclose監視関数を使うように設定する</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_tcpcontext_set_conn_closewatcher( tcpcontext_t tp, int (*cw)(conn_t,CLOSE_REASON) )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>設定対象となるTCPコンテキスト
</td></tr>
<tr><th>arg 2</Th><td>int (*cw)(conn_t c, CLOSE_REASON reason)</td></tr>
<tr><th></th><td>close 監視関数。conn_t c には、閉じられようとしているコネクションが入る。
reason には， CLOSE_REASON 列挙体で定義されている定数が代入される．
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>何らかの理由で接続がcloseされてしまったときに1回だけ呼びだされる関数。
VCEではこのように呼びだされる関数は close watcher と呼ばれ，
conn_t でも circ_t でも同様に使われる．
アプリケーション開発者がこの関数本体を定義する
ことによって、ソケットが閉じられたことをログしたりできる。
close watcher は呼びだされるときの原因に応じて reason 引数に，
何が原因だったのかをあらわす定数が代入される．
アプリケーションではこの値をみて，closeの原因を推定できる．
reason の内容は，以下の通りである．
以下ではそれぞれを
「リモート型」と「ローカル型」に分けて，
問題を迅速に切りわけられるようにした．

<ul>
<LI>CLOSE_REASON_NONE (-1)<BR>
VCEが内部的に使用する．これが返されるのは， VCE のバグが考えられる．

<LI>CLOSE_REASON_UNKNOWN (0)<BR>
原因不明．基本的に返されることはない．
返された場合は，VCEのバグが考えられる．

<LI>CLOSE_REASON_REMOTE (1)<BR>
リモートピアによってコネクションが切断されたため，
書きこみも読みこみもできなくなった．
CLOSE_REASON_REMOTE は，リモート型の中で，特に分類できなかった場合の
generic な理由のときに返される．

<LI>CLOSE_REASON_APPLICATION (2)<BR>
アプリケーションによって， vce_conn_close などが呼びだされた．
「ローカル型」の典型的なクローズ理由である．

<LI>CLOSE_REASON_TIMEOUT (3)<BR>
タイムアウト時間になるまで，送受信が行われなかったため，
切断された．タイムアウトの場合は，リモートが原因なのか，
ローカルが原因なのか，判別はつかない．

<LI>CLOSE_REASON_DECODER (4)<BR>
暗号デコーディング関数の内部でエラーが起きた．
相手から送られてきたデータのフォーマットが異常であるか，
データレコードが必要としている分のデータが届かない間にコネクションが
利用不可能になってしまった場合に起こる．
つまり，このエラーは，「リモート型」である．
このエラーは，コネクション初期化時の暗号ネゴシエーションが終わり，
データの交換が始まってから起こる．

<LI>CLOSE_REASON_ENCODER (5)<BR>
暗号エンコーディング関数の内部でエラーが起きた．
このエラーは，コネクション初期化時の暗号ネゴシエーションが終わり，
データの交換が始まってから起こる．
VCE は暗号化用に特別なメモリを使わないこともあり，この理由は
「リモート型」である．


<LI>CLOSE_REASON_PARSER (6)<BR>
プロトコルパーサー関数が負の値を返したので，
コネクションを切断した．
これは，ローカル型である．ローカルのパーサー関数の返り値が負であった．

<LI>CLOSE_REASON_INTERNAL (7)<BR>
VCE の内部的な問題により，コネクションを閉じた．
VCEの内部メモリが足りない場合や，エラーチェックに
失敗した場合や，VCEのバグが考えられる．
ローカル型である．

<LI>CLOSE_REASON_FULL (8)<BR>
SWPを使っている場合に，SWPへ送る送信バッファが一杯になっている場合に
この値になる．SWPへ送る送信バッファが一杯ということは，
SWPのサーバーからの受信バッファも一杯になっている可能性が高い．
SWPのバッファー容量を大きくするか，
相手むけ回線の容量が一杯になっていることを疑うべきである．
リモートホストのバッファが一杯になっていることから，
「リモート型」と言える．

</ul>

<BR><BR>
現在、コールバック関数の返り値は無視される。
close watcher は，すでに完成しているコネクションに対してだけ呼びだされる．
言いかえれば，暗号化コネクションを使用しているときに、
暗号ネゴシエーションが終了する前にコネクションが切断された場合、
close watcher は呼びだされない．
その場合でも、 fainalizer は呼びだされる。
<BR>
なお，close watcher の引数はVCE バージョン 0.4.73 から追加されたが，
過去のバージョンの close watcher を渡してもコンパイラ警告が出るだけで
問題は起きない．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_tcpcontext_set_conn_acceptwatcher">vce_tcpcontext_set_conn_acceptwatcher</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_conn_finalizer"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_conn_finalizer</th></tr>
<tr><th>概要</th><td>TCPコンテキストに対して、コネクションのファイナライザを指定する。</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_tcpcontext_set_conn_finalizer( tcpcontext_t tp , void *finalizer(conn_t) )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>ファイナライザを指定するTCPコンテキストのポインタ
</td></tr>
<tr><th>arg 2</Th><td>void *finalizer(conn_t to_be_finalized )</td></tr>
<tr><th></th><td>ファイナライザ関数へのポインタ。 to_be_finalized は、
解放されようとしているコネクションをあらわす。
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>TCPコンテキストが管理しているTCPコネクションが解放されようとしているときに
1回だけ呼びだされるファイナライザを指定する。
これは、Rubyなど高級言語でTCPのコネクションをガベージコレクタに追跡
させたいときなどに有用である。vce_tcpcontext_create 関数を呼びだして
tcpコンテキストを初期化した後に呼びだすこと。
この関数は主にRubyやJavaなど、他の言語用のwrapperライブラリのために
用意されている。アプリケーションからは、closewatcher を使うので十分である。
注意点としては、暗号化コネクションを使用しているときに、
暗号ネゴシエーションが終了する前にコネクションが切断された場合に、
closewatcher は呼びだされないが、 finalizer は呼びだされる点である。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_tcpcontext_set_circ_finalizer">vce_tcpcontext_set_circ_finalizer</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_conn_hiwater_acceptwatcher"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_conn_hiwater_acceptwatcher</th></tr>
<tr><th>概要</th><td>TCPコンテキストに，接続数が多いとき用のaccept監視関数をセットする</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_tcpcontext_set_conn_hiwater_acceptwatcher( tcpcontext_t tp, int water, int (*aw)(conn_t,int))</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>設定対象となるTCPコンテキスト
</td></tr>
<tr><th>arg 2</Th><td>int water</td></tr>
<tr><th></th><td>高水位を指定する値．この値以上の数の同時接続が，
ひとつのTCPcontextに対して存在している場合は，
通常の acceptwatcher ではなく，
本関数で設定する専用のacceptwatcherを呼びだすようにする．
</td></tr>
<tr><th>arg 3</Th><td>int (*aw)(conn_t c,int num)</td></tr>
<tr><th></th><td>設定する監視関数(高水位接続監視関数)．通常のものとは異なり，
現在何個の接続が存在しているのかを num で受けとることができる．
あらかじめ設定されている最大接続数と比較することで，
システムにあとどれぐらいの余裕があるのかを知ることができる．
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>サーバーコンテキストが新しい接続を受けいれたときに，
同時接続数がある数以上の場合に，
指定した接続監視関数を呼びだすように設定する．
VCEでは，この数のことを「高水位設定値」"high water"と呼んでいる．
この機能を使うことによって，サーバーが混雑しているときに，
ユーザーが単に接続できないようになるのではなく，
「現在混雑しています．」などといったメッセージを送信することが可能となる．
たとえば，絶対的最大数が1000に設定されているゲームサーバーの場合は，
900あたりにこの値(water)を設定しておき，
900本目以降の接続に関してはここで設定した専用の監視関数を使うことで，
独自のプロトコルシーケンスを発行することができる．
高水位接続監視関数が呼びだされた場合は，
通常の接続監視関数は呼びだされない.
また高水位接続監視関数の返り値は，通常の接続監視関数の返り値と同様に
扱われる．つまり，負を返すと接続を拒否する．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_tcpcontext_set_conn_acceptwatcher">vce_tcpcontext_set_conn_acceptwatcher</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_conn_kickip_array"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_conn_kickip_array</th></tr>
<tr><th>概要</th><td>接続を拒否するIPアドレスの配列を設定する。</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_tcpcontext_set_conn_kickip_array(tcpcontext_t tp,unsigned int *null_terminated_ipaddr_array)</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t t</td></tr>
<tr><th></th><td>設定情報を格納しているTCPコンテキスト。
</td></tr>
<tr><th>arg 2</Th><td>unsigned int *null_terminated_ipaddr_array</td></tr>
<tr><th></th><td>０終端されたIPアドレスへのリスト。
</td></tr>
<tr><th>返り値</th><td>無し
</td></tr>
<tr><th>詳細説明</th><td>拒否するIPアドレスをひとつずつ大量に設定したいときに使う。
配列はunsigned intのそのままIPv4アドレスで、配列の先頭のアドレスを渡すだけで
0.0.0.0がくるまで全部とチェックする。Accept後他の処理が入る前にすぐチェックされるので
低負荷で蹴る事が出来る。
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_conn_parser"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_conn_parser</th></tr>
<tr><th>概要</th><td>TCPコンテキストに対して、TCPコネクション(conn_t)用のパーサを設定する</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_tcpcontext_set_conn_parser( tcpcontext_t tp, int (*parser)(conn_t),int (*pcallback)(conn_t,char*,int))</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>設定対象となる TCPコンテキスト
</td></tr>
<tr><th>arg 2</Th><td>int (*parser)(conn_t c )</td></tr>
<tr><th></th><td>パーサ関数へのポインタ
</td></tr>
<tr><th>arg 3</Th><td>int (*pcallback)(conn_t c,char *data, int len )</td></tr>
<tr><th></th><td>パーサ関数がレコードを取りだしたときに、そのレコードを与えてよびだす
コールバック関数
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>通常のTCPコネクション(conn_t)からの入力をパースしてレコードを取りだす
パーサ関数を指定する。VCEでは、
レコード境界を判定してレコードを取りだす方法を挿しかえることができるように、
関数へのポインタを設定できるようになっている。
VCEでは、標準的な方法でレコード境界を判定するためのデフォルトパーサとして、
<pre>
vce_protocol_parser_bin16            標準的なbin16パーサ
vce_protocol_parser_text             改行記号をレコード境界とするパーサ
vce_protocol_parser_through          何も処理せず、そのまま渡すパーサ
vce_protocol_parser_vecmain_server   vecproxy用パーサ
</pre>
以上の2つのパーサを実装しているので、通常のアプリケーションでは、
これらのパーサを利用すればよい。
またパケットベクトライズ(中継サーバ)を使用する場合は、
vce_protocol_parser_vecmain_server をパーサに指定し、
さらに vce_tcpcontext_set_circ_parser も呼びだして
circ_t 用のパーサを指定することも必要である。<BR>
また、 pcallback はパーサによって呼びだされるコールバック関数で、
引数として data, len を用いてレコードの中身(レコード境界を除く)
を与える。これも単純なものはVCEに標準添付されていて、
<pre>
vce_protocol_pcallback_echo_bin16    bin16でエコーするコールバック
vce_protocol_pcallback_echo_text     改行レコードでエコーするコールバック
vce_protocol_pcallback_noop          データを捨てるコールバック
vce_protocol_pcallback_dump          データを表示するコールバック
</pre>
が利用できる。
通常はユーザーがアプリケーションごとにコールバック関数を定義し、
その関数でデータを適切に処理する。
コールバック関数が負を返したら、VCEはプロトコルエラーと判断し、
TCPコネクションを自動的に切断する。
コールバック関数がゼロ以上を返すと，正常終了と見なすが，
vce_tcpcontext_set_conn_call_parser_per_heartbeat 関数を使って
1回の heartbeat あたりの最大コールバック呼びだし回数を変更している場合，
ゼロとそれ以上の値では意味が異なる．
詳細は  vce_tcpcontext_set_conn_call_parser_per_heartbeat
関数のリファレンスを参照．
<BR><BR>
また、パーサを自前で定義するようなアプリケーションの場合
(bin16でもbin32でもtextでもなく、まったく新しいプロトコルを定義したい場合)
はパーサ関数を自前で定義してこの関数でパーサとして設定することになる。
その場合はコールバックを使用することができないため、
<pre>
vce_tcpcontext_set_conn_parser( t, parser, NULL );
</pre>
のようなコーディングをすることになる。

</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_tcpcontext_set_circ_parser">vce_tcpcontext_set_circ_parser</a>
<a href="#vce_tcpcontext_set_conn_call_parser_per_heartbeat">vce_tcpcontext_set_conn_call_parser_per_heartbeat</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_conn_safety_read"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_conn_safety_read</th></tr>
<tr><th>概要</th><td>connコネクションの「安全な読みこみ」を設定する</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_tcpcontext_set_conn_safety_read( tcpcontext_t tp, int per )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>設定したい TCP コンテキスト。
クライアントでもサーバーでもどちらでも、「安全な読みこみ」機能は有効。
</td></tr>
<tr><th>arg 2</Th><td>int per</td></tr>
<tr><th></th><td>書きこみ(送信)バッファのパーセントを0から100の値で指定。
負や101以上の値を指定するとエラーとなる。
書きこみバッファがこのパーセント<b>以上</B>空いているとき<B>だけ</B>、
読みこみ処理をする。読みこみ処理とは、ソケットからの読みこみと、
パーサやコールバック関数の呼びだしである。
0を指定すると、常に読みこみ処理をし、100を指定すると、
書きこみバッファが完全に空の場合だけ読みこみ処理をする。
</td></tr>
<tr><th>返り値</th><td>正常終了の場合0、エラーが発生した場合は負のエラーコードを返す。
</td></tr>
<tr><th>詳細説明</th><td>ネットワークアプリケーションにおいて、
送信のためのバッファが一杯になっている場合は、
以下のような状況が考えられる。
<ol>
<LI>クライアントが処理を継続できない状態になった。
<LI>経路の途中に障害が発生し、通信が遅延している。
<LI>そもそもデータを送る量が多すぎる。
</ol>
VCEでは、「レコード」単位でコールバックを呼びだすプロトコルを主にターゲット
としているが、そのようなプロトコルをデザインする場合、
以下の状況がかならず発生する。
<ol>
<LI>サーバにおいて、クライアントから要求を受けとった。
<LI>それを処理し、クライアントへ処理結果を送りかえす。
<LI>しかし、送信バッファが一杯のため、送信できない。
</ol>
この例では、受信して処理した結果を返せないため、
処理の全体(クライアントに通知するまで)が完了できないままになってしまう。
これを防ぐには、以下のような順番で処理すればよい。
<OL>
<LI>サーバにおいて、書きこみバッファに空きがあるか調べる。
<LI>空きがあるなら要求を受信する。
<LI>それを処理し、クライアントへ処理結果を返す。
</ol>
このような定型的な処理をVCEに任せてしまうために、
vce_tcpcontext_set_conn_safety_read,  vce_tcpcontext_set_circ_safety_read
の2関数が用意されている。
これらの関数を使用すれば、読みこみの前に書きこみバッファの空きを
確認するので、アプリケーション側で、
書きこめなかった場合の処理をする必要がなくなる。
この関数は、どのようなタイミングで呼びだしても、効果をもつ。
VCEでは以上の機能を「安全な読みこみ(safe read)」と名付ける。
受信と送信のサイズ差があまりないアプリケーションで送信バッファが
比較的小さい場合は  per の値は50〜80程度がよく、
送信バッファが十分に大きい場合は10〜20でよい。
デフォルトでは、 per の値は0であり、
書きこみバッファの空きがないときでも読みこみ処理を行なう。
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_equal_io_splitrate"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_equal_io_splitrate</th></tr>
<tr><th>概要</th><td>1回の heartbeat でネットワークへの送信をするコネクション数を調整する</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_tcpcontext_set_equal_io_splitrate( tcpcontext_t tt, int v )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tt</td></tr>
<tr><th></th><td>設定対象となる TCPコンテキスト
</td></tr>
<tr><th>arg 2</Th><td>int v</td></tr>
<tr><th></th><td>何回に分けて書きこむかの値(デフォルトは1)
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>vce_heartbeat では，
VCE が確保している書きこみバッファにデータがたまっている場合は
ネットワークへのデータ送信を試みる．
デフォルトでは，1回の vce_heartbeat
内で全てのデータをフラッシュしようとするが，
送信したい量が1回に数百KB〜数MBに達する場合などは，
送信データが OS の送信用メモリ
(Linuxの場合は，TCP用に確保されているメモリページ)を溢れさせて，
一部のコネクションの送信パフォーマンスが著しく低下してしまう場合がある．
本関数を使って，
複数回の heartbeat でコネクションをフラッシュするように調整し，
この問題を回避することができる．
ただし，1回の vce_heartbeat にかかる時間が長い場合は，
あるクライアントからみた round-trip query time は長くなる可能性がある．
本関数を使わずに，Linux自体をチューンする解決策もある．
それに関しては <a href="linuxtune.html">linuxtune.html</a> を参照.
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_read_delay"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_read_delay</th></tr>
<tr><th>概要</th><td>クライアント、サーバー間の通信の遅延をシミュレートする</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_tcpcontext_set_read_delay( tcpcontext_t tp, int min_delay_ms, int max_delay_ms , int distrib )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>遅延をシミュレートするコネクションを管理するtcpcontext
</td></tr>
<tr><th>arg 2</Th><td>int min_delay_ms</td></tr>
<tr><th></th><td>最小の遅延(ミリ秒)
</td></tr>
<tr><th>arg 3</Th><td>int max_delay_ms</td></tr>
<tr><th></th><td>最大の遅延(ミリ秒)
</td></tr>
<tr><th>arg 4</Th><td>int distrib</td></tr>
<tr><th></th><td>遅延の分布。0だと、遅延はminの値に毎回完全に一致する。
1だと、minとmaxの間がまんべんなく分布する。
2だと、ほとんどがmin付近となる(2次)
3だと、もっとほとんどがmin付近となる(3次)
<Pre>
delay = min + (max-min)*(( random() % 100 / 100.0 ) ^ distrib )
</pre>
0未満や5以上など、意味が薄い値を指定したときは、
verboseモードの場合警告を表示する。
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>VCEを使ったアプリケーションを開発するときにはLANを使用するが、
実際のインターネットの遅延をLANで再現したい場合もある。
そのような場合に、本関数を使うとその遅延をシミュレートすることができる。
本関数は、読みこみバッファのデータをパースしてcollbackを呼びだすタイミング
を制御して、アプリケーションにとっての遅延を再現する。
たとえば、普通のダイヤルアップのユーザーが体験する、
200ミリ秒から500ミリ秒の遅延が発生するようなネットワークを再現するには、
<pre>
vce_tcpcontext_set_read_delay( t, 200, 500 ,2 );
</pre>
などといった設定をすればよい。
注意点としては、vce_heartbeat を十分頻繁に呼びだせない場合は、
遅延の設定値を小さくしても意味がなくなる事である。
</td></tr>
<tr><th>知られているバグやTODO</th><td>現在実装されている遅延シミュレータは非常に単純なものであり、
将来はもっと本格的な遅延シミュレータをサポートする予定である。
その場合は本関数の引数が増えるか、設定値の意味が変化する可能性がある。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_timeout_control"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_timeout_control</th></tr>
<tr><th>概要</th><td>TCPコンテキストのタイムアウト動作方式を設定する。</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>void vce_tcpcontext_timeout_control( tcpcontext_t tp, int recv_reset, int send_reset )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t t</td></tr>
<tr><th></th><td>設定したいTCPコンテキスト
</td></tr>
<tr><th>arg 2</Th><td>int recv_reset</td></tr>
<tr><th></th><td>クライアントから受信したときにタイムアウトカウンタを初期化するかどうか
のフラグ。通常は1にしておく。
</td></tr>
<tr><th>arg 3</Th><td>int send_reset</td></tr>
<tr><th></th><td>クライアントへ送信が成功したときにタイムアウトカウンタを初期化するかどうか
のフラグ。デフォルトはゼロで、アプリケーションによっては1にする場合もある。
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>VCE は、TCP セッションにおいて一定時間アクセスがないとタイムアウトさせて
closewatcher を呼びだす機能を持っている。
何らかのデータを送信したり受信したときにタイムアウトのためのカウンタを
初期化するが、
この関数では、送信/受信 成功のときに実際にタイムアウトカウンタをゼロに
戻すかどうかの設定ができる。
VCE はデフォルト状態では、recv_reset=1, send_reset=0 となっている。
つまり、送信に成功しても、タイムアウトカウンタをリセットしない。
この事により、クライアントからは、タイムアウト時間内に最低1個は、
パケットが送られて来ないとタイムアウトしてしまう。
VCE がターゲットとしているリアルタイムアプリケーションにおいては、
このような動作がデフォルトであるほうが自然である。
本関数は、滅多に使われることはない。
</td></tr>
<tr><th>使用例</th><td>  vce_tcpcontext_timeout_control( t, 1, 1 );
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_use_filter_file"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_use_filter_file</th></tr>
<tr><th>概要</th><td>TCPコンテキストのIPフィルタの設定をファイルから入力する</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_tcpcontext_use_filter_file( tcpcontext_t tp, const char *path )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>設定するTCPコンテキスト
</td></tr>
<tr><th>arg 2</Th><td>char *path</td></tr>
<tr><th></th><td>ファイルのパス
</td></tr>
<tr><th>返り値</th><td>成功したら0、失敗したら負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>テキストの設定ファイルからIPフィルターの設定を読みこんで、
TCPコンテキストのフィルター設定を完全に行なう。
conn_t, circ_t 両方とも128個づつのフィルター設定が可能である。
内部的には、 vce_tcpcontext_add_conn_ipv4_filter,
vce_tcpcontext_add_circ_ipv4_filter の2関数を呼びだすだけである。
本関数が認識できるファイルフォーマットは以下の通り。
<pre>
CONTYPE NETWORK NETMASK BASEPOLICY POLICY POLICY ...
# 行頭のシャープ記号の後は、コメントを書くことができる
# 行頭が空白文字の行も読みとばされる。
conn # このように行頭を空けて設定を書くことはできない
</pre>
すべてのトークンをスペース(0x20)で区切り、トークンは
先頭から最低4個(BASEPOLICYまでが)必要である。 VCE C言語APIにおいては、
FILTER_POLICYは OR記号で連結していくSyntaxとなっているので、
POLICYトークンは最低1個から、オプションの数だけ増えていくことができる。
ただし現在は3種類だけである。以下の説明においては、シングルクォートは
設定ファイル中には含まれないことに注意。
<pre>
CONTYPE  'conn' または 'circ' を指定する。
NETWORK  '192.168.1.0' や 'lan.some-game.net' などネットワークアドレス
NETMASK  '255.255.255.0' などネットマスクを指定する。
BASEPOLICY  accept もしくは deny を指定する。
POLICY  現在は log を指定可能である。
</pre>
以下にconnをlocalhostからの接続に限る場合の設定例を示す。
<pre>
conn localhost 255.255.255.255 accept
</pre>
以下は、connはLAN からのみ接続可能でログし(中継サーバの使用を意識している)、
circは日本(202.と 210.)に限定するがログしない場合の設定を示す。
<pre>
conn 192.168.1.0 255.255.255.0 accept log
circ 210.0.0.0 255.0.0.0 accept
circ 202.0.0.0 255.0.0.0 accept
</pre>
有効な1行あたり1下位の vce_tcpcontext_add_circ_ipv4_filter または
vce_tcpcontext_add_conn_ipv4_filter 関数が呼びだされるので、
vce_tcpcontext_add_circ_ipv4_filter,vce_tcpcontext_add_conn_ipv4_filter の
2関数の特徴通り、設定ファイルの設定行が一つでも有効になっていれば
基本的にすべての接続がデフォルトでDENYになることに注意が必要である。
また本関数を呼びだすとまず最初にすべての設定をクリアしてから、
ファイルの中身を実行する。既存の設定が存在する場合は注意が必要である。
ただし、ファイルの中身にフォーマット異常が発見された場合は、
クリアも設定も一切されない。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_add_circ_ipv4_filter">vce_tcpcontext_add_circ_ipv4_filter</a>
<a href="#vce_tcpcontext_add_conn_ipv4_filter">vce_tcpcontext_add_conn_ipv4_filter</a>
</td></tr>
</table><br><br>
<a name="vce_text_cmpnocase"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_text_cmpnocase</th></tr>
<tr><th>概要</th><td>大文字と小文字を区別しないC言語文字列の比較</td></tr>
<tr><th>カテゴリ</th><td>text</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_text_cmpnocase( char *s1, char *s2, int n )</b></td>
<tr><th>arg 1</Th><td>char *s1</td></tr>
<tr><th></th><td>比較する文字列の先頭アドレス、ひとつ目
</td></tr>
<tr><th>arg 2</Th><td>char *s2</td></tr>
<tr><th></th><td>比較する文字列の先頭アドレス、ふたつ目
</td></tr>
<tr><th>arg 3</Th><td>int n</td></tr>
<tr><th></th><td>何文字目まで比較するのか(バイト数)
</td></tr>
<tr><th>返り値</th><td>n文字目まで一致している場合は0、異なるなら1を返す。
辞書式の比較には使えない。
</td></tr>
<tr><th>詳細説明</th><td>HTTP では、多くの処理が Case insensitive で行なわれる必要がある。
したがって普通の strcmp は使えない。
</td></tr>
</table><br><br>
<a name="vce_text_hashpjw"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_text_hashpjw</th></tr>
<tr><th>概要</th><td>文字列を32ビット整数値にハッシュする。</td></tr>
<tr><th>カテゴリ</th><td>text</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_text_hashpjw( char *s )</b></td>
<tr><th>arg 1</Th><td>char *s</td></tr>
<tr><th></th><td>ハッシュする文字列
</td></tr>
<tr><th>返り値</th><td>ハッシュ値
</td></tr>
<tr><th>詳細説明</th><td>PJW方式でハッシュする。文字数が少ないと値も小さい。
</td></tr>
</table><br><br>
<a name="vce_text_split_index"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_text_split_index</th></tr>
<tr><th>概要</th><td>文字列をデリミタで切りとり、n番目のトークンの先頭アドレスを得る</td></tr>
<tr><th>カテゴリ</th><td>text</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>char * vce_text_split_index( char *src, char c, int index )</b></td>
<tr><th>arg 1</Th><td>char *src</td></tr>
<tr><th></th><td>元の文字列の先頭アドレス。一切書きこみされない。
</td></tr>
<tr><th>arg 2</Th><td>char c</td></tr>
<tr><th></th><td>デリミタとなる文字 例：''
</td></tr>
<tr><th>arg 3</Th><td>int index</td></tr>
<tr><th></th><td>何番目のトークンを取りだすか。0なら最初、1なら2個目
</td></tr>
<tr><th>返り値</th><td>indexが0のときsrcをそのまま返す。
デリミタがひとつもみつからない場合、srcをそのまま返す。
デリミタはあるが、トークンが足りない場合は、VCE_ENOTFOUNDエラーをセットし、
NULLを返す。
デリミタが見つかったときはその次の文字の先頭アドレスを返す
</td></tr>
<tr><th>詳細説明</th><td>先頭アドレスを返すだけであることに注意。
文字列の終端は変更されず、そのまま使用すると入力文字列の最後までが
出力に含まれることになる。これは、内部ワーキングバッフを一切使用せず、
vce_copy_cstring_upto関数と併用するのを前提としてデザインされている
ためである。
本関数はvce_text_split_index_get_string(int) 関数を作成するために
使われる。アプリケーションでは vce_text_split_index_get_string(int)
関数を使用することが推奨される。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_text_split_index_get_string">vce_text_split_index_get_string</a>
</td></tr>
</table><br><br>
<a name="vce_text_split_index_get_int"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_text_split_index_get_int</th></tr>
<tr><th>概要</th><td>文字列をデリミタで区切り、n番目の整数トークンを返す</td></tr>
<tr><th>カテゴリ</th><td>text</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_text_split_index_get_int( char *src, char c, int index, int *v )</b></td>
<tr><th>arg 1</Th><td>char *src</td></tr>
<tr><th></th><td>処理対象となる文字列の先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>char c</td></tr>
<tr><th></th><td>デリミタとなる文字
</td></tr>
<tr><th>arg 3</Th><td>int index</td></tr>
<tr><th></th><td>何番目のトークンかを指定する番号。0なら最初のトークンである
</td></tr>
<tr><th>arg 4</Th><td>int *v</td></tr>
<tr><th></th><td>出力の整数値。
</td></tr>
<tr><th>返り値</th><td>vce_text_split_index_get_string 関数と同様、トークンが見つからない場合は
VCE_ENOTFOUND を返す。
</td></tr>
<tr><th>詳細説明</th><td>1文字の同じデリミタで区切られたトークン列を分解し、int の値を取りだす。
CSV形式の数値データファイルから値を読みだすという例が最も典型的である。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_text_split_index_get_string">vce_text_split_index_get_string</a>
</td></tr>
</table><br><br>
<a name="vce_text_split_index_get_string"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_text_split_index_get_string</th></tr>
<tr><th>概要</th><td>文字列をデリミタで区切り、n番目のトークンを文字列で返す</td></tr>
<tr><th>カテゴリ</th><td>text</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_text_split_index_get_string( char *src, char c, int index, char *out, int outlen )</b></td>
<tr><th>arg 1</Th><td>char *src</td></tr>
<tr><th></th><td>元の文字列の先頭アドレス
</td></tr>
<tr><th>arg 2</Th><td>char c</td></tr>
<tr><th></th><td>デリミタの文字
</td></tr>
<tr><th>arg 3</Th><td>int index</td></tr>
<tr><th></th><td>何番目のトークンかをしめす番号。0なら最初
</td></tr>
<tr><th>arg 4</Th><td>char *out</td></tr>
<tr><th></th><td>出力バッファ
</td></tr>
<tr><th>arg 5</Th><td>int outlen</td></tr>
<tr><th></th><td>出力の最大バイト数
</td></tr>
<tr><th>返り値</th><td>トークンがみつからない場合は VCE_ENOTFOUNDを返す。
成功した場合は0以上の出力文字列の長さをかえす。
出力文字列は、 ヌル終端された、 C言語の文字列である。
</td></tr>
<tr><th>詳細説明</th><td>1文字の同じデリミタで区切られたトークン列を分解し、文字列を取りだす。
以下に示すのは、CSV形式のデータファイルからの読みだしである。
デリミタ文字を文字列データ中に含むような場合はエスケーピングが必要だが、
本関数はそのような機能は持っていない。
また，長さがゼロの文字列が切りだされることもある．
たとえば "a,b," という src 文字列があったとして， 0番目は "a",
1番目は "b" 2番目は ""， となる．この場合も out には書きこまれる．
3番目は VCE_ENOTFOUND が返され， out には書きこまれない．
</td></tr>
<tr><th>使用例</th><td><pre>
  char src[] = "My name is ringo.";
  for (i=0;;i++) {
      int r;
      char out[100];
      r = vce_text_split_index_get_string( src, ' ', i, out,sizeof(out));
      if ( r == VCE_ENOTFOUND ) break;
  }
</pre>
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_text_split_index">vce_text_split_index</a>
<a href="#vce_text_split_index_get_string">vce_text_split_index_get_string</a>
</td></tr>
</table><br><br>
<a name="vce_update_int2_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_update_int2_search</th></tr>
<tr><th>概要</th><td>2整数の検索エンジンに、「キーと値」の組を1個追加する</td></tr>
<tr><th>カテゴリ</th><td>search</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_update_int2_search( int index , int key0 , int key1 , void *pointer )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>検索エンジンを特定するためのサーチデスクリプタ
</td></tr>
<tr><th>arg 2</Th><td>int key0</td></tr>
<tr><th></th><td>検索キーとなる整数値、ひとつ目
</td></tr>
<tr><th>arg 3</Th><td>int key1</td></tr>
<tr><th></th><td>検索キーとなる整数値、ふたつ目
</td></tr>
<tr><th>arg 4</Th><td>void *pointer</td></tr>
<tr><th></th><td>検索される値を指すポインタ
</td></tr>
<tr><th>返り値</th><td>正常終了なら0、そうでないなら負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>2整数を検索キーとする検索エンジンにおいて、「検索キーと値」の組を1個
保存する。すでにおなじ検索キーが登録されている場合は、
その値を更新する。
2整数の検索エンジンは、両方の検索キーが一致してはじめてマッチする。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_delete_int2_search">vce_delete_int2_search</a>
<a href="#vce_get_int2_search">vce_get_int2_search</a>
<a href="#vce_init_int2_search">vce_init_int2_search</a>
</td></tr>
</table><br><br>
<a name="vce_update_int4_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_update_int4_search</th></tr>
<tr><th>概要</th><td>4整数の検索エンジンに、「キーと値」の組を1個追加する</td></tr>
<tr><th>カテゴリ</th><td>search</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_update_int4_search( int index , int key0 , int key1 , int key2, int key3, void *pointer )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>検索エンジンを特定するためのサーチデスクリプタ
</td></tr>
<tr><th>arg 2</Th><td>int key0</td></tr>
<tr><th></th><td>検索キーとなる整数値、ひとつ目
</td></tr>
<tr><th>arg 3</Th><td>int key1</td></tr>
<tr><th></th><td>検索キーとなる整数値、ふたつ目
</td></tr>
<tr><th>arg 4</Th><td>int key2</td></tr>
<tr><th></th><td>検索キーとなる整数値、3つ目
</td></tr>
<tr><th>arg 5</Th><td>int key3</td></tr>
<tr><th></th><td>検索キーとなる整数値、4つ目
</td></tr>
<tr><th>arg 6</Th><td>void *pointer</td></tr>
<tr><th></th><td>検索される値を指すポインタ
</td></tr>
<tr><th>返り値</th><td>正常終了なら0、そうでないなら負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>4整数を検索キーとする検索エンジンにおいて、「検索キーと値」の組を1個
保存する。すでにおなじ検索キーが登録されている場合は、
その値を更新する。
4整数の検索エンジンは、両方の検索キーが一致してはじめてマッチする。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_delete_int4_search">vce_delete_int4_search</a>
<a href="#vce_get_int4_search">vce_get_int4_search</a>
<a href="#vce_init_int4_search">vce_init_int4_search</a>
</td></tr>
</table><br><br>
<a name="vce_update_int_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_update_int_search</th></tr>
<tr><th>概要</th><td>整数キーのサーチエンジンに、「キーと値」の組を1個追加または更新する</td></tr>
<tr><th>カテゴリ</th><td>search</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_update_int_search( int index , int key , void *pointer )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>サーチエンジンを特定するサーチデスクリプタ。
vce_init_int_search の返り値である。
</td></tr>
<tr><th>arg 2</Th><td>int key</td></tr>
<tr><th></th><td>検索キーとなる値。できるだけ「まばらに」散っているほうが、
値が多くなったときでも検索の性能が落ちない。
</td></tr>
<tr><th>arg 3</Th><td>void *pointer</td></tr>
<tr><th></th><td>検索される値を指すポインタ
</td></tr>
<tr><th>返り値</th><td>エラーが発生した場合は負のエラーコードを返す。正常終了したら0を返す。
</td></tr>
<tr><th>詳細説明</th><td>整数を検索のキーとして使用する整数サーチエンジンに、「キーと値」の組を
1個追加する。すでに同じキーが登録されている場合は、値を更新する。
vce_update_int_search を呼びだしてキーと値を登録した後、
vce_get_int_search を呼びだして検索をかける。
検索の値が必要でなくなったときは、 vce_delete_int_search を呼びだす。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_int_search">vce_get_int_search</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
</td></tr>
</table><br><br>
<a name="vce_update_string_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_update_string_search</th></tr>
<tr><th>概要</th><td>文字列検索エンジンに、「キーと値」の組を1個追加、更新する</td></tr>
<tr><th>カテゴリ</th><td>search</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_update_string_search( int index , char *key , void *pointer )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>検索エンジンを特定するためのサーチデスクリプタ
</td></tr>
<tr><th>arg 2</Th><td>char *key</td></tr>
<tr><th></th><td>検索キーとなる文字列。現在のバージョンでは、先頭の32バイトしか
検索に使用されない。
</td></tr>
<tr><th>arg 3</Th><td>void *pointer</td></tr>
<tr><th></th><td>検索される値をさすポインタ
</td></tr>
<tr><th>返り値</th><td>正常終了なら0、異常終了なら負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>文字列を検索キーとする検索のために、「キーと値」の組を検索エンジンに
登録する。ハッシュ方式には、 PJW を使用している。
検索のしくみについては、 vce_init_int_search を参照。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_delete_string_search">vce_delete_string_search</a>
<a href="#vce_get_string_search">vce_get_string_search</a>
<a href="#vce_init_string_search">vce_init_string_search</a>
<a href="#vce_update_int_search">vce_update_int_search</a>
</td></tr>
</table><br><br>
<a name="vce_update_vstring_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_update_vstring_search</th></tr>
<tr><th>概要</th><td>任意長の文字列検索エンジンに，「キーと値」の組を1個追加，更新する</td></tr>
<tr><th>カテゴリ</th><td>search</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_update_vstring_search( int index, char *key, void *pointer )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>検索エンジンを特定するためのサーチデスクリプタ
</td></tr>
<tr><th>arg 2</Th><td>char *key</td></tr>
<tr><th></th><td>検索キーとなる文字列。 vce_init_vstring_search で指定した key_len
までの長さが検索に使用される．
</td></tr>
<tr><th>arg 3</Th><td>void *pointer</td></tr>
<tr><th></th><td>検索される値をさすポインタ
</td></tr>
<tr><th>返り値</th><td>正常終了なら0、異常終了なら負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>文字列を検索キーとする検索のために、「キーと値」の組を検索エンジンに
登録する。ハッシュ方式には、 PJW を使用している。
検索のしくみについては、 vce_init_int_search を参照。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_delete_vstring_search">vce_delete_vstring_search</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_init_vstring_search">vce_init_vstring_search</a>
</td></tr>
</table><br><br>
<a name="vce_utime_diff"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_utime_diff</th></tr>
<tr><th>概要</th><td>struct timeval 型の時刻の差分を VCEI64 型で求める</td></tr>
<tr><th>カテゴリ</th><td>util</td></tr>
<tr><th>対応OS</th><td>linux,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b></b></td>
<tr><th>arg 1</Th><td>struct timeval *before</td></tr>
<tr><th></th><td>差分を求める時刻のうち、前のもの。
</td></tr>
<tr><th>arg 2</Th><td>struct timeval *after</td></tr>
<tr><th></th><td>差分を求める時刻のうち、後のもの。
</td></tr>
<tr><th>返り値</th><td></td></tr>
<tr><th>詳細説明</th><td>時刻の差分をマイクロ秒に換算し、VCEI64 型に変換して返す。
この関数は BSD カーネルの time_diff 関数とまったく同じだが、
32ビットマシンで42億マイクロ秒(420秒)を越える時間を返せるように、
VCEI64型としている。
</td></tr>
</table><br><br>
<a name="vce_vec_init_mainserv"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vec_init_mainserv</th></tr>
<tr><th>概要</th><td>パケットベクトライズに対応したサーバの初期化ルーチン</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_vec_init_mainserv( tcpcontext_t tp, int maxcirc, int rbsize )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>操作対象となるTCPコンテキスト
</td></tr>
<tr><th>arg 2</Th><td>int maxcirc</td></tr>
<tr><th></th><td>1個のTCPベクトライズコネクションに含める仮想回路(circ_t)の最大数。
通常は10000以下を指定する。
</td></tr>
<tr><th>arg 3</Th><td>int rbsize</td></tr>
<tr><th></th><td>1個の仮想回路あたりの読みこみバッファ長(byte)
</td></tr>
<tr><th>返り値</th><td>成功したら0、失敗したら負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>パケットベクトライズに対応したサーバにおいて、
VCEに内蔵されているベクトライズルーチンで必要な初期化を行なう。
この初期化をすることによって、指定されたTCPコンテキストが管理する
コネクションの中に複数の仮想回路を含めることができる。
VCE仮想回路(circ_t)を利用するすべてのアプリケーションは、
vce_tcpcontext_create 関数のよび出し後、
本関数を使用して適切に仮想回路処理ルーチンを
TCPコンテキストに組みこまなければならない。
<BR>
注意<BR>
本関数を使って circ を有効にする場合は，
ベクトライズを担当する中継サーバとのコネクションにわりあてる
書きこみバッファのサイズを大きくしておく必要がある．
現在の VCE ではその値は 32768 で(今後変更の可能性がある)，
書きこみバッファの残りがそれより小さい量の場合は，
ネットワークの状況に関係なく書きこみが失敗する可能性がある．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_vec_setup_linkage"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vec_setup_linkage</th></tr>
<tr><th>概要</th><td>パケットベクトライザをサーバコネクションに結びつける</td></tr>
<tr><th>カテゴリ</th><td>tcp</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_vec_setup_linkage( tcpcontext_t tp, conn_t cp )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>TCPコンテキストへのポインタ
</td></tr>
<tr><th>arg 2</Th><td>conn_t cp</td></tr>
<tr><th></th><td>結びつけるコネクション。サーバに対してつながっていることが必要である。
</td></tr>
<tr><th>返り値</th><td>正常終了なら0、失敗なら負のエラーコードを返す
</td></tr>
<tr><th>詳細説明</th><td>クライアントからの接続を受けつけるためのサーバTCPコンテキストの初期化時に
パケットベクトライザプロトコルのパーザを登録し、
さらに初期化の次の段階として、どのサーバコネクションをベクトライズの
出力用コネクションとするかを指定する。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_vecprotocol_acceptwatcher_deny"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vecprotocol_acceptwatcher_deny</th></tr>
<tr><th>概要</th><td>すべてのコネクションを拒否する仮想回路(circ_t)用のaccept監視関数</td></tr>
<tr><th>カテゴリ</th><td>watcher</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_vecprotocol_acceptwatcher_deny( circ_t c )</b></td>
<tr><th>arg 1</Th><td>circ_t c</td></tr>
<tr><th></th><td>ベクトライズサーバが新規に accept したコネクションをあらわす circ_t
</td></tr>
<tr><th>返り値</th><td>この関数はつねに負を返す。
</td></tr>
<tr><th>詳細説明</th><td>この関数は tcpcontext_create の引数に指定し、指定すると
すべての仮想回路のコネクション要求を拒否するようになる。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_vecprotocol_acceptwatcher_noop">vce_vecprotocol_acceptwatcher_noop</a>
</td></tr>
</table><br><br>
<a name="vce_vecprotocol_acceptwatcher_noop"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vecprotocol_acceptwatcher_noop</th></tr>
<tr><th>概要</th><td>すべてのコネクションを受けいれる仮想回路(circ_t)のaccept監視関数</td></tr>
<tr><th>カテゴリ</th><td>watcher</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_vecprotocol_acceptwatcher_noop( circ_t c )</b></td>
<tr><th>arg 1</Th><td>circ_t c</td></tr>
<tr><th></th><td>ベクトライズサーバが新規に accept したコネクションをあらわす circ_t
</td></tr>
<tr><th>返り値</th><td>この関数は常に0を返す。
</td></tr>
<tr><th>詳細説明</th><td>tcpcontext_create の引数のうち ベクトライズサーバ用の accept 監視関数
として指定される。指定されると、すべてのコネクションを受けいれるようになる。
これはデフォルト(NULLを指定したとき)と同じ動作である。
明示的に指定することによってコードが見やすくする効果がある。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_vecprotocol_acceptwatcher_deny">vce_vecprotocol_acceptwatcher_deny</a>
</td></tr>
</table><br><br>
<a name="vce_vecprotocol_closewatcher_noop"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vecprotocol_closewatcher_noop</th></tr>
<tr><th>概要</th><td>何もしない仮想回路の close 監視関数</td></tr>
<tr><th>カテゴリ</th><td>watcher</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_vecprotocol_closewatcher_noop( circ_t c )</b></td>
<tr><th>arg 1</Th><td>circ_t c</td></tr>
<tr><th></th><td>閉じられようとしている仮想回路(閉じる直前)
</td></tr>
<tr><th>返り値</th><td>常に0を返す
</td></tr>
<tr><th>詳細説明</th><td>vce_tcpcontext_create の引数のうち ベクトライズサーバ用の close 監視関数
として指定される関数のひとつ。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_vecprotocol_parser_bin16"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vecprotocol_parser_bin16</th></tr>
<tr><th>概要</th><td>仮想回路(circ_t)用の bin16 プロトコルレコードパーサ</td></tr>
<tr><th>カテゴリ</th><td>parser</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_vecprotocol_parser_bin16( circ_t cir )</b></td>
<tr><th>arg 1</Th><td>circ_t cir</td></tr>
<tr><th></th><td>処理対象となる仮想回路 へのポインタ
</td></tr>
<tr><th>返り値</th><td>コールバックが負を返した値をそのままかえす
</td></tr>
<tr><th>詳細説明</th><td>1個のTCPコネクションに含まれる仮想回路(circ_t)の入力データレコード
を取りだし、あらかじめ vce_tcpcontext_create 関数の呼びだし時に指定されて
いるコールバック関数を呼びだす。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_parser_bin16">vce_protocol_parser_bin16</a>
<a href="#vce_vecprotocol_unparser_bin16">vce_vecprotocol_unparser_bin16</a>
</td></tr>
</table><br><br>
<a name="vce_vecprotocol_parser_bin32"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vecprotocol_parser_bin32</th></tr>
<tr><th>概要</th><td>仮想回路(circ_t)用のBIN32パーサ</td></tr>
<tr><th>カテゴリ</th><td>parser</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_vecprotocol_parser_bin32( circ_t cir )</b></td>
<tr><th>arg 1</Th><td>circ_t cir</td></tr>
<tr><th></th><td>レコード取りだし対象となる仮想回路
</td></tr>
<tr><th>返り値</th><td>データが不足している場合は0、
データが不正な場合は負のエラーコード、
レコード取りだしに成功した場合は、コールバック関数の戻り値をそのまま返す。
</td></tr>
<tr><th>詳細説明</th><td>仮想回路の入力を解析し、Bin32レコードを取りだす。
この関数が負を返した場合は、VCEは接続を切断する。
Bin32は長さフィールドが32ビット長であるので、
理論的には 4GBまでのレコードを通信できる。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_vecprotocol_parser_bin16">vce_vecprotocol_parser_bin16</a>
</td></tr>
</table><br><br>
<a name="vce_vecprotocol_parser_text"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vecprotocol_parser_text</th></tr>
<tr><th>概要</th><td>仮想回路用の text プロトコルレコードパーサ</td></tr>
<tr><th>カテゴリ</th><td>parser</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_vecprotocol_parser_text( circ_t cir )</b></td>
<tr><th>arg 1</Th><td>circ_t cir</td></tr>
<tr><th></th><td>処理対象となる仮想回路へのポインタ
</td></tr>
<tr><th>返り値</th><td>コールバックの返した値をそのまま返す
</td></tr>
<tr><th>詳細説明</th><td>仮想回路に入力されたデータから1行のレコードを取りだして、
改行記号を含まない部分をコールバック関数に渡す。
改行記号とは、 "\r\n" もしくは "\n" である。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_parser_text">vce_protocol_parser_text</a>
</td></tr>
</table><br><br>
<a name="vce_vecprotocol_parser_through"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vecprotocol_parser_through</th></tr>
<tr><th>概要</th><td>仮想回路(circ_t)用の、何もしないスルーパーサ</td></tr>
<tr><th>カテゴリ</th><td>parser</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_vecprotocol_parser_through( circ_t cir )</b></td>
<tr><th>arg 1</Th><td>circ_t cir</td></tr>
<tr><th></th><td>処理対象となる仮想回路へのポインタ
</td></tr>
<tr><th>返り値</th><td>コールバックが返した値をそのまま返す。
</td></tr>
<tr><th>詳細説明</th><td>仮想回路の入力に対して何の処理もせずにコールバック関数に渡す。
レコードという概念が必要ないプロトコルでは意味がある
(単にログをたれ流して受けとるサーバなど)が、ほとんどのプロトコルでは
レコードを定義して処理をする。利用頻度は少ない。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_parser_through">vce_protocol_parser_through</a>
</td></tr>
</table><br><br>
<a name="vce_vecprotocol_pcallback_echo_bin16"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vecprotocol_pcallback_echo_bin16</th></tr>
<tr><th>概要</th><td>パケットベクトライザ用の、エコーコールバック関数(bin16出力)</td></tr>
<tr><th>カテゴリ</th><td>pcallback</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_vecprotocol_pcallback_echo_bin16( circ_t ct, char *data, int len )</b></td>
<tr><th>arg 1</Th><td>circ_t</td></tr>
<tr><th></th><td>入出力対象の仮想回路(circ_t)
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>入力データの先頭アドレス
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>入力データの長さ(バイト数)
</td></tr>
<tr><th>返り値</th><td>送信できた長さを返す
</td></tr>
<tr><th>詳細説明</th><td>VCEではパケットベクトライズを用いて1本のTCPコネクション(conn_t)の中に
仮想回路(circ_t)を含めることができるが、本関数ではその仮想回路への
入力をそのままエコーバックする。
アプリケーションのデバッグ用に使用することができる。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_pcallback_dump">vce_protocol_pcallback_dump</a>
<a href="#vce_protocol_pcallback_echo_bin16">vce_protocol_pcallback_echo_bin16</a>
<a href="#vce_protocol_pcallback_noop">vce_protocol_pcallback_noop</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_vecprotocol_pcallback_echo_text"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vecprotocol_pcallback_echo_text</th></tr>
<tr><th>概要</th><td>パケットベクトライザ用の、text出力のエコーコールバック関数</td></tr>
<tr><th>カテゴリ</th><td>pcallback</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_vecprotocol_pcallback_echo_text(circ_t ct,char*data,int len)</b></td>
<tr><th>arg 1</Th><td>circ_t ct</td></tr>
<tr><th></th><td>入出力対象となる仮想回路
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>仮想回路からの入力データの先頭アドレス
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>入力データの長さ
</td></tr>
<tr><th>返り値</th><td>仮想回路に書きこめたデータの長さ
</td></tr>
<tr><th>詳細説明</th><td>仮想回路用のエコーコールバック関数．text プロトコルでエコーする。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_vecprotocol_pcallback_echo_bin16">vce_vecprotocol_pcallback_echo_bin16</a>
</td></tr>
</table><br><br>
<a name="vce_vecprotocol_unparser_bin16"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vecprotocol_unparser_bin16</th></tr>
<tr><th>概要</th><td>TCPコネクション内の仮想回路circ_t に対してbin16レコードを書きこむ</td></tr>
<tr><th>カテゴリ</th><td>parser</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_vecprotocol_unparser_bin16( circ_t ct, char *data , int len )</b></td>
<tr><th>arg 1</Th><td>circ_t ct</td></tr>
<tr><th></th><td>書きこむ先の仮想回路 circ_t
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>書きこみたいデータへのポインタ
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>書きこみたいデータの長さ
</td></tr>
<tr><th>返り値</th><td>成功なら書きこんだデータの長さ(len) +2 、
失敗なら負のエラーコードを返す。
</td></tr>
<tr><th>詳細説明</th><td>vce_vecprotocol_unparser_bin16 関数は、bin16フォーマットにしたがった
データレコードを circ_t に対して書きこむ。 circ_t が何を意味するのか
については、 tcpカテゴリの関数群の説明を参照。
bin16プロトコルのデータレコードは、2バイトの長さフィールドを含むので、
実際に書きこめた長さ(返り値)は、書きこもうとしたデータの長さよりも
2だけ多くなる．さらに，SWPを介した通信では，
SWP との通信に必要な情報が付加されるため，
最適化の状況によるが数バイトから数十バイト多くなることがある．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_vecprotocol_parser_bin16">vce_vecprotocol_parser_bin16</a>
</td></tr>
</table><br><br>
<a name="vce_vecprotocol_unparser_bin32"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vecprotocol_unparser_bin32</th></tr>
<tr><th>概要</th><td>仮想回路circ_tに対して BIN32プロトコルのレコードをひとつ書きこむ</td></tr>
<tr><th>カテゴリ</th><td>parser</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_vecprotocol_unparser_bin32( circ_t ct, char *data, int len )</b></td>
<tr><th>arg 1</Th><td>circ_t ct</td></tr>
<tr><th></th><td>書きこみ先の仮想回路
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>書きこみたいデータの先頭アドレス
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>書きこむデータの長さ(バイト)
</td></tr>
<tr><th>返り値</th><td>成功なら書きこんだデータの長さを返す。
失敗の場合は負のエラーコードを返す。
</td></tr>
<tr><th>詳細説明</th><td>32ビットの長さ(つまり4GB)のデータレコードまでを書きこむことができる。
返り値の特性に関しては vce_vecprotocol_unparser_bin16 関数を参照．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_vecprotocol_unparser_bin16">vce_vecprotocol_unparser_bin16</a>
</td></tr>
</table><br><br>
<a name="vce_vecprotocol_unparser_text"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vecprotocol_unparser_text</th></tr>
<tr><th>概要</th><td>仮想回路circ_tに対してtextプロトコルの1レコードを書きこむ</td></tr>
<tr><th>カテゴリ</th><td>parser</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_vecprotocol_unparser_text( circ_t ct, char *data, int len )</b></td>
<tr><th>arg 1</Th><td>circ_t ct</td></tr>
<tr><th></th><td>出力対象となる仮想回路
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>書きこむデータ。
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>書きこむデータの長さ
</td></tr>
<tr><th>返り値</th><td></td></tr>
<tr><th>詳細説明</th><td>改行記号である"\n" や "\r"もエスケープなどの処理を一切せずに
そのまま書きこむので注意が必要である。
また、データの末尾に "\n" を追加して送信するので、
送信バイト数は、成功の場合 len よりも1多い値となる。
それ以外の返り値の特性に関しては
vce_vecprotocol_unparser_bin16 関数を参照．
</td></tr>
<tr><th>See also</th><td>
<a href="# vce_vecprotocol_unparser_bin16"> vce_vecprotocol_unparser_bin16</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_vecprotocol_unparser_through"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vecprotocol_unparser_through</th></tr>
<tr><th>概要</th><td>仮想回路(circ_t)に対して、レコード境界なしで生データを書きこむ</td></tr>
<tr><th>カテゴリ</th><td>parser</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_vecprotocol_unparser_through( circ_t ct, char *data, int len )</b></td>
<tr><th>arg 1</Th><td>circ_t ct</td></tr>
<tr><th></th><td>書きこみ対象となる仮想回路
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>書きこむデータの先頭アドレス
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>書きこむデータの長さ
</td></tr>
<tr><th>返り値</th><td>書きこむことができた長さを返す。
失敗の場合は負のエラーコードが返る
</td></tr>
<tr><th>詳細説明</th><td>データに対して何の処理もせずに仮想回路に対して書きこむ。
長さ分だけ書きこむか、何も書きこまずに失敗するか、どちらかである。
返り値の特性に関しては
vce_vecprotocol_unparser_bin16 関数を参照．
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_vecprotocol_unparser_bin16">vce_vecprotocol_unparser_bin16</a>
<a href="#vce_vecprotocol_unparser_text">vce_vecprotocol_unparser_text</a>
</td></tr>
</table><br><br>
<a name="vce_verrout"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_verrout</th></tr>
<tr><th>概要</th><td>VCEのログ出力をする。可変引数ではなくva_listを引数に持った物。</td></tr>
<tr><th>カテゴリ</th><td>core</td></tr>
<tr><th>対応OS</th><td>linux,win32,other,darwin</td></tr>
<tr><th>関数プロトタイプ</th><td><b>int vce_verrout( const char *format, va_list arg )</b></td>
<tr><th>arg 1</Th><td>char *format</td></tr>
<tr><th></th><td>フォーマット文字列。 printf のものと同じ
</td></tr>
<tr><th>arg 2</Th><td>va_list arg</td></tr>
<tr><th></th><td>va_listによる引数。
</td></tr>
<tr><th>返り値</th><td>なし
</td></tr>
<tr><th>詳細説明</th><td>文字列を標準エラー出力に表示する。仕様はvce_errout()と同じ。
可変引数ではなく、va_listによる引数に対応したもの。
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_errout_config">vce_errout_config</a>
<a href="#vce_errout_v">vce_errout_v</a>
</td></tr>
</table><br><br>
<!-- make_funcdef end -->
<BR><BR>
<p><a href="index.html">indexに戻る</a><br></p>
<div id="footer">
Copyright 2000-2005 Community Engine Inc. All rights reserved.
</div>
</body>
</html>
