<html>
<head>
<link rel="stylesheet" href="../vce.css" type="text/css">
<title> VCE-SDK API Reference Manual </title>
</head>
<body>
<h1> VCE-SDK API Reference Manual </h1>
<h2>Categories</h2>
<!-- make_categoryindexindex -->
<ol>
<li><a href="#analyzer">analyzer</a></li>
<li><a href="#array">array</a></li>
<li><a href="#bin">bin</a></li>
<li><a href="#core">core</a></li>
<li><a href="#err">err</a></li>
<li><a href="#log">log</a></li>
<li><a href="#logwriter">logwriter</a></li>
<li><a href="#monitor">monitor</a></li>
<li><a href="#parser">parser</a></li>
<li><a href="#pcallback">pcallback</a></li>
<li><a href="#profiler">profiler</a></li>
<li><a href="#search">search</a></li>
<li><a href="#task">task</a></li>
<li><a href="#tcp">tcp</a></li>
<li><a href="#text">text</a></li>
<li><a href="#util">util</a></li>
<li><a href="#watcher">watcher</a></li>
</ol>
<h2>Function index by name</h2>
<!-- make_nameindex -->
<ol>
<li><a href="#ARRAY_SCAN">ARRAY_SCAN</a></li>
<li><a href="#ARRAY_SCAN_TYPE">ARRAY_SCAN_TYPE</a></li>
<li><a href="#ELEMENTOF">ELEMENTOF</a></li>
<li><a href="#FREE">FREE</a></li>
<li><a href="#GET_16BIT_INT">GET_16BIT_INT</a></li>
<li><a href="#GET_16BIT_NATIVEINT">GET_16BIT_NATIVEINT</a></li>
<li><a href="#GET_32BIT_INT">GET_32BIT_INT</a></li>
<li><a href="#GET_32BIT_NATIVEINT">GET_32BIT_NATIVEINT</a></li>
<li><a href="#GET_64BIT_INT">GET_64BIT_INT</a></li>
<li><a href="#GET_64BIT_NATIVEINT">GET_64BIT_NATIVEINT</a></li>
<li><a href="#GET_8BIT_INT">GET_8BIT_INT</a></li>
<li><a href="#GET_8BIT_NATIVEINT">GET_8BIT_NATIVEINT</a></li>
<li><a href="#MALLOC">MALLOC</a></li>
<li><a href="#MAX">MAX</a></li>
<li><a href="#MIN">MIN</a></li>
<li><a href="#SET_16BIT_INT">SET_16BIT_INT</a></li>
<li><a href="#SET_16BIT_NATIVEINT">SET_16BIT_NATIVEINT</a></li>
<li><a href="#SET_32BIT_INT">SET_32BIT_INT</a></li>
<li><a href="#SET_32BIT_NATIVEINT">SET_32BIT_NATIVEINT</a></li>
<li><a href="#SET_64BIT_INT">SET_64BIT_INT</a></li>
<li><a href="#SET_64BIT_NATIVEINT">SET_64BIT_NATIVEINT</a></li>
<li><a href="#SET_8BIT_INT">SET_8BIT_INT</a></li>
<li><a href="#SET_8BIT_NATIVEINT">SET_8BIT_NATIVEINT</a></li>
<li><a href="#STRERR">STRERR</a></li>
<li><a href="#vce_alloc_array_object">vce_alloc_array_object</a></li>
<li><a href="#vce_analyzer_analyze">vce_analyzer_analyze</a></li>
<li><a href="#vce_analyzer_clear">vce_analyzer_clear</a></li>
<li><a href="#vce_analyzer_get_state_string">vce_analyzer_get_state_string</a></li>
<li><a href="#vce_analyzer_init">vce_analyzer_init</a></li>
<li><a href="#vce_array_object_inuse">vce_array_object_inuse</a></li>
<li><a href="#vce_atoi">vce_atoi</a></li>
<li><a href="#vce_binary_pack">vce_binary_pack</a></li>
<li><a href="#vce_binary_pop_nb_i1">vce_binary_pop_nb_i1</a></li>
<li><a href="#vce_binary_pop_nb_i2">vce_binary_pop_nb_i2</a></li>
<li><a href="#vce_binary_pop_nb_i4">vce_binary_pop_nb_i4</a></li>
<li><a href="#vce_binary_pop_nb_i8">vce_binary_pop_nb_i8</a></li>
<li><a href="#vce_binary_pop_nb_ia1">vce_binary_pop_nb_ia1</a></li>
<li><a href="#vce_binary_pop_nb_ia2">vce_binary_pop_nb_ia2</a></li>
<li><a href="#vce_binary_pop_nb_ia4">vce_binary_pop_nb_ia4</a></li>
<li><a href="#vce_binary_pop_nb_ia8">vce_binary_pop_nb_ia8</a></li>
<li><a href="#vce_binary_pop_nb_stra">vce_binary_pop_nb_stra</a></li>
<li><a href="#vce_binary_push_nb_i1">vce_binary_push_nb_i1</a></li>
<li><a href="#vce_binary_push_nb_i2">vce_binary_push_nb_i2</a></li>
<li><a href="#vce_binary_push_nb_i4">vce_binary_push_nb_i4</a></li>
<li><a href="#vce_binary_push_nb_i8">vce_binary_push_nb_i8</a></li>
<li><a href="#vce_binary_push_nb_ia1">vce_binary_push_nb_ia1</a></li>
<li><a href="#vce_binary_push_nb_ia2">vce_binary_push_nb_ia2</a></li>
<li><a href="#vce_binary_push_nb_ia4">vce_binary_push_nb_ia4</a></li>
<li><a href="#vce_binary_push_nb_ia8">vce_binary_push_nb_ia8</a></li>
<li><a href="#vce_binary_push_nb_stra">vce_binary_push_nb_stra</a></li>
<li><a href="#vce_binary_unpack">vce_binary_unpack</a></li>
<li><a href="#vce_chop_string_destroy">vce_chop_string_destroy</a></li>
<li><a href="#vce_circ_clear">vce_circ_clear</a></li>
<li><a href="#vce_circ_close">vce_circ_close</a></li>
<li><a href="#vce_circ_get_index">vce_circ_get_index</a></li>
<li><a href="#vce_circ_get_parent_conn">vce_circ_get_parent_conn</a></li>
<li><a href="#vce_circ_get_remote_addr_string">vce_circ_get_remote_addr_string</a></li>
<li><a href="#vce_circ_get_remote_ipv4_addr">vce_circ_get_remote_ipv4_addr</a></li>
<li><a href="#vce_circ_get_remote_ipv4_addr_string">vce_circ_get_remote_ipv4_addr_string</a></li>
<li><a href="#vce_circ_get_remote_ipv6_addr">vce_circ_get_remote_ipv6_addr</a></li>
<li><a href="#vce_circ_get_remote_ipv6_addr_string">vce_circ_get_remote_ipv6_addr_string</a></li>
<li><a href="#vce_circ_get_state_buffer">vce_circ_get_state_buffer</a></li>
<li><a href="#vce_circ_get_struct_from_index">vce_circ_get_struct_from_index</a></li>
<li><a href="#vce_circ_get_tcpcontext">vce_circ_get_tcpcontext</a></li>
<li><a href="#vce_circ_is_equal">vce_circ_is_equal</a></li>
<li><a href="#vce_circ_is_valid">vce_circ_is_valid</a></li>
<li><a href="#vce_circ_set_alarmwatcher">vce_circ_set_alarmwatcher</a></li>
<li><a href="#vce_circ_set_timeout">vce_circ_set_timeout</a></li>
<li><a href="#vce_circ_switch">vce_circ_switch</a></li>
<li><a href="#vce_circ_test_sanity">vce_circ_test_sanity</a></li>
<li><a href="#vce_circ_writable">vce_circ_writable</a></li>
<li><a href="#vce_circ_write">vce_circ_write</a></li>
<li><a href="#vce_cleanup_all_search_engine">vce_cleanup_all_search_engine</a></li>
<li><a href="#vce_cleanup_search_engine">vce_cleanup_search_engine</a></li>
<li><a href="#vce_conn_break_heartbeat">vce_conn_break_heartbeat</a></li>
<li><a href="#vce_conn_clear">vce_conn_clear</a></li>
<li><a href="#vce_conn_close">vce_conn_close</a></li>
<li><a href="#vce_conn_close_tcpcontext_all">vce_conn_close_tcpcontext_all</a></li>
<li><a href="#vce_conn_get_buffer">vce_conn_get_buffer</a></li>
<li><a href="#vce_conn_get_child_circ">vce_conn_get_child_circ</a></li>
<li><a href="#vce_conn_get_index">vce_conn_get_index</a></li>
<li><a href="#vce_conn_get_local_addr_string">vce_conn_get_local_addr_string</a></li>
<li><a href="#vce_conn_get_local_ipv4_addr">vce_conn_get_local_ipv4_addr</a></li>
<li><a href="#vce_conn_get_local_ipv4_addr_string">vce_conn_get_local_ipv4_addr_string</a></li>
<li><a href="#vce_conn_get_local_ipv6_addr">vce_conn_get_local_ipv6_addr</a></li>
<li><a href="#vce_conn_get_local_ipv6_addr_string">vce_conn_get_local_ipv6_addr_string</a></li>
<li><a href="#vce_conn_get_remote_addr_string">vce_conn_get_remote_addr_string</a></li>
<li><a href="#vce_conn_get_remote_ipv4_addr">vce_conn_get_remote_ipv4_addr</a></li>
<li><a href="#vce_conn_get_remote_ipv4_addr_string">vce_conn_get_remote_ipv4_addr_string</a></li>
<li><a href="#vce_conn_get_remote_ipv6_addr">vce_conn_get_remote_ipv6_addr</a></li>
<li><a href="#vce_conn_get_remote_ipv6_addr_string">vce_conn_get_remote_ipv6_addr_string</a></li>
<li><a href="#vce_conn_get_stat">vce_conn_get_stat</a></li>
<li><a href="#vce_conn_get_state_buffer">vce_conn_get_state_buffer</a></li>
<li><a href="#vce_conn_get_struct_from_index">vce_conn_get_struct_from_index</a></li>
<li><a href="#vce_conn_get_tcpcontext">vce_conn_get_tcpcontext</a></li>
<li><a href="#vce_conn_is_equal">vce_conn_is_equal</a></li>
<li><a href="#vce_conn_is_valid">vce_conn_is_valid</a></li>
<li><a href="#vce_conn_set_alarmwatcher">vce_conn_set_alarmwatcher</a></li>
<li><a href="#vce_conn_set_delay">vce_conn_set_delay</a></li>
<li><a href="#vce_conn_set_parser">vce_conn_set_parser</a></li>
<li><a href="#vce_conn_set_timeout">vce_conn_set_timeout</a></li>
<li><a href="#vce_conn_show_stat">vce_conn_show_stat</a></li>
<li><a href="#vce_conn_shrink_readbuf">vce_conn_shrink_readbuf</a></li>
<li><a href="#vce_conn_writable">vce_conn_writable</a></li>
<li><a href="#vce_conn_write">vce_conn_write</a></li>
<li><a href="#vce_conn_writed">vce_conn_writed</a></li>
<li><a href="#vce_copy_cstring">vce_copy_cstring</a></li>
<li><a href="#vce_copy_cstring_upto">vce_copy_cstring_upto</a></li>
<li><a href="#vce_decode_buffer_by_blowfish">vce_decode_buffer_by_blowfish</a></li>
<li><a href="#vce_decode_buffer_by_rijndael">vce_decode_buffer_by_rijndael</a></li>
<li><a href="#vce_delete_int2_search">vce_delete_int2_search</a></li>
<li><a href="#vce_delete_int4_search">vce_delete_int4_search</a></li>
<li><a href="#vce_delete_int_search">vce_delete_int_search</a></li>
<li><a href="#vce_delete_string_search">vce_delete_string_search</a></li>
<li><a href="#vce_delete_vstring_search">vce_delete_vstring_search</a></li>
<li><a href="#vce_descape_string">vce_descape_string</a></li>
<li><a href="#vce_dump_buffer">vce_dump_buffer</a></li>
<li><a href="#vce_encode_buffer_by_blowfish">vce_encode_buffer_by_blowfish</a></li>
<li><a href="#vce_encode_buffer_by_rijndael">vce_encode_buffer_by_rijndael</a></li>
<li><a href="#vce_end_all_array">vce_end_all_array</a></li>
<li><a href="#vce_end_array">vce_end_array</a></li>
<li><a href="#vce_errout">vce_errout</a></li>
<li><a href="#vce_errout0">vce_errout0</a></li>
<li><a href="#vce_errout0_v">vce_errout0_v</a></li>
<li><a href="#vce_errout_config">vce_errout_config</a></li>
<li><a href="#vce_errout_set_another">vce_errout_set_another</a></li>
<li><a href="#vce_errout_v">vce_errout_v</a></li>
<li><a href="#vce_escape_string">vce_escape_string</a></li>
<li><a href="#vce_extract_data_from_hex_text">vce_extract_data_from_hex_text</a></li>
<li><a href="#vce_finalize">vce_finalize</a></li>
<li><a href="#vce_free_array_object">vce_free_array_object</a></li>
<li><a href="#vce_free_array_object_all">vce_free_array_object_all</a></li>
<li><a href="#vce_get_array_maxnum">vce_get_array_maxnum</a></li>
<li><a href="#vce_get_array_member_size">vce_get_array_member_size</a></li>
<li><a href="#vce_get_array_object_index">vce_get_array_object_index</a></li>
<li><a href="#vce_get_array_object_last">vce_get_array_object_last</a></li>
<li><a href="#vce_get_array_object_next">vce_get_array_object_next</a></li>
<li><a href="#vce_get_array_object_pointer_by_index">vce_get_array_object_pointer_by_index</a></li>
<li><a href="#vce_get_array_object_pointer_by_index_only_used">vce_get_array_object_pointer_by_index_only_used</a></li>
<li><a href="#vce_get_array_object_top">vce_get_array_object_top</a></li>
<li><a href="#vce_get_array_usenum">vce_get_array_usenum</a></li>
<li><a href="#vce_get_current_utime">vce_get_current_utime</a></li>
<li><a href="#vce_get_int2_or_search">vce_get_int2_or_search</a></li>
<li><a href="#vce_get_int2_search">vce_get_int2_search</a></li>
<li><a href="#vce_get_int4_or_search">vce_get_int4_or_search</a></li>
<li><a href="#vce_get_int4_search">vce_get_int4_search</a></li>
<li><a href="#vce_get_int_search">vce_get_int_search</a></li>
<li><a href="#vce_get_ipv4_addr_by_name">vce_get_ipv4_addr_by_name</a></li>
<li><a href="#vce_get_last_error">vce_get_last_error</a></li>
<li><a href="#vce_get_netstat_string">vce_get_netstat_string</a></li>
<li><a href="#vce_get_search_usenum">vce_get_search_usenum</a></li>
<li><a href="#vce_get_stat">vce_get_stat</a></li>
<li><a href="#vce_get_string_search">vce_get_string_search</a></li>
<li><a href="#vce_get_tcp_packet_read_size">vce_get_tcp_packet_read_size</a></li>
<li><a href="#vce_get_tcp_packet_write_size">vce_get_tcp_packet_write_size</a></li>
<li><a href="#vce_get_version">vce_get_version</a></li>
<li><a href="#vce_get_vstring_search">vce_get_vstring_search</a></li>
<li><a href="#vce_heartbeat">vce_heartbeat</a></li>
<li><a href="#vce_httptext_divide_header_and_content">vce_httptext_divide_header_and_content</a></li>
<li><a href="#vce_httptext_get_header_info">vce_httptext_get_header_info</a></li>
<li><a href="#vce_if_included_in_array">vce_if_included_in_array</a></li>
<li><a href="#vce_init_array">vce_init_array</a></li>
<li><a href="#vce_init_int2_search">vce_init_int2_search</a></li>
<li><a href="#vce_init_int4_search">vce_init_int4_search</a></li>
<li><a href="#vce_init_int_search">vce_init_int_search</a></li>
<li><a href="#vce_init_limit_t">vce_init_limit_t</a></li>
<li><a href="#vce_init_string_search">vce_init_string_search</a></li>
<li><a href="#vce_init_vstring_search">vce_init_vstring_search</a></li>
<li><a href="#vce_initialize">vce_initialize</a></li>
<li><a href="#vce_initialize_limited">vce_initialize_limited</a></li>
<li><a href="#vce_istore_init">vce_istore_init</a></li>
<li><a href="#vce_istore_load">vce_istore_load</a></li>
<li><a href="#vce_istore_save">vce_istore_save</a></li>
<li><a href="#vce_iterate_int2_search">vce_iterate_int2_search</a></li>
<li><a href="#vce_iterate_int4_search">vce_iterate_int4_search</a></li>
<li><a href="#vce_limit_clear">vce_limit_clear</a></li>
<li><a href="#vce_log_add_monitor_command">vce_log_add_monitor_command</a></li>
<li><a href="#vce_log_add_type">vce_log_add_type</a></li>
<li><a href="#vce_log_get_types">vce_log_get_types</a></li>
<li><a href="#vce_log_gettime_long">vce_log_gettime_long</a></li>
<li><a href="#vce_log_gettime_normal">vce_log_gettime_normal</a></li>
<li><a href="#vce_log_gettime_short">vce_log_gettime_short</a></li>
<li><a href="#vce_log_init">vce_log_init</a></li>
<li><a href="#vce_log_parse">vce_log_parse</a></li>
<li><a href="#vce_log_print">vce_log_print</a></li>
<li><a href="#vce_log_set_gettime_func">vce_log_set_gettime_func</a></li>
<li><a href="#vce_log_set_type_mask">vce_log_set_type_mask</a></li>
<li><a href="#vce_log_set_type_mask_by_name">vce_log_set_type_mask_by_name</a></li>
<li><a href="#vce_log_vprint">vce_log_vprint</a></li>
<li><a href="#vce_logwriter_connect">vce_logwriter_connect</a></li>
<li><a href="#vce_logwriter_init">vce_logwriter_init</a></li>
<li><a href="#vce_logwriter_poll">vce_logwriter_poll</a></li>
<li><a href="#vce_logwriter_printf">vce_logwriter_printf</a></li>
<li><a href="#vce_logwriter_vprintf">vce_logwriter_vprintf</a></li>
<li><a href="#vce_mainloop">vce_mainloop</a></li>
<li><a href="#vce_make_binary_array_from_hex">vce_make_binary_array_from_hex</a></li>
<li><a href="#vce_make_binary_array_from_line">vce_make_binary_array_from_line</a></li>
<li><a href="#vce_make_hex_from_binary_array">vce_make_hex_from_binary_array</a></li>
<li><a href="#vce_make_hex_text_from_buffer">vce_make_hex_text_from_buffer</a></li>
<li><a href="#vce_makecstr">vce_makecstr</a></li>
<li><a href="#vce_monitor_client_add">vce_monitor_client_add</a></li>
<li><a href="#vce_monitor_client_call">vce_monitor_client_call</a></li>
<li><a href="#vce_monitor_client_callable">vce_monitor_client_callable</a></li>
<li><a href="#vce_monitor_client_connect">vce_monitor_client_connect</a></li>
<li><a href="#vce_monitor_client_connected">vce_monitor_client_connected</a></li>
<li><a href="#vce_monitor_client_delete">vce_monitor_client_delete</a></li>
<li><a href="#vce_monitor_client_disable">vce_monitor_client_disable</a></li>
<li><a href="#vce_monitor_client_disconnect">vce_monitor_client_disconnect</a></li>
<li><a href="#vce_monitor_client_enable">vce_monitor_client_enable</a></li>
<li><a href="#vce_monitor_client_set_replywatcher">vce_monitor_client_set_replywatcher</a></li>
<li><a href="#vce_monitor_ent_init">vce_monitor_ent_init</a></li>
<li><a href="#vce_monitor_server_add_command">vce_monitor_server_add_command</a></li>
<li><a href="#vce_monitor_server_add_stantdard_commands">vce_monitor_server_add_stantdard_commands</a></li>
<li><a href="#vce_monitor_server_disable">vce_monitor_server_disable</a></li>
<li><a href="#vce_monitor_server_enable">vce_monitor_server_enable</a></li>
<li><a href="#vce_monitor_server_reply">vce_monitor_server_reply</a></li>
<li><a href="#vce_profiler_cleanup">vce_profiler_cleanup</a></li>
<li><a href="#vce_profiler_in">vce_profiler_in</a></li>
<li><a href="#vce_profiler_init">vce_profiler_init</a></li>
<li><a href="#vce_profiler_out">vce_profiler_out</a></li>
<li><a href="#vce_profiler_save_stats">vce_profiler_save_stats</a></li>
<li><a href="#vce_protocol_acceptwatcher_deny">vce_protocol_acceptwatcher_deny</a></li>
<li><a href="#vce_protocol_acceptwatcher_noop">vce_protocol_acceptwatcher_noop</a></li>
<li><a href="#vce_protocol_acceptwatcher_vec0">vce_protocol_acceptwatcher_vec0</a></li>
<li><a href="#vce_protocol_closewatcher_noop">vce_protocol_closewatcher_noop</a></li>
<li><a href="#vce_protocol_closewatcher_vec0">vce_protocol_closewatcher_vec0</a></li>
<li><a href="#vce_protocol_parser_bin16">vce_protocol_parser_bin16</a></li>
<li><a href="#vce_protocol_parser_bin32">vce_protocol_parser_bin32</a></li>
<li><a href="#vce_protocol_parser_text">vce_protocol_parser_text</a></li>
<li><a href="#vce_protocol_parser_through">vce_protocol_parser_through</a></li>
<li><a href="#vce_protocol_parser_vec0">vce_protocol_parser_vec0</a></li>
<li><a href="#vce_protocol_parser_vecmain_client">vce_protocol_parser_vecmain_client</a></li>
<li><a href="#vce_protocol_parser_vecmain_server">vce_protocol_parser_vecmain_server</a></li>
<li><a href="#vce_protocol_pcallback_dump">vce_protocol_pcallback_dump</a></li>
<li><a href="#vce_protocol_pcallback_echo_bin16">vce_protocol_pcallback_echo_bin16</a></li>
<li><a href="#vce_protocol_pcallback_echo_text">vce_protocol_pcallback_echo_text</a></li>
<li><a href="#vce_protocol_pcallback_noop">vce_protocol_pcallback_noop</a></li>
<li><a href="#vce_protocol_unparser_bin16">vce_protocol_unparser_bin16</a></li>
<li><a href="#vce_protocol_unparser_bin32">vce_protocol_unparser_bin32</a></li>
<li><a href="#vce_protocol_unparser_text">vce_protocol_unparser_text</a></li>
<li><a href="#vce_protocol_unparser_through">vce_protocol_unparser_through</a></li>
<li><a href="#vce_read_plain_text_file">vce_read_plain_text_file</a></li>
<li><a href="#vce_read_simple_config_file">vce_read_simple_config_file</a></li>
<li><a href="#vce_replace_malloc_funcs">vce_replace_malloc_funcs</a></li>
<li><a href="#vce_save_statlog">vce_save_statlog</a></li>
<li><a href="#vce_scandir">vce_scandir</a></li>
<li><a href="#vce_set_heartbeat_wait_flag">vce_set_heartbeat_wait_flag</a></li>
<li><a href="#vce_set_internal_timer">vce_set_internal_timer</a></li>
<li><a href="#vce_set_mainloop_callback">vce_set_mainloop_callback</a></li>
<li><a href="#vce_set_read_write_log_mode">vce_set_read_write_log_mode</a></li>
<li><a href="#vce_set_socket_library_ok">vce_set_socket_library_ok</a></li>
<li><a href="#vce_set_verbose_mode">vce_set_verbose_mode</a></li>
<li><a href="#vce_sha1_buffer_checksum">vce_sha1_buffer_checksum</a></li>
<li><a href="#vce_sha1_file_checksum">vce_sha1_file_checksum</a></li>
<li><a href="#vce_show_array_usage">vce_show_array_usage</a></li>
<li><a href="#vce_snprintf">vce_snprintf</a></li>
<li><a href="#vce_strcmptail">vce_strcmptail</a></li>
<li><a href="#vce_strerror">vce_strerror</a></li>
<li><a href="#vce_strerror_close_reason">vce_strerror_close_reason</a></li>
<li><a href="#vce_strlenmax">vce_strlenmax</a></li>
<li><a href="#vce_strncat">vce_strncat</a></li>
<li><a href="#vce_strncpy">vce_strncpy</a></li>
<li><a href="#vce_switchcontext_cleanup">vce_switchcontext_cleanup</a></li>
<li><a href="#vce_switchcontext_create">vce_switchcontext_create</a></li>
<li><a href="#vce_switchtable_read_from_file">vce_switchtable_read_from_file</a></li>
<li><a href="#vce_switchtable_show">vce_switchtable_show</a></li>
<li><a href="#vce_taskcontext_cleanup">vce_taskcontext_cleanup</a></li>
<li><a href="#vce_taskcontext_create">vce_taskcontext_create</a></li>
<li><a href="#vce_taskcontext_get_elapsed_time">vce_taskcontext_get_elapsed_time</a></li>
<li><a href="#vce_taskcontext_get_id">vce_taskcontext_get_id</a></li>
<li><a href="#vce_taskcontext_get_workmem">vce_taskcontext_get_workmem</a></li>
<li><a href="#vce_taskgroup_cleanup">vce_taskgroup_cleanup</a></li>
<li><a href="#vce_taskgroup_create">vce_taskgroup_create</a></li>
<li><a href="#vce_taskgroup_get_stat">vce_taskgroup_get_stat</a></li>
<li><a href="#vce_taskgroup_set_scan_log_mode">vce_taskgroup_set_scan_log_mode</a></li>
<li><a href="#vce_tcpcontext_add_circ_ipv4_filter">vce_tcpcontext_add_circ_ipv4_filter</a></li>
<li><a href="#vce_tcpcontext_add_ipv4_filter">vce_tcpcontext_add_ipv4_filter</a></li>
<li><a href="#vce_tcpcontext_circ_iterate">vce_tcpcontext_circ_iterate</a></li>
<li><a href="#vce_tcpcontext_cleanup">vce_tcpcontext_cleanup</a></li>
<li><a href="#vce_tcpcontext_clear_circ_ipv4_filter">vce_tcpcontext_clear_circ_ipv4_filter</a></li>
<li><a href="#vce_tcpcontext_clear_conn_ipv4_filter">vce_tcpcontext_clear_conn_ipv4_filter</a></li>
<li><a href="#vce_tcpcontext_conn_iterate">vce_tcpcontext_conn_iterate</a></li>
<li><a href="#vce_tcpcontext_connect">vce_tcpcontext_connect</a></li>
<li><a href="#vce_tcpcontext_count_connections">vce_tcpcontext_count_connections</a></li>
<li><a href="#vce_tcpcontext_create">vce_tcpcontext_create</a></li>
<li><a href="#vce_tcpcontext_delete_circ_ipv4_filter">vce_tcpcontext_delete_circ_ipv4_filter</a></li>
<li><a href="#vce_tcpcontext_delete_conn_ipv4_filter">vce_tcpcontext_delete_conn_ipv4_filter</a></li>
<li><a href="#vce_tcpcontext_enable_accept">vce_tcpcontext_enable_accept</a></li>
<li><a href="#vce_tcpcontext_get_all_circuit">vce_tcpcontext_get_all_circuit</a></li>
<li><a href="#vce_tcpcontext_get_all_connection">vce_tcpcontext_get_all_connection</a></li>
<li><a href="#vce_tcpcontext_get_stat">vce_tcpcontext_get_stat</a></li>
<li><a href="#vce_tcpcontext_is_circ_mode">vce_tcpcontext_is_circ_mode</a></li>
<li><a href="#vce_tcpcontext_protocol_set_maxlength">vce_tcpcontext_protocol_set_maxlength</a></li>
<li><a href="#vce_tcpcontext_reset_compress">vce_tcpcontext_reset_compress</a></li>
<li><a href="#vce_tcpcontext_set_accept_max">vce_tcpcontext_set_accept_max</a></li>
<li><a href="#vce_tcpcontext_set_circ_acceptwatcher">vce_tcpcontext_set_circ_acceptwatcher</a></li>
<li><a href="#vce_tcpcontext_set_circ_closewatcher">vce_tcpcontext_set_circ_closewatcher</a></li>
<li><a href="#vce_tcpcontext_set_circ_finalizer">vce_tcpcontext_set_circ_finalizer</a></li>
<li><a href="#vce_tcpcontext_set_circ_hiwater_acceptwatcher">vce_tcpcontext_set_circ_hiwater_acceptwatcher</a></li>
<li><a href="#vce_tcpcontext_set_circ_parser">vce_tcpcontext_set_circ_parser</a></li>
<li><a href="#vce_tcpcontext_set_circ_switchresultwatcher">vce_tcpcontext_set_circ_switchresultwatcher</a></li>
<li><a href="#vce_tcpcontext_set_circ_switchwatcher">vce_tcpcontext_set_circ_switchwatcher</a></li>
<li><a href="#vce_tcpcontext_set_compress">vce_tcpcontext_set_compress</a></li>
<li><a href="#vce_tcpcontext_set_conn_acceptwatcher">vce_tcpcontext_set_conn_acceptwatcher</a></li>
<li><a href="#vce_tcpcontext_set_conn_call_parser_per_heartbeat">vce_tcpcontext_set_conn_call_parser_per_heartbeat</a></li>
<li><a href="#vce_tcpcontext_set_conn_closewatcher">vce_tcpcontext_set_conn_closewatcher</a></li>
<li><a href="#vce_tcpcontext_set_conn_finalizer">vce_tcpcontext_set_conn_finalizer</a></li>
<li><a href="#vce_tcpcontext_set_conn_hiwater_acceptwatcher">vce_tcpcontext_set_conn_hiwater_acceptwatcher</a></li>
<li><a href="#vce_tcpcontext_set_conn_kickip_array">vce_tcpcontext_set_conn_kickip_array</a></li>
<li><a href="#vce_tcpcontext_set_conn_parser">vce_tcpcontext_set_conn_parser</a></li>
<li><a href="#vce_tcpcontext_set_conn_safety_read">vce_tcpcontext_set_conn_safety_read</a></li>
<li><a href="#vce_tcpcontext_set_equal_io_splitrate">vce_tcpcontext_set_equal_io_splitrate</a></li>
<li><a href="#vce_tcpcontext_set_read_delay">vce_tcpcontext_set_read_delay</a></li>
<li><a href="#vce_tcpcontext_timeout_control">vce_tcpcontext_timeout_control</a></li>
<li><a href="#vce_tcpcontext_use_filter_file">vce_tcpcontext_use_filter_file</a></li>
<li><a href="#vce_text_cmpnocase">vce_text_cmpnocase</a></li>
<li><a href="#vce_text_hashpjw">vce_text_hashpjw</a></li>
<li><a href="#vce_text_split_index">vce_text_split_index</a></li>
<li><a href="#vce_text_split_index_get_int">vce_text_split_index_get_int</a></li>
<li><a href="#vce_text_split_index_get_string">vce_text_split_index_get_string</a></li>
<li><a href="#vce_update_int2_search">vce_update_int2_search</a></li>
<li><a href="#vce_update_int4_search">vce_update_int4_search</a></li>
<li><a href="#vce_update_int_search">vce_update_int_search</a></li>
<li><a href="#vce_update_string_search">vce_update_string_search</a></li>
<li><a href="#vce_update_vstring_search">vce_update_vstring_search</a></li>
<li><a href="#vce_utime_diff">vce_utime_diff</a></li>
<li><a href="#vce_vec_init_mainserv">vce_vec_init_mainserv</a></li>
<li><a href="#vce_vec_setup_linkage">vce_vec_setup_linkage</a></li>
<li><a href="#vce_vecprotocol_acceptwatcher_deny">vce_vecprotocol_acceptwatcher_deny</a></li>
<li><a href="#vce_vecprotocol_acceptwatcher_noop">vce_vecprotocol_acceptwatcher_noop</a></li>
<li><a href="#vce_vecprotocol_closewatcher_noop">vce_vecprotocol_closewatcher_noop</a></li>
<li><a href="#vce_vecprotocol_parser_bin16">vce_vecprotocol_parser_bin16</a></li>
<li><a href="#vce_vecprotocol_parser_bin32">vce_vecprotocol_parser_bin32</a></li>
<li><a href="#vce_vecprotocol_parser_text">vce_vecprotocol_parser_text</a></li>
<li><a href="#vce_vecprotocol_parser_through">vce_vecprotocol_parser_through</a></li>
<li><a href="#vce_vecprotocol_pcallback_echo_bin16">vce_vecprotocol_pcallback_echo_bin16</a></li>
<li><a href="#vce_vecprotocol_pcallback_echo_text">vce_vecprotocol_pcallback_echo_text</a></li>
<li><a href="#vce_vecprotocol_unparser_bin16">vce_vecprotocol_unparser_bin16</a></li>
<li><a href="#vce_vecprotocol_unparser_bin32">vce_vecprotocol_unparser_bin32</a></li>
<li><a href="#vce_vecprotocol_unparser_text">vce_vecprotocol_unparser_text</a></li>
<li><a href="#vce_vecprotocol_unparser_through">vce_vecprotocol_unparser_through</a></li>
<li><a href="#vce_verrout">vce_verrout</a></li>
</ol>
<h2>Category index by name</h2>
<!-- make_categoryindex -->
<a name="analyzer"></a>
<h3>analyzer</h3>
<p>PENDING
</p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_analyzer_analyze">vce_analyzer_analyze</a><BR>
<a href="#vce_analyzer_clear">vce_analyzer_clear</a><BR>
<a href="#vce_analyzer_get_state_string">vce_analyzer_get_state_string</a><BR>
<a href="#vce_analyzer_init">vce_analyzer_init</a><BR>
</td></tr>
</table>
<a name="array"></a>
<h3>array</h3>
<p></p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#ARRAY_SCAN">ARRAY_SCAN</a><BR>
<a href="#ARRAY_SCAN_TYPE">ARRAY_SCAN_TYPE</a><BR>
<a href="#vce_alloc_array_object">vce_alloc_array_object</a><BR>
<a href="#vce_array_object_inuse">vce_array_object_inuse</a><BR>
<a href="#vce_end_all_array">vce_end_all_array</a><BR>
<a href="#vce_end_array">vce_end_array</a><BR>
<a href="#vce_free_array_object">vce_free_array_object</a><BR>
<a href="#vce_free_array_object_all">vce_free_array_object_all</a><BR>
<a href="#vce_get_array_maxnum">vce_get_array_maxnum</a><BR>
<a href="#vce_get_array_member_size">vce_get_array_member_size</a><BR>
<a href="#vce_get_array_object_index">vce_get_array_object_index</a><BR>
<a href="#vce_get_array_object_last">vce_get_array_object_last</a><BR>
<a href="#vce_get_array_object_next">vce_get_array_object_next</a><BR>
<a href="#vce_get_array_object_pointer_by_index">vce_get_array_object_pointer_by_index</a><BR>
<a href="#vce_get_array_object_pointer_by_index_only_used">vce_get_array_object_pointer_by_index_only_used</a><BR>
<a href="#vce_get_array_object_top">vce_get_array_object_top</a><BR>
<a href="#vce_get_array_usenum">vce_get_array_usenum</a><BR>
<a href="#vce_if_included_in_array">vce_if_included_in_array</a><BR>
<a href="#vce_init_array">vce_init_array</a><BR>
<a href="#vce_show_array_usage">vce_show_array_usage</a><BR>
</td></tr>
</table>
<a name="bin"></a>
<h3>bin</h3>
<p></p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_binary_pack">vce_binary_pack</a><BR>
<a href="#vce_binary_pop_nb_i1">vce_binary_pop_nb_i1</a><BR>
<a href="#vce_binary_pop_nb_i2">vce_binary_pop_nb_i2</a><BR>
<a href="#vce_binary_pop_nb_i4">vce_binary_pop_nb_i4</a><BR>
<a href="#vce_binary_pop_nb_i8">vce_binary_pop_nb_i8</a><BR>
<a href="#vce_binary_pop_nb_ia1">vce_binary_pop_nb_ia1</a><BR>
<a href="#vce_binary_pop_nb_ia2">vce_binary_pop_nb_ia2</a><BR>
<a href="#vce_binary_pop_nb_ia4">vce_binary_pop_nb_ia4</a><BR>
<a href="#vce_binary_pop_nb_ia8">vce_binary_pop_nb_ia8</a><BR>
<a href="#vce_binary_pop_nb_stra">vce_binary_pop_nb_stra</a><BR>
<a href="#vce_binary_push_nb_i1">vce_binary_push_nb_i1</a><BR>
<a href="#vce_binary_push_nb_i2">vce_binary_push_nb_i2</a><BR>
<a href="#vce_binary_push_nb_i4">vce_binary_push_nb_i4</a><BR>
<a href="#vce_binary_push_nb_i8">vce_binary_push_nb_i8</a><BR>
<a href="#vce_binary_push_nb_ia1">vce_binary_push_nb_ia1</a><BR>
<a href="#vce_binary_push_nb_ia2">vce_binary_push_nb_ia2</a><BR>
<a href="#vce_binary_push_nb_ia4">vce_binary_push_nb_ia4</a><BR>
<a href="#vce_binary_push_nb_ia8">vce_binary_push_nb_ia8</a><BR>
<a href="#vce_binary_push_nb_stra">vce_binary_push_nb_stra</a><BR>
<a href="#vce_binary_unpack">vce_binary_unpack</a><BR>
</td></tr>
</table>
<a name="core"></a>
<h3>core</h3>
<p> Core functions are basic functions for VCE applications.
Major functionality is controlling application's main loop,
VCE initialization, and cleaning up.
  In Win32 environment, winsock initialization is done in
vce_initialize function.
vce_errout_?? functions are designed to output application error log
to file or stdout.
</p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_conn_set_delay">vce_conn_set_delay</a><BR>
<a href="#vce_errout">vce_errout</a><BR>
<a href="#vce_errout0">vce_errout0</a><BR>
<a href="#vce_errout0_v">vce_errout0_v</a><BR>
<a href="#vce_errout_config">vce_errout_config</a><BR>
<a href="#vce_errout_set_another">vce_errout_set_another</a><BR>
<a href="#vce_errout_v">vce_errout_v</a><BR>
<a href="#vce_finalize">vce_finalize</a><BR>
<a href="#vce_get_version">vce_get_version</a><BR>
<a href="#vce_heartbeat">vce_heartbeat</a><BR>
<a href="#vce_init_limit_t">vce_init_limit_t</a><BR>
<a href="#vce_initialize">vce_initialize</a><BR>
<a href="#vce_initialize_limited">vce_initialize_limited</a><BR>
<a href="#vce_limit_clear">vce_limit_clear</a><BR>
<a href="#vce_mainloop">vce_mainloop</a><BR>
<a href="#vce_set_heartbeat_wait_flag">vce_set_heartbeat_wait_flag</a><BR>
<a href="#vce_set_mainloop_callback">vce_set_mainloop_callback</a><BR>
<a href="#vce_set_read_write_log_mode">vce_set_read_write_log_mode</a><BR>
<a href="#vce_set_socket_library_ok">vce_set_socket_library_ok</a><BR>
<a href="#vce_set_verbose_mode">vce_set_verbose_mode</a><BR>
<a href="#vce_verrout">vce_verrout</a><BR>
</td></tr>
</table>
<a name="err"></a>
<h3>err</h3>
<p></p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_get_last_error">vce_get_last_error</a><BR>
<a href="#vce_strerror">vce_strerror</a><BR>
<a href="#vce_strerror_close_reason">vce_strerror_close_reason</a><BR>
</td></tr>
</table>
<a name="log"></a>
<h3>log</h3>
<p>PENDING
</p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_get_netstat_string">vce_get_netstat_string</a><BR>
<a href="#vce_get_stat">vce_get_stat</a><BR>
<a href="#vce_log_add_monitor_command">vce_log_add_monitor_command</a><BR>
<a href="#vce_log_add_type">vce_log_add_type</a><BR>
<a href="#vce_log_get_types">vce_log_get_types</a><BR>
<a href="#vce_log_gettime_long">vce_log_gettime_long</a><BR>
<a href="#vce_log_gettime_normal">vce_log_gettime_normal</a><BR>
<a href="#vce_log_gettime_short">vce_log_gettime_short</a><BR>
<a href="#vce_log_init">vce_log_init</a><BR>
<a href="#vce_log_parse">vce_log_parse</a><BR>
<a href="#vce_log_print">vce_log_print</a><BR>
<a href="#vce_log_set_gettime_func">vce_log_set_gettime_func</a><BR>
<a href="#vce_log_set_type_mask">vce_log_set_type_mask</a><BR>
<a href="#vce_log_set_type_mask_by_name">vce_log_set_type_mask_by_name</a><BR>
<a href="#vce_log_vprint">vce_log_vprint</a><BR>
<a href="#vce_save_statlog">vce_save_statlog</a><BR>
</td></tr>
</table>
<a name="logwriter"></a>
<h3>logwriter</h3>
<p>PENDING
</p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_logwriter_connect">vce_logwriter_connect</a><BR>
<a href="#vce_logwriter_init">vce_logwriter_init</a><BR>
<a href="#vce_logwriter_poll">vce_logwriter_poll</a><BR>
<a href="#vce_logwriter_printf">vce_logwriter_printf</a><BR>
<a href="#vce_logwriter_vprintf">vce_logwriter_vprintf</a><BR>
</td></tr>
</table>
<a name="monitor"></a>
<h3>monitor</h3>
<p></p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_monitor_client_add">vce_monitor_client_add</a><BR>
<a href="#vce_monitor_client_call">vce_monitor_client_call</a><BR>
<a href="#vce_monitor_client_callable">vce_monitor_client_callable</a><BR>
<a href="#vce_monitor_client_connect">vce_monitor_client_connect</a><BR>
<a href="#vce_monitor_client_connected">vce_monitor_client_connected</a><BR>
<a href="#vce_monitor_client_delete">vce_monitor_client_delete</a><BR>
<a href="#vce_monitor_client_disable">vce_monitor_client_disable</a><BR>
<a href="#vce_monitor_client_disconnect">vce_monitor_client_disconnect</a><BR>
<a href="#vce_monitor_client_enable">vce_monitor_client_enable</a><BR>
<a href="#vce_monitor_client_set_replywatcher">vce_monitor_client_set_replywatcher</a><BR>
<a href="#vce_monitor_ent_init">vce_monitor_ent_init</a><BR>
<a href="#vce_monitor_server_add_command">vce_monitor_server_add_command</a><BR>
<a href="#vce_monitor_server_add_stantdard_commands">vce_monitor_server_add_stantdard_commands</a><BR>
<a href="#vce_monitor_server_disable">vce_monitor_server_disable</a><BR>
<a href="#vce_monitor_server_enable">vce_monitor_server_enable</a><BR>
<a href="#vce_monitor_server_reply">vce_monitor_server_reply</a><BR>
</td></tr>
</table>
<a name="parser"></a>
<h3>parser</h3>
<p></p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_protocol_parser_bin16">vce_protocol_parser_bin16</a><BR>
<a href="#vce_protocol_parser_bin32">vce_protocol_parser_bin32</a><BR>
<a href="#vce_protocol_parser_text">vce_protocol_parser_text</a><BR>
<a href="#vce_protocol_parser_through">vce_protocol_parser_through</a><BR>
<a href="#vce_protocol_parser_vec0">vce_protocol_parser_vec0</a><BR>
<a href="#vce_protocol_parser_vecmain_client">vce_protocol_parser_vecmain_client</a><BR>
<a href="#vce_protocol_parser_vecmain_server">vce_protocol_parser_vecmain_server</a><BR>
<a href="#vce_protocol_unparser_bin16">vce_protocol_unparser_bin16</a><BR>
<a href="#vce_protocol_unparser_bin32">vce_protocol_unparser_bin32</a><BR>
<a href="#vce_protocol_unparser_text">vce_protocol_unparser_text</a><BR>
<a href="#vce_protocol_unparser_through">vce_protocol_unparser_through</a><BR>
<a href="#vce_vecprotocol_parser_bin16">vce_vecprotocol_parser_bin16</a><BR>
<a href="#vce_vecprotocol_parser_bin32">vce_vecprotocol_parser_bin32</a><BR>
<a href="#vce_vecprotocol_parser_text">vce_vecprotocol_parser_text</a><BR>
<a href="#vce_vecprotocol_parser_through">vce_vecprotocol_parser_through</a><BR>
<a href="#vce_vecprotocol_unparser_bin16">vce_vecprotocol_unparser_bin16</a><BR>
<a href="#vce_vecprotocol_unparser_bin32">vce_vecprotocol_unparser_bin32</a><BR>
<a href="#vce_vecprotocol_unparser_text">vce_vecprotocol_unparser_text</a><BR>
<a href="#vce_vecprotocol_unparser_through">vce_vecprotocol_unparser_through</a><BR>
</td></tr>
</table>
<a name="pcallback"></a>
<h3>pcallback</h3>
<p></p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_protocol_pcallback_dump">vce_protocol_pcallback_dump</a><BR>
<a href="#vce_protocol_pcallback_echo_bin16">vce_protocol_pcallback_echo_bin16</a><BR>
<a href="#vce_protocol_pcallback_echo_text">vce_protocol_pcallback_echo_text</a><BR>
<a href="#vce_protocol_pcallback_noop">vce_protocol_pcallback_noop</a><BR>
<a href="#vce_vecprotocol_pcallback_echo_bin16">vce_vecprotocol_pcallback_echo_bin16</a><BR>
<a href="#vce_vecprotocol_pcallback_echo_text">vce_vecprotocol_pcallback_echo_text</a><BR>
</td></tr>
</table>
<a name="profiler"></a>
<h3>profiler</h3>
<p></p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_profiler_cleanup">vce_profiler_cleanup</a><BR>
<a href="#vce_profiler_in">vce_profiler_in</a><BR>
<a href="#vce_profiler_init">vce_profiler_init</a><BR>
<a href="#vce_profiler_out">vce_profiler_out</a><BR>
<a href="#vce_profiler_save_stats">vce_profiler_save_stats</a><BR>
</td></tr>
</table>
<a name="search"></a>
<h3>search</h3>
<p></p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_cleanup_all_search_engine">vce_cleanup_all_search_engine</a><BR>
<a href="#vce_cleanup_search_engine">vce_cleanup_search_engine</a><BR>
<a href="#vce_delete_int2_search">vce_delete_int2_search</a><BR>
<a href="#vce_delete_int4_search">vce_delete_int4_search</a><BR>
<a href="#vce_delete_int_search">vce_delete_int_search</a><BR>
<a href="#vce_delete_string_search">vce_delete_string_search</a><BR>
<a href="#vce_delete_vstring_search">vce_delete_vstring_search</a><BR>
<a href="#vce_get_int2_or_search">vce_get_int2_or_search</a><BR>
<a href="#vce_get_int2_search">vce_get_int2_search</a><BR>
<a href="#vce_get_int4_or_search">vce_get_int4_or_search</a><BR>
<a href="#vce_get_int4_search">vce_get_int4_search</a><BR>
<a href="#vce_get_int_search">vce_get_int_search</a><BR>
<a href="#vce_get_search_usenum">vce_get_search_usenum</a><BR>
<a href="#vce_get_string_search">vce_get_string_search</a><BR>
<a href="#vce_get_vstring_search">vce_get_vstring_search</a><BR>
<a href="#vce_init_int2_search">vce_init_int2_search</a><BR>
<a href="#vce_init_int4_search">vce_init_int4_search</a><BR>
<a href="#vce_init_int_search">vce_init_int_search</a><BR>
<a href="#vce_init_string_search">vce_init_string_search</a><BR>
<a href="#vce_init_vstring_search">vce_init_vstring_search</a><BR>
<a href="#vce_iterate_int2_search">vce_iterate_int2_search</a><BR>
<a href="#vce_iterate_int4_search">vce_iterate_int4_search</a><BR>
<a href="#vce_update_int2_search">vce_update_int2_search</a><BR>
<a href="#vce_update_int4_search">vce_update_int4_search</a><BR>
<a href="#vce_update_int_search">vce_update_int_search</a><BR>
<a href="#vce_update_string_search">vce_update_string_search</a><BR>
<a href="#vce_update_vstring_search">vce_update_vstring_search</a><BR>
</td></tr>
</table>
<a name="task"></a>
<h3>task</h3>
<p></p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_taskcontext_cleanup">vce_taskcontext_cleanup</a><BR>
<a href="#vce_taskcontext_create">vce_taskcontext_create</a><BR>
<a href="#vce_taskcontext_get_elapsed_time">vce_taskcontext_get_elapsed_time</a><BR>
<a href="#vce_taskcontext_get_id">vce_taskcontext_get_id</a><BR>
<a href="#vce_taskcontext_get_workmem">vce_taskcontext_get_workmem</a><BR>
<a href="#vce_taskgroup_cleanup">vce_taskgroup_cleanup</a><BR>
<a href="#vce_taskgroup_create">vce_taskgroup_create</a><BR>
<a href="#vce_taskgroup_get_stat">vce_taskgroup_get_stat</a><BR>
<a href="#vce_taskgroup_set_scan_log_mode">vce_taskgroup_set_scan_log_mode</a><BR>
</td></tr>
</table>
<a name="tcp"></a>
<h3>tcp</h3>
<p></p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_circ_close">vce_circ_close</a><BR>
<a href="#vce_circ_get_index">vce_circ_get_index</a><BR>
<a href="#vce_circ_get_parent_conn">vce_circ_get_parent_conn</a><BR>
<a href="#vce_circ_get_remote_addr_string">vce_circ_get_remote_addr_string</a><BR>
<a href="#vce_circ_get_remote_ipv4_addr">vce_circ_get_remote_ipv4_addr</a><BR>
<a href="#vce_circ_get_remote_ipv4_addr_string">vce_circ_get_remote_ipv4_addr_string</a><BR>
<a href="#vce_circ_get_remote_ipv6_addr">vce_circ_get_remote_ipv6_addr</a><BR>
<a href="#vce_circ_get_remote_ipv6_addr_string">vce_circ_get_remote_ipv6_addr_string</a><BR>
<a href="#vce_circ_get_state_buffer">vce_circ_get_state_buffer</a><BR>
<a href="#vce_circ_get_struct_from_index">vce_circ_get_struct_from_index</a><BR>
<a href="#vce_circ_get_tcpcontext">vce_circ_get_tcpcontext</a><BR>
<a href="#vce_circ_is_equal">vce_circ_is_equal</a><BR>
<a href="#vce_circ_is_valid">vce_circ_is_valid</a><BR>
<a href="#vce_circ_set_timeout">vce_circ_set_timeout</a><BR>
<a href="#vce_circ_switch">vce_circ_switch</a><BR>
<a href="#vce_circ_test_sanity">vce_circ_test_sanity</a><BR>
<a href="#vce_circ_writable">vce_circ_writable</a><BR>
<a href="#vce_circ_write">vce_circ_write</a><BR>
<a href="#vce_conn_break_heartbeat">vce_conn_break_heartbeat</a><BR>
<a href="#vce_conn_clear">vce_conn_clear</a><BR>
<a href="#vce_conn_close">vce_conn_close</a><BR>
<a href="#vce_conn_close_tcpcontext_all">vce_conn_close_tcpcontext_all</a><BR>
<a href="#vce_conn_get_buffer">vce_conn_get_buffer</a><BR>
<a href="#vce_conn_get_child_circ">vce_conn_get_child_circ</a><BR>
<a href="#vce_conn_get_index">vce_conn_get_index</a><BR>
<a href="#vce_conn_get_local_addr_string">vce_conn_get_local_addr_string</a><BR>
<a href="#vce_conn_get_local_ipv4_addr">vce_conn_get_local_ipv4_addr</a><BR>
<a href="#vce_conn_get_local_ipv4_addr_string">vce_conn_get_local_ipv4_addr_string</a><BR>
<a href="#vce_conn_get_local_ipv6_addr">vce_conn_get_local_ipv6_addr</a><BR>
<a href="#vce_conn_get_local_ipv6_addr_string">vce_conn_get_local_ipv6_addr_string</a><BR>
<a href="#vce_conn_get_remote_addr_string">vce_conn_get_remote_addr_string</a><BR>
<a href="#vce_conn_get_remote_ipv4_addr">vce_conn_get_remote_ipv4_addr</a><BR>
<a href="#vce_conn_get_remote_ipv4_addr_string">vce_conn_get_remote_ipv4_addr_string</a><BR>
<a href="#vce_conn_get_remote_ipv6_addr">vce_conn_get_remote_ipv6_addr</a><BR>
<a href="#vce_conn_get_remote_ipv6_addr_string">vce_conn_get_remote_ipv6_addr_string</a><BR>
<a href="#vce_conn_get_stat">vce_conn_get_stat</a><BR>
<a href="#vce_conn_get_state_buffer">vce_conn_get_state_buffer</a><BR>
<a href="#vce_conn_get_struct_from_index">vce_conn_get_struct_from_index</a><BR>
<a href="#vce_conn_get_tcpcontext">vce_conn_get_tcpcontext</a><BR>
<a href="#vce_conn_is_equal">vce_conn_is_equal</a><BR>
<a href="#vce_conn_is_valid">vce_conn_is_valid</a><BR>
<a href="#vce_conn_set_parser">vce_conn_set_parser</a><BR>
<a href="#vce_conn_set_timeout">vce_conn_set_timeout</a><BR>
<a href="#vce_conn_show_stat">vce_conn_show_stat</a><BR>
<a href="#vce_conn_shrink_readbuf">vce_conn_shrink_readbuf</a><BR>
<a href="#vce_conn_writable">vce_conn_writable</a><BR>
<a href="#vce_conn_write">vce_conn_write</a><BR>
<a href="#vce_conn_writed">vce_conn_writed</a><BR>
<a href="#vce_get_tcp_packet_read_size">vce_get_tcp_packet_read_size</a><BR>
<a href="#vce_get_tcp_packet_write_size">vce_get_tcp_packet_write_size</a><BR>
<a href="#vce_switchcontext_create">vce_switchcontext_create</a><BR>
<a href="#vce_switchtable_read_from_file">vce_switchtable_read_from_file</a><BR>
<a href="#vce_switchtable_show">vce_switchtable_show</a><BR>
<a href="#vce_tcpcontext_add_circ_ipv4_filter">vce_tcpcontext_add_circ_ipv4_filter</a><BR>
<a href="#vce_tcpcontext_add_ipv4_filter">vce_tcpcontext_add_ipv4_filter</a><BR>
<a href="#vce_tcpcontext_circ_iterate">vce_tcpcontext_circ_iterate</a><BR>
<a href="#vce_tcpcontext_cleanup">vce_tcpcontext_cleanup</a><BR>
<a href="#vce_tcpcontext_clear_circ_ipv4_filter">vce_tcpcontext_clear_circ_ipv4_filter</a><BR>
<a href="#vce_tcpcontext_clear_conn_ipv4_filter">vce_tcpcontext_clear_conn_ipv4_filter</a><BR>
<a href="#vce_tcpcontext_connect">vce_tcpcontext_connect</a><BR>
<a href="#vce_tcpcontext_count_connections">vce_tcpcontext_count_connections</a><BR>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a><BR>
<a href="#vce_tcpcontext_delete_circ_ipv4_filter">vce_tcpcontext_delete_circ_ipv4_filter</a><BR>
<a href="#vce_tcpcontext_delete_conn_ipv4_filter">vce_tcpcontext_delete_conn_ipv4_filter</a><BR>
<a href="#vce_tcpcontext_enable_accept">vce_tcpcontext_enable_accept</a><BR>
<a href="#vce_tcpcontext_get_all_circuit">vce_tcpcontext_get_all_circuit</a><BR>
<a href="#vce_tcpcontext_get_all_connection">vce_tcpcontext_get_all_connection</a><BR>
<a href="#vce_tcpcontext_get_stat">vce_tcpcontext_get_stat</a><BR>
<a href="#vce_tcpcontext_is_circ_mode">vce_tcpcontext_is_circ_mode</a><BR>
<a href="#vce_tcpcontext_protocol_set_maxlength">vce_tcpcontext_protocol_set_maxlength</a><BR>
<a href="#vce_tcpcontext_reset_compress">vce_tcpcontext_reset_compress</a><BR>
<a href="#vce_tcpcontext_set_accept_max">vce_tcpcontext_set_accept_max</a><BR>
<a href="#vce_tcpcontext_set_circ_acceptwatcher">vce_tcpcontext_set_circ_acceptwatcher</a><BR>
<a href="#vce_tcpcontext_set_circ_closewatcher">vce_tcpcontext_set_circ_closewatcher</a><BR>
<a href="#vce_tcpcontext_set_circ_finalizer">vce_tcpcontext_set_circ_finalizer</a><BR>
<a href="#vce_tcpcontext_set_circ_hiwater_acceptwatcher">vce_tcpcontext_set_circ_hiwater_acceptwatcher</a><BR>
<a href="#vce_tcpcontext_set_circ_parser">vce_tcpcontext_set_circ_parser</a><BR>
<a href="#vce_tcpcontext_set_circ_switchresultwatcher">vce_tcpcontext_set_circ_switchresultwatcher</a><BR>
<a href="#vce_tcpcontext_set_circ_switchwatcher">vce_tcpcontext_set_circ_switchwatcher</a><BR>
<a href="#vce_tcpcontext_set_compress">vce_tcpcontext_set_compress</a><BR>
<a href="#vce_tcpcontext_set_conn_acceptwatcher">vce_tcpcontext_set_conn_acceptwatcher</a><BR>
<a href="#vce_tcpcontext_set_conn_call_parser_per_heartbeat">vce_tcpcontext_set_conn_call_parser_per_heartbeat</a><BR>
<a href="#vce_tcpcontext_set_conn_closewatcher">vce_tcpcontext_set_conn_closewatcher</a><BR>
<a href="#vce_tcpcontext_set_conn_finalizer">vce_tcpcontext_set_conn_finalizer</a><BR>
<a href="#vce_tcpcontext_set_conn_hiwater_acceptwatcher">vce_tcpcontext_set_conn_hiwater_acceptwatcher</a><BR>
<a href="#vce_tcpcontext_set_conn_kickip_array">vce_tcpcontext_set_conn_kickip_array</a><BR>
<a href="#vce_tcpcontext_set_conn_parser">vce_tcpcontext_set_conn_parser</a><BR>
<a href="#vce_tcpcontext_set_conn_safety_read">vce_tcpcontext_set_conn_safety_read</a><BR>
<a href="#vce_tcpcontext_set_equal_io_splitrate">vce_tcpcontext_set_equal_io_splitrate</a><BR>
<a href="#vce_tcpcontext_set_read_delay">vce_tcpcontext_set_read_delay</a><BR>
<a href="#vce_tcpcontext_timeout_control">vce_tcpcontext_timeout_control</a><BR>
<a href="#vce_tcpcontext_use_filter_file">vce_tcpcontext_use_filter_file</a><BR>
<a href="#vce_vec_init_mainserv">vce_vec_init_mainserv</a><BR>
<a href="#vce_vec_setup_linkage">vce_vec_setup_linkage</a><BR>
</td></tr>
</table>
<a name="text"></a>
<h3>text</h3>
<p></p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_chop_string_destroy">vce_chop_string_destroy</a><BR>
<a href="#vce_copy_cstring">vce_copy_cstring</a><BR>
<a href="#vce_copy_cstring_upto">vce_copy_cstring_upto</a><BR>
<a href="#vce_escape_string">vce_escape_string</a><BR>
<a href="#vce_httptext_divide_header_and_content">vce_httptext_divide_header_and_content</a><BR>
<a href="#vce_httptext_get_header_info">vce_httptext_get_header_info</a><BR>
<a href="#vce_makecstr">vce_makecstr</a><BR>
<a href="#vce_snprintf">vce_snprintf</a><BR>
<a href="#vce_strcmptail">vce_strcmptail</a><BR>
<a href="#vce_strlenmax">vce_strlenmax</a><BR>
<a href="#vce_strncat">vce_strncat</a><BR>
<a href="#vce_strncpy">vce_strncpy</a><BR>
<a href="#vce_text_cmpnocase">vce_text_cmpnocase</a><BR>
<a href="#vce_text_hashpjw">vce_text_hashpjw</a><BR>
<a href="#vce_text_split_index">vce_text_split_index</a><BR>
<a href="#vce_text_split_index_get_int">vce_text_split_index_get_int</a><BR>
<a href="#vce_text_split_index_get_string">vce_text_split_index_get_string</a><BR>
</td></tr>
</table>
<a name="util"></a>
<h3>util</h3>
<p></p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#ELEMENTOF">ELEMENTOF</a><BR>
<a href="#FREE">FREE</a><BR>
<a href="#GET_16BIT_INT">GET_16BIT_INT</a><BR>
<a href="#GET_16BIT_NATIVEINT">GET_16BIT_NATIVEINT</a><BR>
<a href="#GET_32BIT_INT">GET_32BIT_INT</a><BR>
<a href="#GET_32BIT_NATIVEINT">GET_32BIT_NATIVEINT</a><BR>
<a href="#GET_64BIT_INT">GET_64BIT_INT</a><BR>
<a href="#GET_64BIT_NATIVEINT">GET_64BIT_NATIVEINT</a><BR>
<a href="#GET_8BIT_INT">GET_8BIT_INT</a><BR>
<a href="#GET_8BIT_NATIVEINT">GET_8BIT_NATIVEINT</a><BR>
<a href="#MALLOC">MALLOC</a><BR>
<a href="#MAX">MAX</a><BR>
<a href="#MIN">MIN</a><BR>
<a href="#SET_16BIT_INT">SET_16BIT_INT</a><BR>
<a href="#SET_16BIT_NATIVEINT">SET_16BIT_NATIVEINT</a><BR>
<a href="#SET_32BIT_INT">SET_32BIT_INT</a><BR>
<a href="#SET_32BIT_NATIVEINT">SET_32BIT_NATIVEINT</a><BR>
<a href="#SET_64BIT_INT">SET_64BIT_INT</a><BR>
<a href="#SET_64BIT_NATIVEINT">SET_64BIT_NATIVEINT</a><BR>
<a href="#SET_8BIT_INT">SET_8BIT_INT</a><BR>
<a href="#SET_8BIT_NATIVEINT">SET_8BIT_NATIVEINT</a><BR>
<a href="#STRERR">STRERR</a><BR>
<a href="#vce_atoi">vce_atoi</a><BR>
<a href="#vce_decode_buffer_by_blowfish">vce_decode_buffer_by_blowfish</a><BR>
<a href="#vce_decode_buffer_by_rijndael">vce_decode_buffer_by_rijndael</a><BR>
<a href="#vce_dump_buffer">vce_dump_buffer</a><BR>
<a href="#vce_encode_buffer_by_blowfish">vce_encode_buffer_by_blowfish</a><BR>
<a href="#vce_encode_buffer_by_rijndael">vce_encode_buffer_by_rijndael</a><BR>
<a href="#vce_extract_data_from_hex_text">vce_extract_data_from_hex_text</a><BR>
<a href="#vce_get_current_utime">vce_get_current_utime</a><BR>
<a href="#vce_get_ipv4_addr_by_name">vce_get_ipv4_addr_by_name</a><BR>
<a href="#vce_make_binary_array_from_hex">vce_make_binary_array_from_hex</a><BR>
<a href="#vce_make_binary_array_from_line">vce_make_binary_array_from_line</a><BR>
<a href="#vce_make_hex_from_binary_array">vce_make_hex_from_binary_array</a><BR>
<a href="#vce_make_hex_text_from_buffer">vce_make_hex_text_from_buffer</a><BR>
<a href="#vce_read_plain_text_file">vce_read_plain_text_file</a><BR>
<a href="#vce_read_simple_config_file">vce_read_simple_config_file</a><BR>
<a href="#vce_replace_malloc_funcs">vce_replace_malloc_funcs</a><BR>
<a href="#vce_scandir">vce_scandir</a><BR>
<a href="#vce_sha1_buffer_checksum">vce_sha1_buffer_checksum</a><BR>
<a href="#vce_sha1_file_checksum">vce_sha1_file_checksum</a><BR>
<a href="#vce_utime_diff">vce_utime_diff</a><BR>
</td></tr>
</table>
<a name="watcher"></a>
<h3>watcher</h3>
<p></p>
<table id="categoryindex">
<tr><td>Functions:</td></tr>
<tr><td>
<a href="#vce_circ_set_alarmwatcher">vce_circ_set_alarmwatcher</a><BR>
<a href="#vce_conn_set_alarmwatcher">vce_conn_set_alarmwatcher</a><BR>
<a href="#vce_protocol_acceptwatcher_deny">vce_protocol_acceptwatcher_deny</a><BR>
<a href="#vce_protocol_acceptwatcher_noop">vce_protocol_acceptwatcher_noop</a><BR>
<a href="#vce_protocol_acceptwatcher_vec0">vce_protocol_acceptwatcher_vec0</a><BR>
<a href="#vce_protocol_closewatcher_noop">vce_protocol_closewatcher_noop</a><BR>
<a href="#vce_protocol_closewatcher_vec0">vce_protocol_closewatcher_vec0</a><BR>
<a href="#vce_vecprotocol_acceptwatcher_deny">vce_vecprotocol_acceptwatcher_deny</a><BR>
<a href="#vce_vecprotocol_acceptwatcher_noop">vce_vecprotocol_acceptwatcher_noop</a><BR>
<a href="#vce_vecprotocol_closewatcher_noop">vce_vecprotocol_closewatcher_noop</a><BR>
</td></tr>
</table>
<h2>Definition of all functions</h2>
<!-- make_funcdef start -->
<a name="ARRAY_SCAN"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
ARRAY_SCAN</th></tr>
<tr><th>Summary</th><td>Scan all in-use elements stored in VCE's array.</td></tr>
<tr><th>Category</th><td>array</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>ARRAY_SCAN( int arraydescriptor, void* pointer )</b></td>
<tr><th>arg 1</Th><td>int arraydescriptor</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>arg 2</Th><td>void *pointer</td></tr>
<tr><th></th><td>Set address of each array entry to this pointer.
</td></tr>
<tr><th>Return value</th><td>This macro returns no value, since this is not used as a function
but as a loop (like C's for statement). 
</td></tr>
<tr><th>Description</th><td>When you want to scan all elements in an VCE array,
you can use vce_get_array_object_top function.
First of all, fetch the top element from the in-use list.
And afterwards, use the vce_get_array_object_next function repeatedly,
until it returns NULL.
This macro is made available to avoid complication of such process.
Note that this macro fetches allocated array elements
only-those elements in the in-use list.
Even if 1000 is given as the maximum array size,
it will never repeat the loop if no elements is found.
</td></tr>
<tr><th>Example</th><td><pre>
// Process all allocated elements in an array specified by "memory_ind" 
struct client *c;
ARRAY_SCAN( memory_ind, c ){
  do_something_to_the_structure( c );
}
</pre>
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_array_object_next">vce_get_array_object_next</a>
<a href="#vce_get_array_object_top">vce_get_array_object_top</a>
<a href="#vce_init_array">vce_init_array</a>
</td></tr>
</table><br><br>
<a name="ARRAY_SCAN_TYPE"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
ARRAY_SCAN_TYPE</th></tr>
<tr><th>Summary</th><td>A variety of ARRAY_SCAN macro fot use in C++ language</td></tr>
<tr><th>Category</th><td>array</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>ARRAY_SCAN_TYPE( int arraydescriptor void *pointer, typedecl )</b></td>
<tr><th>arg 1</Th><td>int arraydescriptor</td></tr>
<tr><th></th><td>Array descriptor of VCE array.
</td></tr>
<tr><th>arg 2</Th><td>void *pointer</td></tr>
<tr><th></th><td>Set address of each array entry to this pointer.
</td></tr>
<tr><th>arg 3</Th><td> typedecl</td></tr>
<tr><th></th><td>Type of the pointer.
</td></tr>
<tr><th>Return value</th><td>None.
</td></tr>
<tr><th>Description</th><td>ARRAY_SCAN assigns a void pointer to the pointer variable "pointer".
This leads a compilation error however in C++,
because C++ requires casting when assignning void pointer.
Consequently, the ARRAY_SCAN_TYPE macro is given the pointer variable type. 
</td></tr>
<tr><th>See also</th><td>
<a href="#ARRAY_SCAN">ARRAY_SCAN</a>
</td></tr>
</table><br><br>
<a name="ELEMENTOF"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
ELEMENTOF</th></tr>
<tr><th>Summary</th><td>Get number of elements of a fixed-size array.</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int ELEMENTOF(x)</b></td>
<tr><th>arg 1</Th><td>x</td></tr>
<tr><th></th><td>Any C array. (Not pointer)
</td></tr>
<tr><th>Return value</th><td>Number of elements of the array.
</td></tr>
<tr><th>Description</th><td>This macro is actually defined as
<pre>
( sizeof(x) / sizeof((x)[0]) )
</pre>     
 This macro cannot be used for an array allocated by malloc,
 because the size of elements is not determined upon compilation. 
</td></tr>
<tr><th>Example</th><td><pre>
  int hoge[]= {1,2,3,4,5};
  a = ELEMENTOF(hoge);           // numer 5 is in a
</pre>
</td></tr>
</table><br><br>
<a name="FREE"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
FREE</th></tr>
<tr><th>Summary</th><td>Release a memory block allocated with MALLOC function.</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void FREE( void *p )</b></td>
<tr><th>arg 1</Th><td>void *p</td></tr>
<tr><th></th><td>Top address of a memry block which will be freed.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>This function wrap the standard C free function.
It simply logs invocation records of free.
It prints log message when vce_set_verbose_mode 1.
</td></tr>
<tr><th>See also</th><td>
<a href="#MALLOC">MALLOC</a>
<a href="#vce_set_verbose_mode">vce_set_verbose_mode</a>
</td></tr>
</table><br><br>
<a name="GET_16BIT_INT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
GET_16BIT_INT</th></tr>
<tr><th>Summary</th><td>Get 16 bit integer value from buffer</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>unsigned short GET_16BIT_INT( char *p )</b></td>
<tr><th>arg 1</Th><td>char *p</td></tr>
<tr><th></th><td>Top address of source data buffer.
</td></tr>
<tr><th>Return value</th><td>Got value (unsigned short)
</td></tr>
<tr><th>Description</th><td>ntohs is used internally.
It is mainly used for protocol processing,
though the function group in the bin category should
rather be used for more general purposes.
For the MIPS machine architecture (PlayStation(R)2),
VCE implements this macro as a function. 
</td></tr>
<tr><th>See also</th><td>
<a href="#GET_32BIT_INT">GET_32BIT_INT</a>
<a href="#GET_8BIT_INT">GET_8BIT_INT</a>
<a href="#SET_16BIT_INT">SET_16BIT_INT</a>
<a href="#SET_32BIT_INT">SET_32BIT_INT</a>
<a href="#SET_8BIT_INT">SET_8BIT_INT</a>
</td></tr>
</table><br><br>
<a name="GET_16BIT_NATIVEINT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
GET_16BIT_NATIVEINT</th></tr>
<tr><th>Summary</th><td>Get 16bit integer value from any buffer</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>short GET_16BIT_NATIVEINT( char *p )</b></td>
<tr><th>Return value</th><td>Got short value.
</td></tr>
<tr><th>Description</th><td> It does not use ntohs, htons nor others.
A value is copied directly.
For MIPS architecture (PlayStation(R)2 ),
VCE  implements this macro as a function. 
</td></tr>
<tr><th>See also</th><td>
<a href="#GET_32BIT_NATIVEINT">GET_32BIT_NATIVEINT</a>
<a href="#GET_8BIT_NATIVEINT">GET_8BIT_NATIVEINT</a>
</td></tr>
</table><br><br>
<a name="GET_32BIT_INT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
GET_32BIT_INT</th></tr>
<tr><th>Summary</th><td>A macro to get 32bit value from memory buffer.</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>unsigned int GET_32BIT_INT( char *p )</b></td>
<tr><th>arg 1</Th><td>char *p</td></tr>
<tr><th></th><td>Top address of source data.
</td></tr>
<tr><th>Return value</th><td>Got value(int)
</td></tr>
<tr><th>Description</th><td>ntohl is used internally.
This macro is used for binary protocol analysis, however,
if the binary protocol is implemented within an application,
the bin category function group should be used instead.
For the MIPS machine architecture (PlayStation(R)2)
VCE implements this macro as a function. 
</td></tr>
<tr><th>See also</th><td>
<a href="#GET_16BIT_INT">GET_16BIT_INT</a>
<a href="#GET_8BIT_INT">GET_8BIT_INT</a>
<a href="#SET_16BIT_INT">SET_16BIT_INT</a>
<a href="#SET_32BIT_INT">SET_32BIT_INT</a>
<a href="#SET_8BIT_INT">SET_8BIT_INT</a>
</td></tr>
</table><br><br>
<a name="GET_32BIT_NATIVEINT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
GET_32BIT_NATIVEINT</th></tr>
<tr><th>Summary</th><td>Get 32bit integer value from buffer</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int GET_32BIT_NATIVEINT( char *p )</b></td>
<tr><th>Return value</th><td>Got int value.
</td></tr>
<tr><th>Description</th><td>This is a data-fetch macro not using ntohl, htonl nor others.
For MIPS machine architecture (PlayStation(R)2 ),
VCE implements this macro as a function. 
</td></tr>
<tr><th>See also</th><td>
<a href="#GET_16BIT_NATIVEINT">GET_16BIT_NATIVEINT</a>
<a href="#GET_8BIT_NATIVEINT">GET_8BIT_NATIVEINT</a>
</td></tr>
</table><br><br>
<a name="GET_64BIT_INT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
GET_64BIT_INT</th></tr>
<tr><th>Summary</th><td>A macro to get 64bit value from memory buffer.</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>VCEI64 GET_64BIT_INT( char *p )</b></td>
<tr><th>arg 1</Th><td>char *p</td></tr>
<tr><th></th><td>Top address of source data.
</td></tr>
<tr><th>Return value</th><td>Got value(int)
</td></tr>
<tr><th>Description</th><td>ntohl is used internally.
This macro is used for binary protocol analysis, however,
if the binary protocol is implemented within an application,
the bin category function group should be used instead.
For the MIPS machine architecture (PlayStation(R)2)
VCE implements this macro as a function. 
</td></tr>
<tr><th>See also</th><td>
<a href="#GET_16BIT_INT">GET_16BIT_INT</a>
<a href="#GET_8BIT_INT">GET_8BIT_INT</a>
<a href="#SET_16BIT_INT">SET_16BIT_INT</a>
<a href="#SET_32BIT_INT">SET_32BIT_INT</a>
<a href="#SET_8BIT_INT">SET_8BIT_INT</a>
</td></tr>
</table><br><br>
<a name="GET_64BIT_NATIVEINT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
GET_64BIT_NATIVEINT</th></tr>
<tr><th>Summary</th><td>Get 64bit integer value from buffer</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int GET_64BIT_NATIVEINT( char *p )</b></td>
<tr><th>Return value</th><td>Got int value.
</td></tr>
<tr><th>Description</th><td>This is a data-fetch macro not using ntohl, htonl nor others.
For MIPS machine architecture (PlayStation(R)2 ),
VCE implements this macro as a function. 
</td></tr>
<tr><th>See also</th><td>
<a href="#GET_16BIT_NATIVEINT">GET_16BIT_NATIVEINT</a>
<a href="#GET_8BIT_NATIVEINT">GET_8BIT_NATIVEINT</a>
</td></tr>
</table><br><br>
<a name="GET_8BIT_INT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
GET_8BIT_INT</th></tr>
<tr><th>Summary</th><td>Get 8-bit integer from buffer</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>unsigned char GET_8BIT_INT( char *b )</b></td>
<tr><th>arg 1</Th><td>char *b</td></tr>
<tr><th></th><td>Top address of source data buffer.
</td></tr>
<tr><th>Return value</th><td>Got value (unsigned char)
</td></tr>
<tr><th>Description</th><td> This simply fetches a value.
 It is defined to maintain consistency with 32 and 16 bit macro.
</td></tr>
<tr><th>See also</th><td>
<a href="#GET_16BIT_INT">GET_16BIT_INT</a>
<a href="#GET_32BIT_INT">GET_32BIT_INT</a>
<a href="#SET_16BIT_INT">SET_16BIT_INT</a>
<a href="#SET_32BIT_INT">SET_32BIT_INT</a>
<a href="#SET_8BIT_INT">SET_8BIT_INT</a>
</td></tr>
</table><br><br>
<a name="GET_8BIT_NATIVEINT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
GET_8BIT_NATIVEINT</th></tr>
<tr><th>Summary</th><td>Get 8bit integer value from buffer</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>char GET_8BIT_NATIVEINT( char *p )</b></td>
<tr><th>Return value</th><td>Got 8bit value
</td></tr>
<tr><th>Description</th><td>This is defined merely for writing codes consistent with GET_32BIT_NATIVEINT,
GET_16BIT_NATIVEINT and others. 
</td></tr>
<tr><th>See also</th><td>
<a href="#GET_16BIT_NATIVEINT">GET_16BIT_NATIVEINT</a>
<a href="#GET_32BIT_NATIVEINT">GET_32BIT_NATIVEINT</a>
</td></tr>
</table><br><br>
<a name="MALLOC"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
MALLOC</th></tr>
<tr><th>Summary</th><td>A wrapper function for C library malloc().</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void *MALLOC( size_t size )</b></td>
<tr><th>arg 1</Th><td>size_t size</td></tr>
<tr><th></th><td>Size of allocated memory ( in bytes)
</td></tr>
<tr><th>Return value</th><td>Top address of allocated memory block.
</td></tr>
<tr><th>Description</th><td>This calls the malloc() function of the standard C library,
and returns a returned value of malloc as is.
VCE invokes the malloc function only once upon a startup of a program
to allocate a large memory space as possible as it can,
afterwards, it free()s everything upon a cleanup,
not using malloc funcs at all, according to its strategy.
This is because the malloc function is too slow,
or for minimizing variation of behavior due to the
difference in implementation method of the malloc function.
The MALLOC function is used pairing up with the FREE function.
It prints log message when vce_set_verbose_mode 1.
</td></tr>
<tr><th>See also</th><td>
<a href="#FREE">FREE</a>
<a href="#vce_set_verbose_mode">vce_set_verbose_mode</a>
</td></tr>
</table><br><br>
<a name="MAX"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
MAX</th></tr>
<tr><th>Summary</th><td>Compare 2 integer values and return bigger one.</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int MAX(int a, int b)</b></td>
<tr><th>arg 1</Th><td>int a</td></tr>
<tr><th></th><td>First parameter being compared.
Although "int" type is used in this macro's prototype,
but because this is macro, so you can make use of this macro
for any types which accepts integer-comparison operator.
</td></tr>
<tr><th>arg 2</Th><td>int b</td></tr>
<tr><th></th><td>Another parameter being compared.
</td></tr>
<tr><th>Return value</th><td>Got value ( bigger one )
</td></tr>
<tr><th>Description</th><td> This is defined as follows.
 It corresponds to the char, short, int, long, long long, float, double, and VCEI64
 types along with their unsigned types. 
<pre>
   ( (x) > (y) ? (x)  (y) )
</pre>   
</td></tr>
<tr><th>See also</th><td>
<a href="#MIN">MIN</a>
</td></tr>
</table><br><br>
<a name="MIN"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
MIN</th></tr>
<tr><th>Summary</th><td>Compare 2 integer values and return bigger one.</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int MIN(int a, int b )</b></td>
<tr><th>arg 1</Th><td>int a</td></tr>
<tr><th></th><td>First parameter being compared.
Although "int" type is used in this macro's prototype,
but because this is macro, so you can make use of this macro
for any types which accepts integer-comparison operator.
</td></tr>
<tr><th>arg 2</Th><td>int b</td></tr>
<tr><th></th><td>Another parameter being compared.
</td></tr>
<tr><th>Return value</th><td>Result value.
</td></tr>
<tr><th>Description</th><td>This is defined as follows.
It corresponds to the char, short, int, long, long long, float, double, and VCEI64
types along with their unsigned types. 
<Pre>
( (x) < (y) ? (x)  (y) )
</pre>

</td></tr>
<tr><th>See also</th><td>
<a href="#MAX">MAX</a>
</td></tr>
</table><br><br>
<a name="SET_16BIT_INT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
SET_16BIT_INT</th></tr>
<tr><th>Summary</th><td>Copy 16-bit integer to buffer in network byte-order.</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void SET_16BIT_INT( char *b, unsigned short i )</b></td>
<tr><th>arg 1</Th><td>char *b</td></tr>
<tr><th></th><td>Top address of destination buffer.
</td></tr>
<tr><th>arg 2</Th><td>unsigned short i</td></tr>
<tr><th></th><td>Native unsignes short value being copied.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>htons is used internally.
It is mainly used for protocol processing,
though the function group in the bin category should rather be used for
more general purposes.
For the MIPS architecture (PlayStation(R)2 ),
VCE implements this macro as a function. 
</td></tr>
<tr><th>See also</th><td>
<a href="#GET_16BIT_INT">GET_16BIT_INT</a>
<a href="#GET_32BIT_INT">GET_32BIT_INT</a>
<a href="#GET_8BIT_INT">GET_8BIT_INT</a>
<a href="#SET_32BIT_INT">SET_32BIT_INT</a>
<a href="#SET_8BIT_INT">SET_8BIT_INT</a>
</td></tr>
</table><br><br>
<a name="SET_16BIT_NATIVEINT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
SET_16BIT_NATIVEINT</th></tr>
<tr><th>Summary</th><td>Copy 16-bit integer value to any buffer</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void SET_16BIT_NATIVEINT( char *p, short i )</b></td>
<tr><th>arg 1</Th><td>char *p</td></tr>
<tr><th></th><td>Top address of destination buffer.
</td></tr>
<tr><th>arg 2</Th><td>short i</td></tr>
<tr><th></th><td>Native value being copied.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>This macro is not using ntohs, htons nor others inside it.
For MIPS machine architecture(PlayStation(R)2),
VCE implements this macro as a function. 
</td></tr>
<tr><th>See also</th><td>
<a href="#SET_16BIT_NATIVEINT">SET_16BIT_NATIVEINT</a>
<a href="#SET_8BIT_NATIVEINT">SET_8BIT_NATIVEINT</a>
</td></tr>
</table><br><br>
<a name="SET_32BIT_INT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
SET_32BIT_INT</th></tr>
<tr><th>Summary</th><td>Copy 32-bit integer to buffer in network byte-order.</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void SET_32BIT_INT( char *b, unsigned int i )</b></td>
<tr><th>arg 1</Th><td>char *b</td></tr>
<tr><th></th><td>Top address of input data.
</td></tr>
<tr><th>arg 2</Th><td>unsigned int i</td></tr>
<tr><th></th><td>Native int value being copied.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>htonl is used internally.
For MIPS architecture (PlayStation(R)2 ),
VCE  implements this macro as a function.
It can be used for protocol analysis,
but you should rather use the function group in the bin
category for protocol analysis( they make it robust ).
</td></tr>
<tr><th>See also</th><td>
<a href="#GET_16BIT_INT">GET_16BIT_INT</a>
<a href="#GET_32BIT_INT">GET_32BIT_INT</a>
<a href="#SET_16BIT_INT">SET_16BIT_INT</a>
<a href="#SET_8BIT_INT">SET_8BIT_INT</a>
<a href="#SET_8BIT_INT">SET_8BIT_INT</a>
</td></tr>
</table><br><br>
<a name="SET_32BIT_NATIVEINT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
SET_32BIT_NATIVEINT</th></tr>
<tr><th>Summary</th><td>copy 32bit integer value to any buffer</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void SET_32BIT_NATIVEINT( char *p, int i )</b></td>
<tr><th>arg 1</Th><td>char *p</td></tr>
<tr><th></th><td>Top address of destination buffer.
</td></tr>
<tr><th>arg 2</Th><td>int i</td></tr>
<tr><th></th><td>Native value being copied.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td> Copy values directly to output buffer without doing htonl, nor htons.
For MIPS machine architecture (PlayStation(R)2 ),
VCE implements this macro as a function. 
</td></tr>
<tr><th>See also</th><td>
<a href="#SET_16BIT_NATIVEINT">SET_16BIT_NATIVEINT</a>
<a href="#SET_8BIT_NATIVEINT">SET_8BIT_NATIVEINT</a>
</td></tr>
</table><br><br>
<a name="SET_64BIT_INT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
SET_64BIT_INT</th></tr>
<tr><th>Summary</th><td>Copy 32-bit integer to buffer in network byte-order.</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void SET_64BIT_INT( char *b, VCEI64 i )</b></td>
<tr><th>arg 1</Th><td>char *b</td></tr>
<tr><th></th><td>Top address of input data.
</td></tr>
<tr><th>arg 2</Th><td>VCEI64 i</td></tr>
<tr><th></th><td>Native int value being copied.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>htonl is used internally.
For MIPS architecture (PlayStation(R)2 ),
VCE  implements this macro as a function.
It can be used for protocol analysis,
but you should rather use the function group in the bin
category for protocol analysis( they make it robust ).
</td></tr>
<tr><th>See also</th><td>
<a href="#GET_16BIT_INT">GET_16BIT_INT</a>
<a href="#GET_32BIT_INT">GET_32BIT_INT</a>
<a href="#SET_16BIT_INT">SET_16BIT_INT</a>
<a href="#SET_8BIT_INT">SET_8BIT_INT</a>
<a href="#SET_8BIT_INT">SET_8BIT_INT</a>
</td></tr>
</table><br><br>
<a name="SET_64BIT_NATIVEINT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
SET_64BIT_NATIVEINT</th></tr>
<tr><th>Summary</th><td>copy 64bit integer value to any buffer</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void SET_64BIT_NATIVEINT( char *p, VCEI64 i )</b></td>
<tr><th>arg 1</Th><td>char *p</td></tr>
<tr><th></th><td>Top address of destination buffer.
</td></tr>
<tr><th>arg 2</Th><td>int i</td></tr>
<tr><th></th><td>Native value being copied.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td> Copy values directly to output buffer without doing htonl, nor htons.
For MIPS machine architecture (PlayStation(R)2 ),
VCE implements this macro as a function. 
</td></tr>
<tr><th>See also</th><td>
<a href="#SET_16BIT_NATIVEINT">SET_16BIT_NATIVEINT</a>
<a href="#SET_8BIT_NATIVEINT">SET_8BIT_NATIVEINT</a>
</td></tr>
</table><br><br>
<a name="SET_8BIT_INT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
SET_8BIT_INT</th></tr>
<tr><th>Summary</th><td>Copy 8-bit integer to buffer</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void SET_8BIT_INT( char *b, unsigned char i )</b></td>
<tr><th>arg 1</Th><td>char *b</td></tr>
<tr><th></th><td>Top address of destination buffer.
</td></tr>
<tr><th>arg 2</Th><td>unsigned char i</td></tr>
<tr><th></th><td>unsigned char value being copied.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td> This only copies onto a buffer, being available for the purpose
of writing well-formed codes,
maintaining consistency with 32 and 16 bit macro or others. 
</td></tr>
<tr><th>See also</th><td>
<a href="#GET_16BIT_INT">GET_16BIT_INT</a>
<a href="#GET_32BIT_INT">GET_32BIT_INT</a>
<a href="#GET_8BIT_INT">GET_8BIT_INT</a>
<a href="#SET_16BIT_INT">SET_16BIT_INT</a>
<a href="#SET_32BIT_INT">SET_32BIT_INT</a>
</td></tr>
</table><br><br>
<a name="SET_8BIT_NATIVEINT"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
SET_8BIT_NATIVEINT</th></tr>
<tr><th>Summary</th><td>Copy 8bit integer value to any buffer</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void SET_8BIT_NATIVEINT( char *p, char i )</b></td>
<tr><th>arg 1</Th><td>char *P</td></tr>
<tr><th></th><td>Top address of destiniation buffer.
</td></tr>
<tr><th>arg 2</Th><td>char i</td></tr>
<tr><th></th><td>Native value being copied.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>This macro is only for writing well-formed codes,
maintaining consistency with SET_16BIT_NATIVEINT,SET_32BIT_NATIVEINT. 
</td></tr>
<tr><th>See also</th><td>
<a href="#SET_16BIT_NATIVEINT">SET_16BIT_NATIVEINT</a>
<a href="#SET_8BIT_NATIVEINT">SET_8BIT_NATIVEINT</a>
</td></tr>
</table><br><br>
<a name="STRERR"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
STRERR</th></tr>
<tr><th>Summary</th><td>Get string of latest VCE error</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>char *STRERR</b></td>
<tr><th>Return value</th><td>Pointer to string explaining the error code.
</td></tr>
<tr><th>Description</th><td>STRERR macro is defined as
<pre>
(vce_strerror( vce_get_last_error() ))
</pre>
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_last_error">vce_get_last_error</a>
<a href="#vce_strerror">vce_strerror</a>
</td></tr>
</table><br><br>
<a name="vce_alloc_array_object"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_alloc_array_object</th></tr>
<tr><th>Summary</th><td>Allocate an unused element of a VCE array.</td></tr>
<tr><th>Category</th><td>array</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void * vce_alloc_array_object( int index )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Array descriptor to specify VCE array.
</td></tr>
<tr><th>Return value</th><td>The top address of an allocated array element.
The null pointer is returned in case that all the element is
already used.
Error code can be obtained in vce_get_last_error function.
</td></tr>
<tr><th>Description</th><td>Search through empty list of VCE array and
then return a pointer if there is any available element.
This function never write data onto the contents of a newly allocated
memory.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_free_array_object">vce_free_array_object</a>
<a href="#vce_free_array_object_all">vce_free_array_object_all</a>
<a href="#vce_init_array">vce_init_array</a>
</td></tr>
</table><br><br>
<a name="vce_analyzer_analyze"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_analyzer_analyze</th></tr>
<tr><th>Summary</th><td>Analyze a protocol.</td></tr>
<tr><th>Category</th><td>analyzer</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_analyzer_analyze( analyzer_t *a, char *data, int data_len, int is_fail )</b></td>
<tr><th>arg 1</Th><td>analyzer_t *a</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>arg 3</Th><td>int data_len</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>arg 4</Th><td>int is_fail</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td>PENDING
</td></tr>
<tr><th>See also</th><td>
<a href="# vce_analyzer_clear"> vce_analyzer_clear</a>
<a href="# vce_analyzer_get_state_string"> vce_analyzer_get_state_string</a>
<a href="#vce_analyzer_init">vce_analyzer_init</a>
</td></tr>
</table><br><br>
<a name="vce_analyzer_clear"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_analyzer_clear</th></tr>
<tr><th>Summary</th><td>Clear an analyzer.</td></tr>
<tr><th>Category</th><td>analyzer</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_analyzer_clear( analyzer_t *a )</b></td>
<tr><th>arg 1</Th><td>analyzer_t *a</td></tr>
<tr><th></th><td></td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td>PENDING
</td></tr>
<tr><th>See also</th><td>
<a href="# vce_analyzer_analyze"> vce_analyzer_analyze</a>
<a href="# vce_analyzer_get_state_string"> vce_analyzer_get_state_string</a>
<a href="#vce_analyzer_init">vce_analyzer_init</a>
</td></tr>
</table><br><br>
<a name="vce_analyzer_get_state_string"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_analyzer_get_state_string</th></tr>
<tr><th>Summary</th><td>Clear an analyzer.</td></tr>
<tr><th>Category</th><td>analyzer</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_analyzer_get_state_string( analyzer_t *a, char *buf, int buf_len )</b></td>
<tr><th>arg 1</Th><td>analyzer_t *a</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 2</Th><td>char *buf</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 3</Th><td>int buf_len</td></tr>
<tr><th></th><td></td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td>PENDING
</td></tr>
<tr><th>See also</th><td>
<a href="# vce_analyzer_analyze"> vce_analyzer_analyze</a>
<a href="# vce_analyzer_get_state_string"> vce_analyzer_get_state_string</a>
<a href="#vce_analyzer_init">vce_analyzer_init</a>
</td></tr>
</table><br><br>
<a name="vce_analyzer_init"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_analyzer_init</th></tr>
<tr><th>Summary</th><td>initialize analyzer structure.</td></tr>
<tr><th>Category</th><td>analyzer</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_analyzer_init( analyzer_t *a, int protocol_max )</b></td>
<tr><th>arg 1</Th><td>analyzer_t *a</td></tr>
<tr><th></th><td>A address of an analyzer_t structure
</td></tr>
<tr><th>arg 2</Th><td>int protocol_max</td></tr>
<tr><th></th><td>Number of protocols. It is important that more than 256 or not.
</td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td>PENDING
</td></tr>
<tr><th>See also</th><td>
<a href="# vce_analyzer_clear"> vce_analyzer_clear</a>
<a href="# vce_analyzer_get_state_string"> vce_analyzer_get_state_string</a>
<a href="#vce_analyzer_analyze">vce_analyzer_analyze</a>
</td></tr>
</table><br><br>
<a name="vce_array_object_inuse"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_array_object_inuse</th></tr>
<tr><th>Summary</th><td>Know a VCE array object is currently used or not</td></tr>
<tr><th>Category</th><td>array</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_array_object_inuse( int index, void *p )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Integer discriptor value to specify VCE array
</td></tr>
<tr><th>arg 2</Th><td>void *p</td></tr>
<tr><th></th><td>Pointer to an VCE array object
</td></tr>
<tr><th>Return value</th><td>Returns 1 if the object is currently used,
otherwize zero. Returns minus error code if given arguments
are invalid ( for example index is inefficient, or pointer is
out of range )
</td></tr>
<tr><th>Description</th><td>You know if an array object is used(not freed) in an VCE array.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_alloc_array_object">vce_alloc_array_object</a>
<a href="#vce_free_array_object">vce_free_array_object</a>
</td></tr>
</table><br><br>
<a name="vce_atoi"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_atoi</th></tr>
<tr><th>Summary</th><td>Convert C string into a int value with simple calcuration.</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_atoi( char *p )</b></td>
<tr><th>arg 1</Th><td>char *p</td></tr>
<tr><th></th><td>Top address of string being converted.
</td></tr>
<tr><th>Return value</th><td>Converted value. If bad input, returns 0 in any case.
</td></tr>
<tr><th>Description</th><td>The atoi routine with the simple computation function.
The following inputs are accepted
<pre>
"12345"      12345
"-12345"    -12345
"123+123"    246
"123-123"    0
"123+-123"    0
"-123-123"   -246
"123*3"      369
"-123*3"    -369
"-123*-3"    369
"123+2*2"    250  Note that "+" is determined first.
"1+1+1+1+1"    5  Any number of linking is allowed.
"1+1+  1+1  +1"    5  Blank characters (TAB, SPACE) are skipped in reading.
</pre>
Dedicated to decimal numbers.
Note that operators are determined from left to right regardless of
connection weight of operators, like an operation of calculators.
atoi of libc is used internally.
If it returns "0" across the board when the conversion of an input
is not possible, the figure "0" cannot be determined whether
an error or valid value.
Therefore, in case of conversion failure,
it is enabled to use the vce_get_last_error function to detect
VCE_EFORMAT, in order to determine such "0".
</td></tr>
<tr><th>Bugs/TODO</th><td>This function is still at the experimental stage,
so it may be not performing stably-sometimes results make no sense.
</td></tr>
</table><br><br>
<a name="vce_binary_pack"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_pack</th></tr>
<tr><th>Summary</th><td>Make a byte array from an array of structure. (obsolete)</td></tr>
<tr><th>Category</th><td>bin</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_binary_pack( struct bin_info *bi, int bn, char *outp, int len )</b></td>
<tr><th>arg 1</Th><td>struct bin_info *bi</td></tr>
<tr><th></th><td>Top address of an array of bin_info structure
</td></tr>
<tr><th>arg 2</Th><td>int bn</td></tr>
<tr><th></th><td>Number of elements of bin_info structure array
</td></tr>
<tr><th>arg 3</Th><td>char *outp</td></tr>
<tr><th></th><td>Output buffer
</td></tr>
<tr><th>arg 4</Th><td>int len</td></tr>
<tr><th></th><td>Length of output buffer ( in bytes)
</td></tr>
<tr><th>Return value</th><td>Number of bytes written in output buffer
</td></tr>
<tr><th>Description</th><td>It Packs data stored in the bin_info structure and converts it
to a series of byte strings. This is mainly used for
protocol processing.
</td></tr>
<tr><th>Bugs/TODO</th><td>Now this function is already replaced with binary push/pop functions.
</td></tr>
</table><br><br>
<a name="vce_binary_pop_nb_i1"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_pop_nb_i1</th></tr>
<tr><th>Summary</th><td>Pop a 1-byte integer(char) from a buffer</td></tr>
<tr><th>Category</th><td>bin</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_binary_pop_nb_i1( char *in, int len, int ofs, char *out)</b></td>
<tr><th>arg 1</Th><td>char *in</td></tr>
<tr><th></th><td>Top address of input buffer
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>Length of input data buffer
</td></tr>
<tr><th>arg 3</Th><td>int ofs</td></tr>
<tr><th></th><td>Number of offset bytes from the beginning of the input buffer
</td></tr>
<tr><th>arg 4</Th><td>char *out</td></tr>
<tr><th></th><td>char pointer to store poped data.
</td></tr>
<tr><th>Return value</th><td>The new ofs value that moves through fetching one byte.
</td></tr>
<tr><th>Description</th><td>This fetches data packed by vce_binary_push_nb_i1function.
An offset advances by 1 all the time; however, it
returns a negative error code in case of failure (such as data shortage).
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_push_nb_i1">vce_binary_push_nb_i1</a>
</td></tr>
</table><br><br>
<a name="vce_binary_pop_nb_i2"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_pop_nb_i2</th></tr>
<tr><th>Summary</th><td>Pop a 2-byte integer(short) from a buffer</td></tr>
<tr><th>Category</th><td>bin</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_binary_pop_nb_i2( char *in, int len, int ofs, short *out )</b></td>
<tr><th>arg 1</Th><td>char *in</td></tr>
<tr><th></th><td>Top address of input buffer
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>Length of input data buffer
</td></tr>
<tr><th>arg 3</Th><td>int ofs</td></tr>
<tr><th></th><td>Number of offset bytes from the beginning of the input buffer
</td></tr>
<tr><th>arg 4</Th><td>short *out</td></tr>
<tr><th></th><td>short pointer to store poped data.
</td></tr>
<tr><th>Return value</th><td>The new ofs value that moves through fetching 2 bytes.
</td></tr>
<tr><th>Description</th><td>This fetches data packed with vce_binary_push_nb_i2 function.
An offset advances by 2 all the time; however, it
returns a negative error code in case of failure (such as data shortage).
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_push_nb_i2">vce_binary_push_nb_i2</a>
</td></tr>
</table><br><br>
<a name="vce_binary_pop_nb_i4"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_pop_nb_i4</th></tr>
<tr><th>Summary</th><td>Pop a 4-byte integer(int) from a buffer</td></tr>
<tr><th>Category</th><td>bin</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_binary_pop_nb_i4( char *in, int len, int ofs, int *out )</b></td>
<tr><th>arg 1</Th><td>char *in</td></tr>
<tr><th></th><td>Top address of input buffer
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>Length of input data buffer
</td></tr>
<tr><th>arg 3</Th><td>int ofs</td></tr>
<tr><th></th><td>Number of offset bytes from the beginning of the input buffer
</td></tr>
<tr><th>arg 4</Th><td>int *out</td></tr>
<tr><th></th><td>int pointer to store poped data.
</td></tr>
<tr><th>Return value</th><td>The new ofs value that moves through fetching 4 bytes.
</td></tr>
<tr><th>Description</th><td>This fetches data packed with vce_binary_push_nb_i4 function.
An offset advances by 4 all the time; however, it
returns a negative error code in case of failure (such as data shortage).
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_push_nb_i4">vce_binary_push_nb_i4</a>
</td></tr>
</table><br><br>
<a name="vce_binary_pop_nb_i8"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_pop_nb_i8</th></tr>
<tr><th>Summary</th><td>Pop a 8-byte integer(int) from a buffer</td></tr>
<tr><th>Category</th><td>bin</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_binary_pop_nb_i8( char *in, int len, int ofs, VCEI64 *out )</b></td>
<tr><th>arg 1</Th><td>char *in</td></tr>
<tr><th></th><td>Top address of input buffer
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>Length of input data buffer
</td></tr>
<tr><th>arg 3</Th><td>int ofs</td></tr>
<tr><th></th><td>Number of offset bytes from the beginning of the input buffer
</td></tr>
<tr><th>arg 4</Th><td>VCEI64 *out</td></tr>
<tr><th></th><td>int pointer to store poped data.
</td></tr>
<tr><th>Return value</th><td>The new ofs value that moves through fetching 8 bytes.
</td></tr>
<tr><th>Description</th><td>This fetches data packed with vce_binary_push_nb_i8 function.
An offset advances by 8 all the time; however, it
returns a negative error code in case of failure (such as data shortage).
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_push_nb_i8">vce_binary_push_nb_i8</a>
</td></tr>
</table><br><br>
<a name="vce_binary_pop_nb_ia1"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_pop_nb_ia1</th></tr>
<tr><th>Summary</th><td>Pop an array of 1-byte integer(char) from a buffer</td></tr>
<tr><th>Category</th><td>bin</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_binary_pop_nb_ia1( char *src, int len, int ofs, char *out, int *outlen )</b></td>
<tr><th>arg 1</Th><td>char *in</td></tr>
<tr><th></th><td>Top address of input data buffer
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>Length of input data buffer
</td></tr>
<tr><th>arg 3</Th><td>int ofs</td></tr>
<tr><th></th><td>Number of offset bytes from the beginning of the input buffer
</td></tr>
<tr><th>arg 4</Th><td>char *out</td></tr>
<tr><th></th><td>Top address of char array to store poped data
</td></tr>
<tr><th>arg 5</Th><td>int *outlen</td></tr>
<tr><th></th><td>value-result parameter. This parameter must contain number of elements
of an array "out" when calling, and returns number of elements
actually filled into "out".
</td></tr>
<tr><th>Return value</th><td>The new ofs value that moves through fetching an array.
It returns a negative error code as fetching fails.
</td></tr>
<tr><th>Description</th><td>This fetches data packed with vce_binary_push_nb_ia1 function.
In case of data shortage, or that an array used
for fetching is too small, it returns a negative error code
indicating failure instead of fetching halfway. This is VCE's
policy on binary operation.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_push_nb_ia1">vce_binary_push_nb_ia1</a>
</td></tr>
</table><br><br>
<a name="vce_binary_pop_nb_ia2"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_pop_nb_ia2</th></tr>
<tr><th>Summary</th><td>Pop an array of 2-byte integer(short) from a buffer</td></tr>
<tr><th>Category</th><td>bin</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_binary_pop_nb_ia2( char *src, int len, int ofs, short *out, int *outlen )</b></td>
<tr><th>arg 1</Th><td>char *in</td></tr>
<tr><th></th><td>Top address of input buffer.
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>Length of input data buffer
</td></tr>
<tr><th>arg 3</Th><td>int ofs</td></tr>
<tr><th></th><td>Number of offset bytes from the beginning of the input buffer
</td></tr>
<tr><th>arg 4</Th><td>short *out</td></tr>
<tr><th></th><td>pointer to short array to save poped data.
</td></tr>
<tr><th>arg 5</Th><td>int *outlen</td></tr>
<tr><th></th><td>value-result parameter. This parameter must contain number of elements
of an array "out" when calling, and returns number of elements
actually filled into "out".
</td></tr>
<tr><th>Return value</th><td>The new ofs value that moves through fetching an array.
It returns a negative error code as fetching fails.
</td></tr>
<tr><th>Description</th><td>This fetches data packed with vce_binary_push_nb_ia2 function.
In case of data shortage, or that an array used
for fetching is too small, it returns a negative error code
indicating failure instead of fetching halfway. This is VCE's
policy on binary operation.
After being changed its order from network byte to native, data is stored.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_push_nb_ia2">vce_binary_push_nb_ia2</a>
</td></tr>
</table><br><br>
<a name="vce_binary_pop_nb_ia4"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_pop_nb_ia4</th></tr>
<tr><th>Summary</th><td>Pop an array of 4-byte integer(int) from a buffer</td></tr>
<tr><th>Category</th><td>bin</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_binary_pop_nb_ia4( char *src, int len, int ofs, int *out, int *outlen )</b></td>
<tr><th>arg 1</Th><td>char *in</td></tr>
<tr><th></th><td>Top address of input buffer
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>Length of input data buffer
</td></tr>
<tr><th>arg 3</Th><td>int ofs</td></tr>
<tr><th></th><td>Number of offset bytes from the beginning of the input buffer
</td></tr>
<tr><th>arg 4</Th><td>int *out</td></tr>
<tr><th></th><td>Top address of int array to store poped data
</td></tr>
<tr><th>arg 5</Th><td>int *outlen</td></tr>
<tr><th></th><td>value-result parameter. This parameter must contain number of elements
of an array "out" when calling, and returns number of elements
actually filled into "out".
</td></tr>
<tr><th>Return value</th><td>The new ofs value that moves through fetching an array.
It returns a negative error code as fetching fails.
</td></tr>
<tr><th>Description</th><td>This fetches data packed with vce_binary_push_nb_ia4 function.
In case of data shortage, or that an array used
for fetching is too small, it returns a negative
error code indicating failure instead of fetching halfway.
This is VCE's policy on binary operation.
Having been changed its order from network byte to native, data is stored.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_push_nb_ia4">vce_binary_push_nb_ia4</a>
</td></tr>
</table><br><br>
<a name="vce_binary_pop_nb_ia8"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_pop_nb_ia8</th></tr>
<tr><th>Summary</th><td>Pop an array of 8-byte integer(int) from a buffer</td></tr>
<tr><th>Category</th><td>bin</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_binary_pop_nb_ia8( char *src, int len, int ofs, VCEI64 *out, int *outlen )</b></td>
<tr><th>arg 1</Th><td>char *in</td></tr>
<tr><th></th><td>Top address of input buffer
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>Length of input data buffer
</td></tr>
<tr><th>arg 3</Th><td>int ofs</td></tr>
<tr><th></th><td>Number of offset bytes from the beginning of the input buffer
</td></tr>
<tr><th>arg 4</Th><td>VCEI64 *out</td></tr>
<tr><th></th><td>Top address of int array to store poped data
</td></tr>
<tr><th>arg 5</Th><td>int *outlen</td></tr>
<tr><th></th><td>value-result parameter. This parameter must contain number of elements
of an array "out" when calling, and returns number of elements
actually filled into "out".
</td></tr>
<tr><th>Return value</th><td>The new ofs value that moves through fetching an array.
It returns a negative error code as fetching fails.
</td></tr>
<tr><th>Description</th><td>This fetches data packed with vce_binary_push_nb_ia8 function.
In case of data shortage, or that an array used
for fetching is too small, it returns a negative
error code indicating failure instead of fetching halfway.
This is VCE's policy on binary operation.
Having been changed its order from network byte to native, data is stored.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_push_nb_ia8">vce_binary_push_nb_ia8</a>
</td></tr>
</table><br><br>
<a name="vce_binary_pop_nb_stra"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_pop_nb_stra</th></tr>
<tr><th>Summary</th><td>Pop an array of strings from a buffer</td></tr>
<tr><th>Category</th><td>bin</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_binary_pop_nb_stra( char *src, int len, int ofs, char **out, int *strnum, int eachmax )</b></td>
<tr><th>arg 1</Th><td>char *in</td></tr>
<tr><th></th><td>Top address of input buffer
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>Length of input data buffer
</td></tr>
<tr><th>arg 3</Th><td>int ofs</td></tr>
<tr><th></th><td>Number of offset bytes from the beginning of the input buffer
</td></tr>
<tr><th>arg 4</Th><td>char **out</td></tr>
<tr><th></th><td>Top address of an array of pointer to char.
</td></tr>
<tr><th>arg 5</Th><td>int *strnum</td></tr>
<tr><th></th><td>value-result parameter. This parameter must contain number of elements
of an array "out" when calling, and returns number of elements
actually filled into "out".
</td></tr>
<tr><th>arg 6</Th><td>int eachmax</td></tr>
<tr><th></th><td>Max length of each strings saved in "out".
</td></tr>
<tr><th>Return value</th><td>The new ofs value that moves through fetching an array.
It returns a negative error code as fetching fails.
</td></tr>
<tr><th>Description</th><td>This fetches data packed with vce_binary_push_nb_stra function.
In case of data shortage, or that an array used for fetching is too
small, it returns a negative error code indicating failure instead
of fetching halfway.
This is VCE's policy on binary operation.
Since character strings are copied onto the character string array
designated by the out argument, memory space for copying must be
allocated by the application using this function.(refer to sample codes)
</td></tr>
<tr><th>Example</th><td>  char *orig_data[] = { "foo", "bar" };
  char packed[1000];
  char buf[3][100];
  char *out[3] = { buf[0] , buf[1], buf[2] }; // you can use C's "for" here
  int new_ofs,strnum,packed_len;
  packed_len = vce_binary_push_nb_stra( packed, sizeof(packed), 0, orig_data, 3, 100 );
  strnum = 3;
  new_ofs = vce_binary_pop_nb_stra( packed, packed_len, 0, out,&strnum, 100 );
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_push_nb_stra">vce_binary_push_nb_stra</a>
</td></tr>
</table><br><br>
<a name="vce_binary_push_nb_i1"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_push_nb_i1</th></tr>
<tr><th>Summary</th><td>Push 1-byte integer(char) to a buffer</td></tr>
<tr><th>Category</th><td>bin</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_binary_push_nb_i1( char *out, int ofs, int maxlen, char c )</b></td>
<tr><th>arg 1</Th><td>char *out</td></tr>
<tr><th></th><td>Top address of output buffer
</td></tr>
<tr><th>arg 2</Th><td>int ofs</td></tr>
<tr><th></th><td>Number of offset bytes from the beginning of the output buffer
</td></tr>
<tr><th>arg 3</Th><td>int maxlen</td></tr>
<tr><th></th><td>Length of output buffer
</td></tr>
<tr><th>arg 4</Th><td>char c</td></tr>
<tr><th></th><td>Source data which will be written into output buffer
</td></tr>
<tr><th>Return value</th><td>New offset value. This value is changed by pushing 1 byte.
In this function, new value is always ofs + 1.
Returns minus error indicator value when any error.
</td></tr>
<tr><th>Description</th><td>This is one of function groups for binary packer that is used as
defining binary protocol. This is used by gen.rb protocol generator.
You can fetch data by the corresponding vce_binary_pop_nb_i1function.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_pop_nb_i1">vce_binary_pop_nb_i1</a>
</td></tr>
</table><br><br>
<a name="vce_binary_push_nb_i2"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_push_nb_i2</th></tr>
<tr><th>Summary</th><td>Push 2-byte integer(short) to a buffer</td></tr>
<tr><th>Category</th><td>bin</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_binary_push_nb_i2( char *out, int ofs, int maxlen, short s )</b></td>
<tr><th>arg 1</Th><td>char *out</td></tr>
<tr><th></th><td>Top address of output buffer
</td></tr>
<tr><th>arg 2</Th><td>int ofs</td></tr>
<tr><th></th><td>Number of offset bytes from the beginning of the output buffer
</td></tr>
<tr><th>arg 3</Th><td>int maxlen</td></tr>
<tr><th></th><td>Length of output buffer
</td></tr>
<tr><th>arg 4</Th><td>short s</td></tr>
<tr><th></th><td>Source data to be pushed
</td></tr>
<tr><th>Return value</th><td>This returns the new ofs value resulted from a movement of
ofs through pushing 2 bytes.
This particular function returns ofs + 2 all the time.
When it fails to push, it returns a negative error code.
</td></tr>
<tr><th>Description</th><td>In compliance with VCE's binary packer policy,
it will never destroy data as pushing data of 2 bytes or larger into a
buffer.
It will either push entire data certainly or fail completely.
You can fetch data by corresponding
vce_binary_pop_nb_i2 function.
Data is output on the network byte order.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_pop_nb_i2">vce_binary_pop_nb_i2</a>
</td></tr>
</table><br><br>
<a name="vce_binary_push_nb_i4"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_push_nb_i4</th></tr>
<tr><th>Summary</th><td>Push 4-byte integer(int) to a buffer</td></tr>
<tr><th>Category</th><td>bin</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_binary_push_nb_i4( char *out, int ofs, int maxlen, int i )</b></td>
<tr><th>arg 1</Th><td>char *out</td></tr>
<tr><th></th><td>Top address of output buffer
</td></tr>
<tr><th>arg 2</Th><td>int ofs</td></tr>
<tr><th></th><td>Number of offset bytes from the beginning of the output buffer
</td></tr>
<tr><th>arg 3</Th><td>int maxlen</td></tr>
<tr><th></th><td>Length of output buffer
</td></tr>
<tr><th>arg 4</Th><td>int i</td></tr>
<tr><th></th><td>Source data to be pushed
</td></tr>
<tr><th>Return value</th><td>This function returns the new ofs value resulted
from a movement of ofs through pushing 4 bytes.
This particular function returns ofs + 4 all the time.
When it fails to push, it returns a negative error code.
</td></tr>
<tr><th>Description</th><td>In compliance with VCE's binary packer policy,
it will never destroy data as pushing data of 4 bytes or larger into a
buffer.
It will either push entire data certainly or fail completely.
You can fetch data by corresponding
vce_binary_pop_nb_I4 function.
Data is output on the network in byte order.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_pop_nb_i4">vce_binary_pop_nb_i4</a>
</td></tr>
</table><br><br>
<a name="vce_binary_push_nb_i8"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_push_nb_i8</th></tr>
<tr><th>Summary</th><td>Push 8-byte integer(VCEI64) to a buffer</td></tr>
<tr><th>Category</th><td>bin</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_binary_push_nb_i8( char *out, int ofs, int maxlen, VCEI64 i )</b></td>
<tr><th>arg 1</Th><td>char *out</td></tr>
<tr><th></th><td>Top address of output buffer
</td></tr>
<tr><th>arg 2</Th><td>int ofs</td></tr>
<tr><th></th><td>Number of offset bytes from the beginning of the output buffer
</td></tr>
<tr><th>arg 3</Th><td>int maxlen</td></tr>
<tr><th></th><td>Length of output buffer
</td></tr>
<tr><th>arg 4</Th><td>VCEI64 i</td></tr>
<tr><th></th><td>Source data to be pushed
</td></tr>
<tr><th>Return value</th><td>This function returns the new ofs value resulted
from a movement of ofs through pushing 8 bytes.
This particular function returns ofs + 8 all the time.
When it fails to push, it returns a negative error code.
</td></tr>
<tr><th>Description</th><td>In compliance with VCE's binary packer policy,
it will never destroy data as pushing data of 8 bytes or larger into a
buffer.
It will either push entire data certainly or fail completely.
You can fetch data by corresponding
vce_binary_pop_nb_i8 function.
Data is output on the network in byte order.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_pop_nb_i8">vce_binary_pop_nb_i8</a>
</td></tr>
</table><br><br>
<a name="vce_binary_push_nb_ia1"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_push_nb_ia1</th></tr>
<tr><th>Summary</th><td>Push an array of 1-byte integer(char) to a buffer</td></tr>
<tr><th>Category</th><td>bin</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_binary_push_nb_ia1( char *out, int ofs, int maxlen, char *ia, int num )</b></td>
<tr><th>arg 1</Th><td>char *out</td></tr>
<tr><th></th><td>Top address of output buffer
</td></tr>
<tr><th>arg 2</Th><td>int ofs</td></tr>
<tr><th></th><td>Number of offset bytes from the beginning of the output buffer
</td></tr>
<tr><th>arg 3</Th><td>int maxlen</td></tr>
<tr><th></th><td>Length of output buffer
</td></tr>
<tr><th>arg 4</Th><td>char *ia</td></tr>
<tr><th></th><td>Top address of an array of char(1byte integer) type
</td></tr>
<tr><th>arg 5</Th><td>int num</td></tr>
<tr><th></th><td>Number of elements being pushed
</td></tr>
<tr><th>Return value</th><td>Return new offset value.
Return minus error code when failed to push.
</td></tr>
<tr><th>Description</th><td>This pushes the contents of a char type array into the output buffer.
You can fetch data by corresponding
vce_binary_pop_nb_ia1 function.
When length of the output buffer is shorter than needed,
it returns a negative error code
(VCE_EFULL), instead of destroying it.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_pop_nb_ia1">vce_binary_pop_nb_ia1</a>
</td></tr>
</table><br><br>
<a name="vce_binary_push_nb_ia2"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_push_nb_ia2</th></tr>
<tr><th>Summary</th><td>Push an array of 2-byte integer(short) to a buffer</td></tr>
<tr><th>Category</th><td>bin</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_binary_push_nb_ia2( char *out, int ofs, int maxlen, short *ia, int num )</b></td>
<tr><th>arg 1</Th><td>char *out</td></tr>
<tr><th></th><td>Top address of output buffer
</td></tr>
<tr><th>arg 2</Th><td>int ofs</td></tr>
<tr><th></th><td>Number of offset bytes from the beginning of the output buffer
</td></tr>
<tr><th>arg 3</Th><td>int maxlen</td></tr>
<tr><th></th><td>Length of output buffer
</td></tr>
<tr><th>arg 4</Th><td>short *ia</td></tr>
<tr><th></th><td>Top address of an array of short(2byte integer) type
</td></tr>
<tr><th>arg 5</Th><td>int num</td></tr>
<tr><th></th><td>Number of elements being pushed
</td></tr>
<tr><th>Return value</th><td>This returns the new offset which has moved through outputting.
In case of output failure, it returns a negative error code.
</td></tr>
<tr><th>Description</th><td>This pushes the contents of a short type array into the output buffer.
You can fetch data by corresponding
vce_binary_pop_nb_ia2 function.
All data is saved in network byte order.
When length of the output buffer is
short, it returns a negative error code (VCE_EFULL),
instead of destroying it.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_pop_nb_ia2">vce_binary_pop_nb_ia2</a>
</td></tr>
</table><br><br>
<a name="vce_binary_push_nb_ia4"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_push_nb_ia4</th></tr>
<tr><th>Summary</th><td>Push an array of 4-byte integer(int) to a buffer</td></tr>
<tr><th>Category</th><td>bin</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_binary_push_nb_ia4( char *out, int ofs, int maxlen, int *ia, int num )</b></td>
<tr><th>arg 1</Th><td>char *out</td></tr>
<tr><th></th><td>Top address of output buffer
</td></tr>
<tr><th>arg 2</Th><td>int ofs</td></tr>
<tr><th></th><td>Number of offset bytes from the beginning of the output buffer
</td></tr>
<tr><th>arg 3</Th><td>int maxlen</td></tr>
<tr><th></th><td>Length of output buffer
</td></tr>
<tr><th>arg 4</Th><td>int *ia</td></tr>
<tr><th></th><td>Top address of an array of int(4byte integer) type
</td></tr>
<tr><th>arg 5</Th><td>int num</td></tr>
<tr><th></th><td>Number of elements being pushed
</td></tr>
<tr><th>Return value</th><td>This returns the new offset which has moved through outputting.
In case of output failure, it returns a negative error code.
</td></tr>
<tr><th>Description</th><td>This pushes the contents of an int type array into the output buffer.
You can fetch data by corresponding vce_binary_pop_nb_ia4 function.
All data is saved in network byte order.
When length of the output buffer is short,
it returns a negative error code (VCE_EFULL), instead of destroying it.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_pop_nb_ia4">vce_binary_pop_nb_ia4</a>
</td></tr>
</table><br><br>
<a name="vce_binary_push_nb_ia8"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_push_nb_ia8</th></tr>
<tr><th>Summary</th><td>Push an array of 8-byte integer(VCEI64) to a buffer</td></tr>
<tr><th>Category</th><td>bin</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_binary_push_nb_ia8( char *out, int ofs, int maxlen, VCEI64 *ia, int num )</b></td>
<tr><th>arg 1</Th><td>char *out</td></tr>
<tr><th></th><td>Top address of output buffer
</td></tr>
<tr><th>arg 2</Th><td>int ofs</td></tr>
<tr><th></th><td>Number of offset bytes from the beginning of the output buffer
</td></tr>
<tr><th>arg 3</Th><td>int maxlen</td></tr>
<tr><th></th><td>Length of output buffer
</td></tr>
<tr><th>arg 4</Th><td>VCEI64 *ia</td></tr>
<tr><th></th><td>Top address of an array of int(4byte integer) type
</td></tr>
<tr><th>arg 5</Th><td>int num</td></tr>
<tr><th></th><td>Number of elements being pushed
</td></tr>
<tr><th>Return value</th><td>This returns the new offset which has moved through outputting.
In case of output failure, it returns a negative error code.
</td></tr>
<tr><th>Description</th><td>This pushes the contents of an int type array into the output buffer.
You can fetch data by corresponding vce_binary_pop_nb_ia8 function.
All data is saved in network byte order.
When length of the output buffer is short,
it returns a negative error code (VCE_EFULL), instead of destroying it.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_pop_nb_ia8">vce_binary_pop_nb_ia8</a>
</td></tr>
</table><br><br>
<a name="vce_binary_push_nb_stra"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_push_nb_stra</th></tr>
<tr><th>Summary</th><td>Push null-terminated string array to a buffer</td></tr>
<tr><th>Category</th><td>bin</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_binary_push_nb_stra( char *out, int ofs, int maxlen, char **stra, int num, int eachmax )</b></td>
<tr><th>arg 1</Th><td>char *out</td></tr>
<tr><th></th><td>Top address of output buffer
</td></tr>
<tr><th>arg 2</Th><td>int ofs</td></tr>
<tr><th></th><td>Number of offset bytes from the beginning of the output buffer
</td></tr>
<tr><th>arg 3</Th><td>int maxlen</td></tr>
<tr><th></th><td>Length of output buffer
</td></tr>
<tr><th>arg 4</Th><td>char **stra</td></tr>
<tr><th></th><td>An array of string pointers, which will be pushed into output buffer
</td></tr>
<tr><th>arg 5</Th><td>int num</td></tr>
<tr><th></th><td>Number of pointers contained in **stra argument
</td></tr>
<tr><th>arg 6</Th><td>int eachmax</td></tr>
<tr><th></th><td>Max length of each strings contained in **stra argument.
If length of even one string goes longer than this value,
this function will return error code.
</td></tr>
<tr><th>Return value</th><td>The new ofs value which has moved through outputting.
When it fails to push because a buffer is full or otherwise,
it returns a negative error code.
</td></tr>
<tr><th>Description</th><td>This packs a character string into binary data,
and adds it to a buffer.
The argument eachmax is added in order to
enable a restriction on the maximum number of letters of each
character string. When num is 0, NULL can be designated as stra.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_pop_nb_stra">vce_binary_pop_nb_stra</a>
</td></tr>
</table><br><br>
<a name="vce_binary_unpack"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_binary_unpack</th></tr>
<tr><th>Summary</th><td>Unpack binary char array into an array of struct.(obsolete)</td></tr>
<tr><th>Category</th><td>bin</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_binary_unpack( struct bin_info *bi, int bn, char *inp, int len )</b></td>
<tr><th>arg 1</Th><td>struct bin_info *bi</td></tr>
<tr><th></th><td>Top address of an array of bin_info structure
</td></tr>
<tr><th>arg 2</Th><td>int bn</td></tr>
<tr><th></th><td>Number of elements of bin_info structure array
</td></tr>
<tr><th>arg 3</Th><td>char *inp</td></tr>
<tr><th></th><td>Top address of input buffer
</td></tr>
<tr><th>arg 4</Th><td>int len</td></tr>
<tr><th></th><td>Length of input buffer (in bytes)
</td></tr>
<tr><th>Return value</th><td>Return length of processed data if successful.
This can be smaller than parameter "len", but never bigger than "len".
Returns VCE_EDATASHORT when input data is too short.
</td></tr>
<tr><th>Description</th><td>This unpacks binary data as specified by an array of the bin_info structure,
and brings it back to the structured state.
It is mainly used for protocol processing.
</td></tr>
<tr><th>Bugs/TODO</th><td>This function is already replaced with binary push/pop functions.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_binary_pack">vce_binary_pack</a>
</td></tr>
</table><br><br>
<a name="vce_chop_string_destroy"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_chop_string_destroy</th></tr>
<tr><th>Summary</th><td>Delete the last newline character of a string</td></tr>
<tr><th>Category</th><td>text</td></tr>
<tr><th>Compatibility</th><td></td></tr>
<tr><th>Prototype</th><td><b>char * vce_chop_string_destroy( char *s )</b></td>
<tr><th>arg 1</Th><td>char *s</td></tr>
<tr><th></th><td>Top address of a string being processed.
</td></tr>
<tr><th>Return value</th><td>Return parameter "s" as it is.
</td></tr>
<tr><th>Description</th><td>This examines the last letter of a string using serlen() function,
and if it is a carriage return (LN), it will be removed then the
string is returned.
When the end of the string is CRLF, it removes such CRLF.
</td></tr>
</table><br><br>
<a name="vce_circ_clear"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_clear</th></tr>
<tr><th>Summary</th><td>Initialize circ_t in official manner</td></tr>
<tr><th>Category</th><td></td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_circ_clear(circ_t *c )</b></td>
<tr><th>arg 1</Th><td>circ_t *c</td></tr>
<tr><th></th><td>Target circ_t
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>Zero-clear with memset or others is
less than formal initialization of circ_t.
To create an initialized circ_t, initialization
using this function is necessary.
</td></tr>
</table><br><br>
<a name="vce_circ_close"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_close</th></tr>
<tr><th>Summary</th><td>Close circ_t.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_circ_close( circ_t cir )</b></td>
<tr><th>arg 1</Th><td>circ_t cir</td></tr>
<tr><th></th><td>A circ_t being closed.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>This closes a virtual circuit by force.
Once it is closed, the circclosewatcher for the virtual circuit that
was designated upon invocation of vce_tcpcontext_create
function is called, then resources are released.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_circ_get_index"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_get_index</th></tr>
<tr><th>Summary</th><td>Get index number of a circ_t virtual circuit.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_circ_get_index( tcpcontext_t t, circ_t c );</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t t</td></tr>
<tr><th></th><td>A TCPcontext which contains this circ_t.
</td></tr>
<tr><th>arg 2</Th><td>circ_t c</td></tr>
<tr><th></th><td>Target circ_t
</td></tr>
<tr><th>Return value</th><td>Index number. Returns minus error indicator value if any error occured.
</td></tr>
<tr><th>Description</th><td>A virtual circuit is controlled by TCP context as a one-dimensional array,
and this function gets an index value inside such array.
Since this index value has uniqueness,
may be used as a session ID of connection.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_circ_get_struct_from_index">vce_circ_get_struct_from_index</a>
</td></tr>
</table><br><br>
<a name="vce_circ_get_parent_conn"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_get_parent_conn</th></tr>
<tr><th>Summary</th><td> Retrieves circ_t's parent conn_t</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>conn_t vce_circ_get_parent_conn( circ_t c)</b></td>
<tr><th>arg 1</Th><td>circ_t c</td></tr>
<tr><th></th><td>Target circ_t
</td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td></td></tr>
</table><br><br>
<a name="vce_circ_get_remote_addr_string"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_get_remote_addr_string</th></tr>
<tr><th>Summary</th><td>Get remote peer address and port number from circ_t by string</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>char * vce_circ_get_remote_addr_string( circ_t ct, char *s, int max )</b></td>
<tr><th>arg 1</Th><td>circ_t ct</td></tr>
<tr><th></th><td>Target circ_t
</td></tr>
<tr><th>arg 2</Th><td>char *s</td></tr>
<tr><th></th><td>Pointer to output string buffer.
</td></tr>
<tr><th>arg 3</Th><td>int max</td></tr>
<tr><th></th><td>Size of output string buffer.
</td></tr>
<tr><th>Return value</th><td>Returns parameter "s" as it is.
</td></tr>
<tr><th>Description</th><td>This gets circ_t's remote peer address as a character string within
a protocol-independent application.
With regard to an output format,
it behaves equally as vce_conn_get_remote_addr_string.
Since an application should be described
independently from IP protocol if possible,
this function should be used rather than functions such as
vce_circ_get_remote_ipv6_addr.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_remote_addr_string">vce_conn_get_remote_addr_string</a>
</td></tr>
</table><br><br>
<a name="vce_circ_get_remote_ipv4_addr"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_get_remote_ipv4_addr</th></tr>
<tr><th>Summary</th><td>Get 32-bit IPv4 remote peer address from a circ_t</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_circ_get_remote_ipv4_addr( circ_t ct, unsigned int *a, unsigned short *p )</b></td>
<tr><th>arg 1</Th><td>circ_t ct</td></tr>
<tr><th></th><td>Target circ_t.
</td></tr>
<tr><th>arg 2</Th><td>unsigned int *a</td></tr>
<tr><th></th><td>IPv4 address output buffer.
Please note that this function returns network byte-order data.
</td></tr>
<tr><th>arg 3</Th><td>unsigned short *p</td></tr>
<tr><th></th><td>Port number.
Please note that this function returns network byte-order data.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>Get remote peer's IPv4 address and port number.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_remote_ipv4_addr">vce_conn_get_remote_ipv4_addr</a>
</td></tr>
</table><br><br>
<a name="vce_circ_get_remote_ipv4_addr_string"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_get_remote_ipv4_addr_string</th></tr>
<tr><th>Summary</th><td>Get 32-bit IPv4 remote peer address from a circ_t as a string</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>char * vce_circ_get_remote_ipv4_addr_string( circ_t ct, char *s, int max )</b></td>
<tr><th>arg 1</Th><td>circ_t ct</td></tr>
<tr><th></th><td>Target circ_t.
</td></tr>
<tr><th>arg 2</Th><td>char *s</td></tr>
<tr><th></th><td>Top address of destination string buffer.
</td></tr>
<tr><th>arg 3</Th><td>int max</td></tr>
<tr><th></th><td>Size of destination string buffer.
</td></tr>
<tr><th>Return value</th><td>Returns parameter "s" as it is.
</td></tr>
<tr><th>Description</th><td>This obtains a remote client's address in character string.
An output character string buffer of at least 50 bytes must
be prepared.
This is caused by existence of some environments not having snprintf.
For this function is dedicated to IPv4,
an applications should not use this function but the
vce_circ_get_remote_addr_string function in order to
accomplish protocol-independency.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_circ_get_remote_addr_string">vce_circ_get_remote_addr_string</a>
<a href="#vce_circ_get_remote_ipv4_addr">vce_circ_get_remote_ipv4_addr</a>
</td></tr>
</table><br><br>
<a name="vce_circ_get_remote_ipv6_addr"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_get_remote_ipv6_addr</th></tr>
<tr><th>Summary</th><td>Get 128-bit IPv6 remote peer address from a circ_t</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_circ_get_remote_ipv6_addr( circ_t ct, char *a, unsigned short *p )</b></td>
<tr><th>arg 1</Th><td>circ_t ct</td></tr>
<tr><th></th><td>Target circ_t.
</td></tr>
<tr><th>arg 2</Th><td>char *a</td></tr>
<tr><th></th><td>IPv6 address output buffer.
Please note that this function returns network byte-order data.
You should allocate larger than, or equal to 16 bytes for this buffer.
</td></tr>
<tr><th>arg 3</Th><td>unsigned short *p</td></tr>
<tr><th></th><td>Port number output buffer.
Please note that this function returns network byte-order data.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>Get remote peer's IPv6 address and port.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_circ_get_remote_ipv6_addr_string">vce_circ_get_remote_ipv6_addr_string</a>
</td></tr>
</table><br><br>
<a name="vce_circ_get_remote_ipv6_addr_string"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_get_remote_ipv6_addr_string</th></tr>
<tr><th>Summary</th><td>Get 128-bit IPv6 remote peer address from a circ_t as a string</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>char * vce_circ_get_remote_ipv6_addr_string( circ_t ct, char *s, int max )</b></td>
<tr><th>arg 1</Th><td>circ_t ct</td></tr>
<tr><th></th><td>Target circ_t.
</td></tr>
<tr><th>arg 2</Th><td>char *s</td></tr>
<tr><th></th><td>Top address of destination string buffer.
</td></tr>
<tr><th>arg 3</Th><td>int max</td></tr>
<tr><th></th><td>Size of destination string buffer.
</td></tr>
<tr><th>Return value</th><td>Returns parameter "s" as it is.
</td></tr>
<tr><th>Description</th><td>This obtains a remote client's address in character string.
An output character string buffer of at least 50 bytes must
be prepared. This is caused by existence of some environments
not having snprintf.
For this function is dedicated to IPv4, an applications should
not use this function but vce_circ_get_remote_addr_string
function in order to accomplish protocol-independency.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_circ_get_remote_addr">vce_circ_get_remote_addr</a>
<a href="#vce_circ_get_remote_addr_string">vce_circ_get_remote_addr_string</a>
<a href="#vce_circ_get_remote_ipv6_addr">vce_circ_get_remote_ipv6_addr</a>
</td></tr>
</table><br><br>
<a name="vce_circ_get_state_buffer"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_get_state_buffer</th></tr>
<tr><th>Summary</th><td>Get pointer to circ_t's state buffer.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void * vce_circ_get_state_buffer( circ_t ct, int *len );</b></td>
<tr><th>arg 1</Th><td>circ_t ct</td></tr>
<tr><th></th><td>Target circ_t.
</td></tr>
<tr><th>arg 2</Th><td>int *len</td></tr>
<tr><th></th><td>Length of state buffer. This is value-result parameter.
Ignored if set NULL.
</td></tr>
<tr><th>Return value</th><td>Pointer to state buffer. Returns NULL pointer if the
protocol is stateless.
</td></tr>
<tr><th>Description</th><td>This obtains a pointer of the state buffer that is associated with circ_t.
To make circ_t as a stateful protocol,
assign a value larger than 0 to the statebuf_size
argument upon invocation of vce_tcpcontext_create function.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_circ_get_struct_from_index"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_get_struct_from_index</th></tr>
<tr><th>Summary</th><td>Get circ_t structure from index and tcpcontext_t</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>circ_t vce_circ_get_struct_from_index( tcpcontext_t t, int index );</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t t</td></tr>
<tr><th></th><td>Target TCPcontext
</td></tr>
<tr><th>arg 2</Th><td>int index</td></tr>
<tr><th></th><td>Index of required circ_t.
This index is equal to what is got by vce_circ_get_index function.
</td></tr>
<tr><th>Return value</th><td>Instance of circ_t
</td></tr>
<tr><th>Description</th><td>This function is used when obtaining a structure itself from
an index of a virtual circuit.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_circ_get_index">vce_circ_get_index</a>
</td></tr>
</table><br><br>
<a name="vce_circ_get_tcpcontext"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_get_tcpcontext</th></tr>
<tr><th>Summary</th><td>get tcpcontext_t from a circ_t</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>tcpcontext_t vce_circ_get_tcpcontext( circ_t c )</b></td>
<tr><th>arg 1</Th><td>circ_t c</td></tr>
<tr><th></th><td>Target circ_t
</td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td>This function is mainly used for the inside of
VCE, and is seldom used from applications.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_tcpcontext">vce_conn_get_tcpcontext</a>
</td></tr>
</table><br><br>
<a name="vce_circ_is_equal"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_is_equal</th></tr>
<tr><th>Summary</th><td>Check if two circ_t instances are the same</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td></td></tr>
<tr><th>Prototype</th><td><b>int vce_circ_is_equal( circ_t c1, circ_t c2 )</b></td>
<tr><th>arg 1</Th><td>circ_t c1</td></tr>
<tr><th></th><td>Target circ_t, first one
</td></tr>
<tr><th>arg 2</Th><td>circ_t c2</td></tr>
<tr><th></th><td>Target circ_t, second one
</td></tr>
<tr><th>Return value</th><td>Returns 1 if two circ_t is equal, otherwise zero.
</td></tr>
<tr><th>Description</th><td>This investigates whether two virtual circuits are the identical.
Writing and reading, using those two circ_t's, will lead
to exactly the same results.
In concrete, this will be the connection having the same pointer
and serial number.
</td></tr>
</table><br><br>
<a name="vce_circ_is_valid"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_is_valid</th></tr>
<tr><th>Summary</th><td>Check if an instance of circ_t is valid or not.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td></td></tr>
<tr><th>Prototype</th><td><b>int vce_circ_is_valid( circ_t ct )</b></td>
<tr><th>arg 1</Th><td>circ_t ct</td></tr>
<tr><th></th><td>Target circ_t
</td></tr>
<tr><th>Return value</th><td>Returns 1 if ct is valid, otherwise returns 0.
</td></tr>
<tr><th>Description</th><td>This returns 1 in case that the writing buffer is full
whereas a connection itself is valid.
</td></tr>
</table><br><br>
<a name="vce_circ_set_alarmwatcher"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_set_alarmwatcher</th></tr>
<tr><th>Summary</th><td>Set alarm clock and callback function per circ_t basis.</td></tr>
<tr><th>Category</th><td>watcher</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>time_t vce_circ_set_alarmwatcher( circ_t c, int sec , int (*alarmwatcher)(circ_t))</b></td>
<tr><th>arg 1</Th><td>circ_t c</td></tr>
<tr><th></th><td>Target circ_t
</td></tr>
<tr><th>arg 2</Th><td>int sec</td></tr>
<tr><th></th><td>set the alarm clock for 'sec' add current time now.
after the 'sec' seconds from this function use, callback function call.
</td></tr>
<tr><th>arg 3</Th><td>int (*alarmwatcher)(cric_t c)</td></tr>
<tr><th></th><td>Callback function. This function will be called by the alarm clock.
</td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td>By default, The length of a time-out duration is the same as it of
the time-out duration that was designated by the
vce_tcpcontext_create function.
However, since the time-out duration designated by the
vce_tcpcontext_create function is also used as the time-out
duration for connections between SWP and a main server,
it is usually given a very long time.
Accordingly, the time-out duration of circ_t is longer
than the time required by applications most of the time.
This function may be used in order to set up the time-out
duration appropriate for an application,
avoiding the said problem.
It would be typical that the time-out duration is reset through calling this
function within acceptwatcher. (refer to sample codes)
</td></tr>
<tr><th>Example</th><td>
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_set_alarmwatcher">vce_conn_set_alarmwatcher</a>
</td></tr>
</table><br><br>
<a name="vce_circ_set_timeout"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_set_timeout</th></tr>
<tr><th>Summary</th><td>Change each circ_t's timeout length</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_circ_set_timeout( circ_t c, int sec )</b></td>
<tr><th>arg 1</Th><td>circ_t c</td></tr>
<tr><th></th><td>Target circ_t
</td></tr>
<tr><th>arg 2</Th><td>int sec</td></tr>
<tr><th></th><td>New timeout value in seconds.
</td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td>By default, The length of a time-out duration is the same as it of
the time-out duration that was designated by the
vce_tcpcontext_create function.
However, since the time-out duration designated by the
vce_tcpcontext_create function is also used as the time-out
duration for connections between SWP and a main server,
it is usually given a very long time.
Accordingly, the time-out duration of circ_t is longer
than the time required by applications most of the time.
This function may be used in order to set up the time-out
duration appropriate for an application,
avoiding the said problem.
It would be typical that the time-out duration is reset through calling this
function within acceptwatcher. (refer to sample codes)
</td></tr>
<tr><th>Example</th><td>  int application_circ_acceptwatcher( circ_t ct )
  {
      vce_circ_set_timeout( ct, 100 );
  }
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_tcpcontext_set_circ_acceptwatcher">vce_tcpcontext_set_circ_acceptwatcher</a>
</td></tr>
</table><br><br>
<a name="vce_circ_switch"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_switch</th></tr>
<tr><th>Summary</th><td>Switch a circ_t to other(or local) servers</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_circ_switch( circ_t c, int server_id, const char *data, int len )</b></td>
<tr><th>arg 1</Th><td>circ_t c</td></tr>
<tr><th></th><td>target circ_t
</td></tr>
<tr><th>arg 2</Th><td>int server_id</td></tr>
<tr><th></th><td>ID of "switching destination server"
</td></tr>
<tr><th>arg 3</Th><td>char *data</td></tr>
<tr><th></th><td>Additional attached information
to be passed to the switch destination server.
This is useful when an application, such as a game,
is needed to send character ID or others accompanying with the
switch process.
Do not include any pointers in this information.
Since pointers make no sense within other machines,
it should be handled with attention.
ID and indexes of respective information,
or copy of information are usually included.
Because the byte order or alignment differs within other servers,
it is preferable that information is compressed with a binary packer,
such as vce_binary_push_nb_i1, and transferred.
Besides, for circ_t's "state buffer" is otherwise transferred to the switch
destination server, additional information need not to be attached
when the contents of the state buffer is enough.
</td></tr>
<tr><th>arg 4</Th><td>int len</td></tr>
<tr><th></th><td>Length of attached data.
</td></tr>
<tr><th>Return value</th><td>This returns 0 and the negative error code,
when it succeeds and fails respectively.
The success is not that a connection finishes switching to a
destination server, but it means that the switch request
go into transmitting queue.
It is necessary to wait for the callback function specified
in vce_tcpcontext_set_circ_switchresultwatcher
function to check whether actual processing is successful or not.
</td></tr>
<tr><th>Description</th><td>This is the basic function for transfer processing of the
circ_t connection to another server.
When switching a connection,
the contents of the "state buffer" are copied, as well as "attached data".
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_set_circ_switchresultwatcher">vce_tcpcontext_set_circ_switchresultwatcher</a>
<a href="#vce_tcpcontext_set_circ_switchwatcher">vce_tcpcontext_set_circ_switchwatcher</a>
</td></tr>
</table><br><br>
<a name="vce_circ_test_sanity"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_test_sanity</th></tr>
<tr><th>Summary</th><td>Test validity of a circ_t most precisely</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_circ_test_sanity( tcpcontext_t tt, circ_t ct, int *type )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tt</td></tr>
<tr><th></th><td>A tcpcontext_t which produced the circ.
</td></tr>
<tr><th>arg 2</Th><td>circ_t ct</td></tr>
<tr><th></th><td>A circ_t to be tested by this function
</td></tr>
<tr><th>arg 3</Th><td>int *type</td></tr>
<tr><th></th><td>Precise result of investigation
</td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td>circ_t has two members a serial number, and a pointer.
vce_circ_is_valid function tests validity of the pointer member
by comparing it with NULL pointer.
But if the pointer is destroyed by application, it may cause
memory access violation.
This function checks circ_t to avoid this problem.
This function will return investigation code by *type argument
<ul>
<LI>5  argument tt (tcpcontext) is null
<LI>6  argument tt (tcpcontext) is invalid  seems not allocated by VCE.
<LI>10  argument tt (tcpcontext) is not configured to produce circ_t
<LI>20  argument tt (tcpcontext) is configured to use state buffer,
but internally state buffer is corrupted ( VCE BUG? )
<LI>30  argument ct 's pointer is NULL
<LI>40  argument ct 's pointer is invalid  odd address
<LI>50  argument ct 's serial number is zero. That's invalid.
<LI>60  argument ct seems not be allocated by VCE.
<LI>70  argument ct seems to have invalid parent conn_t pointer (VCE BUG?)
<LI>80  argument ct has invalid parent conn_t serial number (VCE BUG?)
<LI>90  argument ct has invalid NULL state buffer
<LI>100  argument ct seems not be allocated by VCE.
</ul>

</td></tr>
<tr><th>See also</th><td>
<a href="#vce_circ_is_valid">vce_circ_is_valid</a>
</td></tr>
</table><br><br>
<a name="vce_circ_writable"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_writable</th></tr>
<tr><th>Summary</th><td>Get blank size of a circ_t write buffer.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_circ_writable( circ_t ct )</b></td>
<tr><th>arg 1</Th><td>circ_t ct</td></tr>
<tr><th></th><td>Target circ_t
</td></tr>
<tr><th>Return value</th><td>Return how many bytes can be written into the circ_t.
When it is writable, return 1 or more.
When it is not unwritable but virtual circuit is vaild,
return 0.
Returns minus error code if the circ_t is not valid.
</td></tr>
<tr><th>Description</th><td>Every write to a virtual circuit will be stored in the buffer of
its parent TCP connection.
In other words, no buffers are prepared for each virtual circuits
independently.
Therefore, sometimes this function returns the same value against
multiple circ_t (multiple circ_t is parented by one TCPcontext ).
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_writable">vce_conn_writable</a>
</td></tr>
</table><br><br>
<a name="vce_circ_write"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_circ_write</th></tr>
<tr><th>Summary</th><td>Write data into a virtual circuit (circ_t) within a TCP connection.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_circ_write( circ_t cir, char *data, int datalen )</b></td>
<tr><th>arg 1</Th><td>circ_t cir</td></tr>
<tr><th></th><td>Destination circ_t. Please look at category description about "tcp"
for precise explanation about circ_t.
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>Top address of data which will be sent.
</td></tr>
<tr><th>arg 3</Th><td>int datalen</td></tr>
<tr><th></th><td>Length of data being sent.
</td></tr>
<tr><th>Return value</th><td>Returns datalen if successfully written.
Returns minus error code if fail.
When it succeeds, it is always datalen.
Any smaller positive values will never be returned,
because there are only two result
<pre>
1. Completely success ( returning datalen )
2. Completely fail ( returning minus error code )
</pre>
</td></tr>
<tr><th>Description</th><td>VCE allows inclusion of more than one virtual connection within
a single TCP connection (conn_t).
Because vce_circ_write directly writes data onto such virtual circuit
without any processing, so in ordinary applications should use
bin16 or some protocol functions to write.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_cleanup_all_search_engine"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_cleanup_all_search_engine</th></tr>
<tr><th>Summary</th><td>Release all resource used by search engines</td></tr>
<tr><th>Category</th><td>search</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_cleanup_all_search_engine( void )</b></td>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>This releases all the search engines that VCE internally uses.
It simply calls vce_cleanup_search_engine in a loop, inside it.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_init_int2_search">vce_init_int2_search</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_init_string_search">vce_init_string_search</a>
</td></tr>
</table><br><br>
<a name="vce_cleanup_search_engine"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_cleanup_search_engine</th></tr>
<tr><th>Summary</th><td>Release resource used by a search engine</td></tr>
<tr><th>Category</th><td>search</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_cleanup_search_engine( int index )</b></td>
<tr><th>Return value</th><td>Returns zero if successful, otherwise returns minus error indicator value.
</td></tr>
<tr><th>Description</th><td>Free a search engine specified by parameter "index".
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_cleanup_search_engine">vce_cleanup_search_engine</a>
<a href="#vce_init_int2_search">vce_init_int2_search</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_init_string_search">vce_init_string_search</a>
</td></tr>
</table><br><br>
<a name="vce_conn_break_heartbeat"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_break_heartbeat</th></tr>
<tr><th>Summary</th><td>PENDING</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_conn_break_heartbeat()</b></td>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td>PENDING
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_set_conn_call_parser_per_heartbeat">vce_tcpcontext_set_conn_call_parser_per_heartbeat</a>
</td></tr>
</table><br><br>
<a name="vce_conn_clear"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_clear</th></tr>
<tr><th>Summary</th><td>Initialize conn_t instance</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_conn_clear( conn_t *c )</b></td>
<tr><th>arg 1</Th><td>conn_t *c</td></tr>
<tr><th></th><td>pointer to a conn_t
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>This is only way to correctly create an initialized conn_t.
Zero-clear with memset is not formal.
</td></tr>
</table><br><br>
<a name="vce_conn_close"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_close</th></tr>
<tr><th>Summary</th><td>Close and release one TCP connection.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_conn_close( conn_t ct )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>A TCP connection (conn_t) to be closed.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>This closes a TCP connection.
What it actually does is just to put up the flag for the closing in
next heartbeat.
It succeeds all the time, however, when this function is invoked
for the connection with the close flag up, a warning is
given in the verbose mode.
Note that a connection will not actually be closed,
unless vce_heartbeat is called.
The connection closed by the VCE library will be detected
as an error as an application attempts to write next time.
Moreover, the closewatcher designated upon vce_tcpcontext_create
is called before releasing resources.
By resetting the time-out value shorter than a normal value
right after vce_conn_close, speedy close processing would be expected.
If not doing so, a connection will remain until the default time-out
duration-time passes, should there left some data within a connection.
(refer to sample codes) vce_get_last_error returns
VCE_EINVAL and VCE_EALREADY,
in case that an argument was abnormal and that additional
close is attempted when it was already closed, respectively.
</td></tr>
<tr><th>Example</th><td>// Set shorter time-out duration after closing conn_t
vce_conn_close( co );
vce_conn_set_timeout( co, 0 );
</td></tr>
<tr><th>See also</th><td>
<a href="# vce_tcpcontext_connect"> vce_tcpcontext_connect</a>
<a href="# vce_tcpcontext_create"> vce_tcpcontext_create</a>
<a href="#vce_conn_writable">vce_conn_writable</a>
</td></tr>
</table><br><br>
<a name="vce_conn_close_tcpcontext_all"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_close_tcpcontext_all</th></tr>
<tr><th>Summary</th><td>Close all connections maintained by a tcpcontext.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_conn_close_tcpcontext_all( tcpcontext_t tp )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>Target tcpcontext, which contains one or more conn_t
which will be closed by calling this function.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>This disconnects all connections parented by a TCPcontext.
Closewatcher and fainalizer are invoked afterwords.
You have to call vce_heartbeat after calling this function
to finish I/O. That is because actual disconnection will be done
in next vce_heartbeat (see vce_conn_close section).
A online-game server, for instance, in ideal case it informs all the
clients of its intention of shutdown first of all,
then blocks a new accept with vce_tcpcontext_enable_accept
function, and lastly closes a connection through invoking this function,
in order to properly terminate the server.
You can use this function even in a case that you are using circ_t,
because relay server(swp) automatically disconnect connections with
all the clients when it detects parent conn_t's closing.
This function behaves the same on a server and client.
In the verbose mode, a log is output upon every disconnection.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_enable_accept">vce_tcpcontext_enable_accept</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_buffer"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_buffer</th></tr>
<tr><th>Summary</th><td>Get conn_t's read/write buffer.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td></td></tr>
<tr><th>Prototype</th><td><b>void vce_conn_get_buffer( conn_t c, char **rb, int  *rblen, char **wb, int *wblen )</b></td>
<tr><th>arg 1</Th><td>conn_t c</td></tr>
<tr><th></th><td>target conn_t
</td></tr>
<tr><th>arg 2</Th><td>char **rb</td></tr>
<tr><th></th><td>This parameter returns pointer to read buffer.
</td></tr>
<tr><th>arg 3</Th><td>int *rblen</td></tr>
<tr><th></th><td>This parameter returns length of read buffer.
You can get how many bytes of data can be read from this conn_t.
</td></tr>
<tr><th>arg 4</Th><td>char **wb</td></tr>
<tr><th></th><td>This parameter returns pointer to write buffer.
</td></tr>
<tr><th>arg 5</Th><td>int *wblen</td></tr>
<tr><th></th><td>This parameter returns length of write buffer.
You can get how many bytes of data can be written into this conn_t.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>If your application needs an original protocol parser,
you can define it by directly refering to the read/write buffer.
Such original protocol parser can be registered
by vce_tcpcontext_set_conn_parser function.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_shrink_readbuf">vce_conn_shrink_readbuf</a>
<a href="#vce_tcpcontext_set_conn_parser">vce_tcpcontext_set_conn_parser</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_child_circ"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_child_circ</th></tr>
<tr><th>Summary</th><td> Retrieves conn_t's child circ_t</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_conn_get_child_circ( conn_t c , circ_t *a, int max)</b></td>
<tr><th>arg 1</Th><td>conn_t c</td></tr>
<tr><th></th><td>Target conn_t
</td></tr>
<tr><th>arg 2</Th><td>circ_t *a</td></tr>
<tr><th></th><td>Top address of an array of circ_t.
</td></tr>
<tr><th>arg 3</Th><td>int max</td></tr>
<tr><th></th><td>Max number of elements of array parameter "a".
</td></tr>
<tr><th>Return value</th><td>Number of elements filled in given array.
This number must be larger than or equal to zero.
</td></tr>
<tr><th>Description</th><td></td></tr>
</table><br><br>
<a name="vce_conn_get_index"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_index</th></tr>
<tr><th>Summary</th><td>Get index number of conn_t in VCE library.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_conn_get_index( conn_t c );</b></td>
<tr><th>arg 1</Th><td>conn_t c</td></tr>
<tr><th></th><td>target conn_t. retrieve index from this conn_t.
</td></tr>
<tr><th>Return value</th><td>Index number. Return minus value when error.
</td></tr>
<tr><th>Description</th><td>Index number can be uniquely used to specify conn_t,
because the conn_t structure is maintained as a one-dimensional
array inside VCE.
Therefore, it may be used for the purposes such as the "session ID"
in your application.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_struct_from_index">vce_conn_get_struct_from_index</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_local_addr_string"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_local_addr_string</th></tr>
<tr><th>Summary</th><td>Get local address and port number from conn_t by string</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>char * vce_conn_get_local_addr_string( conn_t ct, char *s, int max )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>source conn_t
</td></tr>
<tr><th>arg 2</Th><td>char *s</td></tr>
<tr><th></th><td>Top address of output buffer
</td></tr>
<tr><th>arg 3</Th><td>int max</td></tr>
<tr><th></th><td>Length of output buffer
</td></tr>
<tr><th>Return value</th><td>Return buffer "s" as it is.
</td></tr>
<tr><th>Description</th><td>This obtains local address of conn_t in a character string.
The address format allowed is the same as
vce_conn_get_remote_addr_string function's.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_remote_addr_string">vce_conn_get_remote_addr_string</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_local_ipv4_addr"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_local_ipv4_addr</th></tr>
<tr><th>Summary</th><td>Get 32-bit IPv4 local address from a TCP connection</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_conn_get_local_ipv4_addr( conn_t ct, unsigned int *a, unsigned short *p )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>source conn_t
</td></tr>
<tr><th>arg 2</Th><td>unsigned int *a</td></tr>
<tr><th></th><td>Pointer to 32bit integer(int) IP address.
Output data is network byte-ordered.
Ignore this parameter if NULL is set.
</td></tr>
<tr><th>arg 3</Th><td>unsigned short *p</td></tr>
<tr><th></th><td>Pointer to 16bit integer(short) port number.
Output data is network byte-ordered.
Ignore this parameter if NULL is set.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>Output data is in the network byte order.
It should be converted using ntohs, ntohl or others as you need.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_remote_ipv4_addr">vce_conn_get_remote_ipv4_addr</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_local_ipv4_addr_string"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_local_ipv4_addr_string</th></tr>
<tr><th>Summary</th><td>Get Ipv4 local peer address from a TCP connectin as a string</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>char * vce_conn_get_local_ipv4_addr_string( conn_t ct, char *s, int max )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>source conn_t
</td></tr>
<tr><th>arg 2</Th><td>char *s</td></tr>
<tr><th></th><td>Top address of output buffer
</td></tr>
<tr><th>arg 3</Th><td>int max</td></tr>
<tr><th></th><td>Length of output buffer
</td></tr>
<tr><th>Return value</th><td>Return parameter "s" as it is
</td></tr>
<tr><th>Description</th><td>This function is dedicated to IPv4 and determines an address
of the end point on this side of the socket.
"This side" means that the end point on the side where the program
that invoked this function is running.
Since this function is dedicated to IPv4,
it is recommended to use vce_conn_get_local_addr_string
function rather than this function,
because we should persue protocol independency in our applications.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_local_addr_string">vce_conn_get_local_addr_string</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_local_ipv6_addr"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_local_ipv6_addr</th></tr>
<tr><th>Summary</th><td>Get 128-bit IPv6 local address from a TCP connection</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_conn_get_local_ipv6_addr( conn_t ct, char *a, unsigned short *p )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>source conn_t
</td></tr>
<tr><th>arg 2</Th><td>char *a</td></tr>
<tr><th></th><td>Pointer to char array, which will contain 16bytes of IPv6 address.
Ignore this parameter if NULL is set.
Output data is network byte-ordered. You have to allocate more than 16bytes
for this parameter.
</td></tr>
<tr><th>arg 3</Th><td>unsigned short *p</td></tr>
<tr><th></th><td>Pointer to 16bit integer(short).
Ignore this parameter if NULL is set.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>This function is IPv6 version of vce_conn_get_remote_ipv4_addr function.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_remote_ipv4_addr">vce_conn_get_remote_ipv4_addr</a>
<a href="#vce_conn_get_remote_ipv6_addr">vce_conn_get_remote_ipv6_addr</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_local_ipv6_addr_string"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_local_ipv6_addr_string</th></tr>
<tr><th>Summary</th><td>Get Ipv6 local address from a TCP connectin as a string</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>char *vce_conn_get_local_ipv6_addr_string( conn_t ct, char *s, int max )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>source conn_t
</td></tr>
<tr><th>arg 2</Th><td>char *s</td></tr>
<tr><th></th><td>Top address of output buffer
</td></tr>
<tr><th>arg 3</Th><td>int max</td></tr>
<tr><th></th><td>Length of output buffer
</td></tr>
<tr><th>Return value</th><td>Return parameter "s" as it is, or NULL when error.
</td></tr>
<tr><th>Description</th><td>This gets local address of a conn_t in a character string,
in the format same as vce_conn_get_remote_addr_string's.
Since this function is dedicated to IPv6 and protocol dependent,
it is recommended to use vce_conn_get_local_addr_string function instead.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_local_addr_string">vce_conn_get_local_addr_string</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_remote_addr_string"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_remote_addr_string</th></tr>
<tr><th>Summary</th><td>Get remote peer address and port number from conn_t by string</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>char *vce_conn_get_remote_addr_string( conn_t ct, char *s, int max )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>source conn_t
</td></tr>
<tr><th>arg 2</Th><td>char *s</td></tr>
<tr><th></th><td>Top address of output buffer.
</td></tr>
<tr><th>arg 3</Th><td>int max</td></tr>
<tr><th></th><td>Length of output buffer
</td></tr>
<tr><th>Return value</th><td>Return buffer "s" as it is.
</td></tr>
<tr><th>Description</th><td>This gets remote peer address of conn_t in
a protocol independent application in a character string.
VCE is compatible with ipv4 and ipv6 at the moment,
and returns like "192.168.0.11234" for IPV4,
or "fe802d0b7fffec6f4cd.5678" for IPv6.
It does not resolve DNS name.
Note that the token indicating the last port number is
divided by "" for ipv4,
whereas "." is used for ipv6.
The process to determine to which protocol a returned character
string belongs is left to an application.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_local_addr_string">vce_conn_get_local_addr_string</a>
<a href="#vce_conn_get_remote_ipv4_addr_string">vce_conn_get_remote_ipv4_addr_string</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_remote_ipv4_addr"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_remote_ipv4_addr</th></tr>
<tr><th>Summary</th><td>Get 32-bit IPv4 remote peer address from a TCP connection</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_conn_get_remote_ipv4_addr( conn_t ct, unsigned int *a, unsigned short *p )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>source conn_t
</td></tr>
<tr><th>arg 2</Th><td>unsigned int *a</td></tr>
<tr><th></th><td>Pointer to return 32bit integer(int) IP address.
Output data will be network byte-ordered.
Ignore this parameter if NULL is set.
</td></tr>
<tr><th>arg 3</Th><td>unsigned short *p</td></tr>
<tr><th></th><td>Pointer to return port number. Output data is network byte-ordered.
Ignore this parameter if NULL is set.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>Output data is in network byte order,
so you use ntohs(), or ntohl() if you need them.
</td></tr>
</table><br><br>
<a name="vce_conn_get_remote_ipv4_addr_string"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_remote_ipv4_addr_string</th></tr>
<tr><th>Summary</th><td>Get Ipv4 remote peer address from a TCP connectin as a string</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>char *vce_conn_get_remote_ipv4_addr_string( conn_t ct, char *s, int max )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>source conn_t
</td></tr>
<tr><th>arg 2</Th><td>char *s</td></tr>
<tr><th></th><td>Top address of output buffer.
</td></tr>
<tr><th>arg 3</Th><td>int max</td></tr>
<tr><th></th><td>Length of output buffer
</td></tr>
<tr><th>Return value</th><td>Return parameter "s" as it is
</td></tr>
<tr><th>Description</th><td>Converting IPv4 address into string is often demanded
for purposes such as logging.
In the PlayStation(R)2development environment,
designate over 50 bytes as "s", the output buffer.
This is because current "PlayStation(R)2 library does not have snprintf.
Since this function is dedicated to IPv4, it is not compatible
with the IPv6 connection.
An application pursuing protocol independency should use
vce_conn_get_remote_addr function.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_remote_addr">vce_conn_get_remote_addr</a>
<a href="#vce_conn_get_remote_ipv4_addr">vce_conn_get_remote_ipv4_addr</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_remote_ipv6_addr"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_remote_ipv6_addr</th></tr>
<tr><th>Summary</th><td>Get 128-bit IPv6 remote peer address from a TCP connection</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_conn_get_remote_ipv6_addr( conn_t ct, char *a, unsigned short *p )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>source conn_t
</td></tr>
<tr><th>arg 2</Th><td>char *a</td></tr>
<tr><th></th><td>Pointer to char array, which will contain 16bytes of IPv6 address.
Ignore this parameter if NULL is set.
Output data is network byte-ordered. You have to allocate more than 16bytes
for this parameter.
</td></tr>
<tr><th>arg 3</Th><td>unsigned short *p</td></tr>
<tr><th></th><td>Pointer to 16bit integer(short) port number.
Ignore this parameter if NULL is set.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>Output data is in network byte order.
You use ntohs(), or ntohl() functions in case you need them.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_local_ipv6_addr">vce_conn_get_local_ipv6_addr</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_remote_ipv6_addr_string"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_remote_ipv6_addr_string</th></tr>
<tr><th>Summary</th><td>Get Ipv6 remote peer address from a TCP connectin as a string</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>char *vce_conn_get_remote_ipv6_addr_string( conn_t ct, char *s, int max )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>source conn_t
</td></tr>
<tr><th>arg 2</Th><td>char *s</td></tr>
<tr><th></th><td>Top address of output buffer
</td></tr>
<tr><th>arg 3</Th><td>int max</td></tr>
<tr><th></th><td>Length of output buffer
</td></tr>
<tr><th>Return value</th><td>Return parameter "s" as it is, or NULL when error.
</td></tr>
<tr><th>Description</th><td>This function is IPv6 version of vce_conn_get_remote_ipv4_addr_string
function.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_remote_addr">vce_conn_get_remote_addr</a>
<a href="#vce_conn_get_remote_ipv4_addr_string">vce_conn_get_remote_ipv4_addr_string</a>
<a href="#vce_conn_get_remote_ipv6_addr">vce_conn_get_remote_ipv6_addr</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_stat"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_stat</th></tr>
<tr><th>Summary</th><td>Get conn_t's statistics information</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_conn_get_stat( conn_t ct, conn_stat_t *st )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>source conn_t
</td></tr>
<tr><th>arg 2</Th><td>conn_stat_t *st</td></tr>
<tr><th></th><td>Top address of an instance of conn_stat_t structure
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>This fetches statistical information from TCP connection.
The conn_stat_t structure is defined for such extraction.
Description of the structure members are as follows

<UL>
<LI>recv_byte<BR>
Total bytes received by this connection.
<LI>send_byte<BR>
Total bytes transmitted by this connection.
<LI>conn_write<BR>
Number of times vce_conn_write is made toward this connection.
<LI>recv_syscall, send_syscall
Number of times the recv()system call and send_syscall
are invoked toward this connection.
</ul>
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_is_valid">vce_conn_is_valid</a>
<a href="#vce_get_stat">vce_get_stat</a>
<a href="#vce_tcpcontext_get_stat">vce_tcpcontext_get_stat</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_state_buffer"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_state_buffer</th></tr>
<tr><th>Summary</th><td>Get pointer to conn_t's state buffer.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void * vce_conn_get_state_buffer( conn_t c, int *len );</b></td>
<tr><th>arg 1</Th><td>conn_t c</td></tr>
<tr><th></th><td>source conn_t
</td></tr>
<tr><th>arg 2</Th><td>int *len</td></tr>
<tr><th></th><td>Return length of state buffer.
Do nothing if NULL is specified.
</td></tr>
<tr><th>Return value</th><td>Pointer to state buffer.
Returns NULL if stateless protocol.
</td></tr>
<tr><th>Description</th><td>This returns protocol state buffer attached to a conn_t.
If the protocol with the state is designated (statebuf_size) upon
invocation of vce_tcpcontext_create,
this returns a pointer to the buffer having the region of that size.
In case a switching proxy is used,
a pointer has to be obtained using the
vce_circ_get_state_buffer function.
Returned value is not defined if you use this function
when you are using connection switching.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_circ_get_state_buffer">vce_circ_get_state_buffer</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_struct_from_index"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_struct_from_index</th></tr>
<tr><th>Summary</th><td>Get conn_t struct from index number.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>conn_t vce_conn_get_struct_from_index( int index );</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Index of the conn_t. You can get conn_t by specifying index
number which is got by using vce_conn_get_index function.
</td></tr>
<tr><th>Return value</th><td>retrieved conn_t
</td></tr>
<tr><th>Description</th><td>You can use this function when you want to get conn_t
from "session ID" in your application.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_index">vce_conn_get_index</a>
</td></tr>
</table><br><br>
<a name="vce_conn_get_tcpcontext"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_get_tcpcontext</th></tr>
<tr><th>Summary</th><td>get tcpcontext_t from a conn_t</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>tcpcontext_t vce_conn_get_tcpcontext( conn_t c )</b></td>
<tr><th>arg 1</Th><td>conn_t c</td></tr>
<tr><th></th><td>target conn_t
</td></tr>
<tr><th>Return value</th><td>instance of tcpcontext_t, owner of parameter "c"
</td></tr>
<tr><th>Description</th><td>When connecting to a remote computer or accepting new TCP,
conn_t is initialized within VCE.
Such conn_t is always associated with tcpcontext.
Therefore, tcpcontext can be extracted from conn_t.
This function is mainly used within VCE internally,
but seldom be used from an application.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_circ_get_tcpcontext">vce_circ_get_tcpcontext</a>
<a href="#vce_tcpcontext_connect">vce_tcpcontext_connect</a>
</td></tr>
</table><br><br>
<a name="vce_conn_is_equal"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_is_equal</th></tr>
<tr><th>Summary</th><td>Check if two conn_t instances are the same</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td></td></tr>
<tr><th>Prototype</th><td><b>int vce_conn_is_equal( conn_t c1 , conn_t c2 )</b></td>
<tr><th>arg 1</Th><td>conn_t c1</td></tr>
<tr><th></th><td>first target
</td></tr>
<tr><th>arg 2</Th><td>conn_t c2</td></tr>
<tr><th></th><td>second target
</td></tr>
<tr><th>Return value</th><td>Returns 1 if equal. 0 if not.
</td></tr>
<tr><th>Description</th><td>This checks if two connections are the same.
Writing and reading using those two conn_t's will lead definitely the
same results.
In concrete, it will be the connection having the same
pointer and serial number.
</td></tr>
</table><br><br>
<a name="vce_conn_is_valid"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_is_valid</th></tr>
<tr><th>Summary</th><td>Check if a TCP connection ( conn_t ) is broken or not.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td></td></tr>
<tr><th>Prototype</th><td><b>int vce_conn_is_valid( conn_t c )</b></td>
<tr><th>arg 1</Th><td>conn_t c</td></tr>
<tr><th></th><td>target conn_t
</td></tr>
<tr><th>Return value</th><td>Returns 1 if valid, or 0 if not valid.
</td></tr>
<tr><th>Description</th><td>VCEed applications often store conn_t's returned from VCE
in a different memory region and use it afterwards for calling
the connection again.
However, at the point of time, the object within VCE
that is referred by such conn_t may possibly have released and reused.
This function checks if such conn_t has reused and is no longer
existing, using the serial number of the conn_t type.
This function is also used to check if the returned value from
vce_tcpcontext_connect is correct or not.
If you want to check you can write data into the conn_t,
you must use vce_conn_writable function all the time, not this function.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_writable">vce_conn_writable</a>
<a href="#vce_tcpcontext_connect">vce_tcpcontext_connect</a>
</td></tr>
</table><br><br>
<a name="vce_conn_set_alarmwatcher"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_set_alarmwatcher</th></tr>
<tr><th>Summary</th><td>Set alarm and callback function per conn_t basis</td></tr>
<tr><th>Category</th><td>watcher</td></tr>
<tr><th>Compatibility</th><td>linux O,win32 X,other X,darwin X</td></tr>
<tr><th>Prototype</th><td><b>time_t vce_conn_set_alarmwatcher( conn_t ct, int sec, int (*alarmwatcher)(conn_t c))</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>target conn_t
</td></tr>
<tr><th>arg 2</Th><td>int sec</td></tr>
<tr><th></th><td>set the alarm clock for 'sec' add current time now.
after the 'sec' seconds from this function use, callback function call.
</td></tr>
<tr><th>arg 3</Th><td>int (*alarmwatcher)(conn_t c)</td></tr>
<tr><th></th><td>Callback function. This function will be called by the alarm clock.
</td></tr>
<tr><th>Return value</th><td>Return value is global time, this function called global time.
When you get alarm time, return value add sec parameter.
</td></tr>
<tr><th>Description</th><td>PENDING
</td></tr>
<tr><th>Example</th><td>PENDING
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_circ_set_alarmwatcher">vce_circ_set_alarmwatcher</a>
</td></tr>
</table><br><br>
<a name="vce_conn_set_delay"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_set_delay</th></tr>
<tr><th>Summary</th><td>pending</td></tr>
<tr><th>Category</th><td>core</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_conn_set_delay(conn_t ct,int delay_min,int delay_max)</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>pending
</td></tr>
<tr><th>arg 2</Th><td>int delay_min</td></tr>
<tr><th></th><td>pending
</td></tr>
<tr><th>arg 3</Th><td>int delay_max</td></tr>
<tr><th></th><td>pending
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>pending
</td></tr>
<tr><th>Bugs/TODO</th><td>pending
</td></tr>
</table><br><br>
<a name="vce_conn_set_parser"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_set_parser</th></tr>
<tr><th>Summary</th><td>Set protocl parser and callback function per conn_t basis</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_conn_set_parser( conn_t ct, int (*parser)(conn_t), int (*pcallback)(conn_t,char*,int))</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>target conn_t
</td></tr>
<tr><th>arg 2</Th><td>int (*parser)(conn_t)</td></tr>
<tr><th></th><td>parser function to be set. For example, vce_protocol_parser_bin16, and
so on.
</td></tr>
<tr><th>arg 3</Th><td>int (*pcallback)(conn_t c,char *d, int l )</td></tr>
<tr><th></th><td>Callback function. This function will be called by the protocol parser.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>In some application, you may want to use
different parsers in each connection.
This function can change both parser and callback function dinamically.

If you change any callback function inside protocol callback function,
new callback function will be used after next parser call.

This function may be used for switching a protocol to
the debug mode, or to the control function, as well.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_parser_bin16">vce_protocol_parser_bin16</a>
<a href="#vce_protocol_parser_text">vce_protocol_parser_text</a>
<a href="#vce_protocol_parser_through">vce_protocol_parser_through</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_tcpcontext_set_conn_parser">vce_tcpcontext_set_conn_parser</a>
</td></tr>
</table><br><br>
<a name="vce_conn_set_timeout"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_set_timeout</th></tr>
<tr><th>Summary</th><td>Change each conn_t's timeout length</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_conn_set_timeout( conn_t c, int sec )</b></td>
<tr><th>arg 1</Th><td>conn_t c</td></tr>
<tr><th></th><td>target conn_t
</td></tr>
<tr><th>arg 2</Th><td>int sec</td></tr>
<tr><th></th><td>new timeout value in seconds
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>By default, time-out durations of respective connections
comply with the time-out setting of the vce_tcpcontext_create function.
The time-out duration depending on each connection can be adjusted without
restriction through using this function.
You can make use of this function in your application
if you want special high security in some situation.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_conn_show_stat"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_show_stat</th></tr>
<tr><th>Summary</th><td>Show stats of all active connections.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_conn_show_stat( void )</b></td>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>This outputs statistical information of the same number
of lines as it of connection, starting with
<pre>
"=== SHOW CONNECTION STATISTICS ===\n".
</pre>
Descriptions of the contents to be displayed are as follows

<UL>
<LI>A<BR>
Address of the connection structure (conn_t)
<LI>Enc<BR>
1 if encrypted, otherwise 0
<LI>IP<BR>
IP address port number. The port number is in the decimal.
<LI>Lst<BR>
Last accessed time (time_t, system time)
<LI>I<BR>
VCE control index
<LI>Sv<BR>
1 for server connections, 0 for client connections.
<LI>ER<BR>
Read buffer address before encryption
<LI>EW<BR>
Write buffer address after encryption
<LI>R<BR>
Read buffer address after decryption
<LI>W<BR>
Write buffer address before encryption
<LI>St<BR>
Negotiating on encryption
</ul>
Note that this function outputs nothing with the VCE library
compiled in the silent mode, and sets up
VCE_ESUPPORT as the last error.
</td></tr>
<tr><th>Bugs/TODO</th><td>Since this function uses standard error for output,
this function cannot be used in case standard error output is
unavailable in Win32GUI environment.
</td></tr>
</table><br><br>
<a name="vce_conn_shrink_readbuf"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_shrink_readbuf</th></tr>
<tr><th>Summary</th><td>shrink conn_t's read buffer</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_conn_shrink_readbuf( conn_t ct, int len )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>target conn_t
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>Length to shrink
</td></tr>
<tr><th>Return value</th><td>Shrinked length. When success, this will be same as parameter "len".
</td></tr>
<tr><th>Description</th><td>When defining an original protocol parser in your application,
the contents of the read buffer must be deleted using
vce_conn_shrink_readbuf, after processing the contents of the read buffer.
</td></tr>
</table><br><br>
<a name="vce_conn_writable"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_writable</th></tr>
<tr><th>Summary</th><td>Check if a TCP connection is ready to use (write).</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_conn_writable( conn_t ct );</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>A conn_t variable to be checked. If you're using nonblocking connect()
option on vce_tcpcontext_create, you can check if TCP socket is
established by calling this function. vce_conn_writable can be used
in both server programs and client programs, but it's commonly used in
client programs.
</td></tr>
<tr><th>Return value</th><td>Returns VCE_EINVAL if ct is not valid.
Returns VCE_ECONNSERIAL if ct is not usable any more
( the connection is cleared inside vce library. )
Returns 0 if connection is active but there are no buffer space/under
key negotiation.
Returns >0 if writable. The value means how many bytes you can write into
the socket.
</td></tr>
<tr><th>Description</th><td>Use this function to check if writing is allowed,
when writing something into conn_t in your application.
</td></tr>
<tr><th>Example</th><td>  // This program keeps writing in conn_t continuously
  tcpcontext_t t = vce_tcpontext_create( 0, ... );
  conn_t new_con = vce_tcpcontext_connect( t, "localhost" , 80 );
  while (1 ){
      vce_heartbeat();
      if( vce_conn_writable( new_con ) >= 4 ){
          vce_conn_write( new_con, "test" , 4 );
      } else {
          // Fail. too long time after starting connect().
      }
  }

</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_is_valid">vce_conn_is_valid</a>
<a href="#vce_conn_write">vce_conn_write</a>
<a href="#vce_tcpcontext_connect">vce_tcpcontext_connect</a>
</td></tr>
</table><br><br>
<a name="vce_conn_write"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_write</th></tr>
<tr><th>Summary</th><td>Write raw data into a TCP connection.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_conn_write( conn_t ct, char *b, size_t len );</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>target conn_t to write
</td></tr>
<tr><th>arg 2</Th><td>char *b</td></tr>
<tr><th></th><td>Pointer to data.
</td></tr>
<tr><th>arg 3</Th><td>size_t len</td></tr>
<tr><th></th><td>Length of written data.
</td></tr>
<tr><th>Return value</th><td>Larger than 1 successful<BR>
0  Buffer full<BR>
</td></tr>
<tr><th>Description</th><td>This directly transmits raw data.
Here direct transmission means that,
data is stored in the write buffer allocated inside conn_t
for a while, then is flushed in next vce_heartbeat().
Consequently, the maximum amount allowed to write at a time
will depend on length of write buffer upon vce_tcpcontext_create.
Data encryption or compression are automatically done inside.

Moreover, once vce_conn_write returns a negative value,
the connection is no longer available. In this case you should
immediately call vce_conn_close against the conn_t.
<BR><BR>

<B>In cases it fails to write  returning 0 for example</B><BR>

In case vce_conn_write returns 0,
any data cannot be written into a socket for some reason.
This usually means that the client side can no longer read (down).
When the contents of an application sends or receives
large data such as JPEG files, a process must go on
without calling vce_conn_close,
even if it returns 0.
However, if small data such as game operation packets is used,
it should be deemed that some problem is occurring to a client
and calling vce_conn_close is perferable.
</td></tr>
<tr><th>Example</th><td>  // how to use vce_conn_close in cases like online games
  // always small packets are transmitted
  if( vce_writable( ct ) > 0 ){
      int writel = vce_conn_write( ct, "hoge", 4 );
      if( writel < 4 ){
          vce_conn_close(ct);
      }
  }

</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_close">vce_conn_close</a>
<a href="#vce_conn_writable">vce_conn_writable</a>
</td></tr>
</table><br><br>
<a name="vce_conn_writed"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_conn_writed</th></tr>
<tr><th>Summary</th><td></td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td></td></tr>
<tr><th>Prototype</th><td><b>int vce_conn_writed( conn_t c )</b></td>
<tr><th>arg 1</Th><td>conn_t c</td></tr>
<tr><th></th><td>target conn_t
</td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_valid">vce_conn_valid</a>
</td></tr>
</table><br><br>
<a name="vce_copy_cstring"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_copy_cstring</th></tr>
<tr><th>Summary</th><td>Copy C string to a buffer. Notify buffer overflow.</td></tr>
<tr><th>Category</th><td>text</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_copy_cstring( char *dest , int destlen , char *src )</b></td>
<tr><th>arg 1</Th><td>char *dest</td></tr>
<tr><th></th><td>Top address of output string buffer.
</td></tr>
<tr><th>arg 2</Th><td>int destlen</td></tr>
<tr><th></th><td>How many bytes will be copied.
</td></tr>
<tr><th>arg 3</Th><td>char *src</td></tr>
<tr><th></th><td>Source string.
</td></tr>
<tr><th>Return value</th><td>Returns 1 if buffer is full, otherwise returns 0.
</td></tr>
<tr><th>Description</th><td>This copies a C language string (terminated by '\0') to other buffer.
This returns 1 if the source character string is too long and
the copy destination buffer is too short, otherwise 0.
When the copy destination buffer is 10 bytes and 10
letters plus 1 null character is given as source, for instance, it returns 1.
vce_copy_cstring warrants that the copy destination
buffer terminates with 0.
</td></tr>
</table><br><br>
<a name="vce_copy_cstring_upto"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_copy_cstring_upto</th></tr>
<tr><th>Summary</th><td>Copy C string to another buffer till finding a character.</td></tr>
<tr><th>Category</th><td>text</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_copy_cstring_upto( char *dest, char *src, char c, int destlen  )</b></td>
<tr><th>arg 1</Th><td>char *dest</td></tr>
<tr><th></th><td>Top address of destination string buffer.
</td></tr>
<tr><th>arg 2</Th><td>char *src</td></tr>
<tr><th></th><td>Top address of source string buffer.
</td></tr>
<tr><th>arg 3</Th><td>char c</td></tr>
<tr><th></th><td>Stop copying if this character is found.
</td></tr>
<tr><th>arg 4</Th><td>int destlen</td></tr>
<tr><th></th><td>Size of destination string buffer in bytes.
</td></tr>
<tr><th>Return value</th><td>This returns length of the string copied (positive value)
as successfully copied.
This is length of copied string including a null character,
as for other functions.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_copy_cstring">vce_copy_cstring</a>
</td></tr>
</table><br><br>
<a name="vce_decode_buffer_by_blowfish"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_decode_buffer_by_blowfish</th></tr>
<tr><th>Summary</th><td>Decrypt binary data array using Blowfish algorithm</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_decode_buffer_by_blowfish( char *buf , int len , char *k, int kl )</b></td>
<tr><th>arg 1</Th><td>char *buf</td></tr>
<tr><th></th><td>Top address of input buffer, which will be decrypted.
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>Length of input data
</td></tr>
<tr><th>arg 3</Th><td>char *k</td></tr>
<tr><th></th><td>Top address of decryption key data
</td></tr>
<tr><th>arg 4</Th><td>int kl</td></tr>
<tr><th></th><td>Length of decryption key
</td></tr>
<tr><th>Return value</th><td>Returns VCE_EINVAL, when invalid arguments are given.
Otherwise returns 0.
</td></tr>
<tr><th>Description</th><td>Please check description of
vce_encode_buffer_by_blowfish function.
This function is a reverse function of vce_encode_buffer_by_blowfish.
</td></tr>
<tr><th>See also</th><td>
<a href="#bf">bf</a>
<a href="#vce_encode_buffer_by_blowfish">vce_encode_buffer_by_blowfish</a>
</td></tr>
</table><br><br>
<a name="vce_decode_buffer_by_rijndael"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_decode_buffer_by_rijndael</th></tr>
<tr><th>Summary</th><td>Decrypt binary data array using Rijndael algorithm</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_decode_buffer_by_rijndael( char *buf , int len , char *k, int kl )</b></td>
<tr><th>arg 1</Th><td>char *buf</td></tr>
<tr><th></th><td>Top address of input buffer, which will be decrypted.
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>Length of input data
</td></tr>
<tr><th>arg 3</Th><td>char *k</td></tr>
<tr><th></th><td>Top address of decryption key data
</td></tr>
<tr><th>arg 4</Th><td>int kl</td></tr>
<tr><th></th><td>Length of decryption key
</td></tr>
<tr><th>Return value</th><td>Returns VCE_EINVAL when invalid arguments are given.
Otherwise returns 0.
</td></tr>
<tr><th>Description</th><td>Please check description of vce_encode_buffer_by_rijndael function.
This function is a reverse function of vce_encode_buffer_by_rijndael.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_encode_buffer_by_rijndael">vce_encode_buffer_by_rijndael</a>
</td></tr>
</table><br><br>
<a name="vce_delete_int2_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_delete_int2_search</th></tr>
<tr><th>Summary</th><td>Delete a value from 2-integer search engine</td></tr>
<tr><th>Category</th><td>search</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_delete_int2_search( int index , int key0 , int key1 )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Search descriptor.
</td></tr>
<tr><th>arg 2</Th><td>int key0</td></tr>
<tr><th></th><td>First integer search key.
</td></tr>
<tr><th>arg 3</Th><td>int key1</td></tr>
<tr><th></th><td>Second integer search key.
</td></tr>
<tr><th>Return value</th><td>Returns zero if successful, otherwise returns minus error indicator value.
</td></tr>
<tr><th>Description</th><td>This deletes a value matching two integers from the search engine.
Once deleted, it will not be found any longer.
If there exist more than one, the first one will be deleted.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_int2_search">vce_get_int2_search</a>
<a href="#vce_init_int2_search">vce_init_int2_search</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_update_int2_search">vce_update_int2_search</a>
</td></tr>
</table><br><br>
<a name="vce_delete_int4_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_delete_int4_search</th></tr>
<tr><th>Summary</th><td>Delete a value from 4-integer search engine</td></tr>
<tr><th>Category</th><td>search</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_delete_int4_search( int index , int key0 , int key1, int key2, int key3 )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Search descriptor.
</td></tr>
<tr><th>arg 2</Th><td>int key0</td></tr>
<tr><th></th><td>First integer search key.
</td></tr>
<tr><th>arg 3</Th><td>int key1</td></tr>
<tr><th></th><td>Second integer search key.
</td></tr>
<tr><th>arg 4</Th><td>int key2</td></tr>
<tr><th></th><td>Third integer search key.
</td></tr>
<tr><th>arg 5</Th><td>int key3</td></tr>
<tr><th></th><td>Fourth integer search key.
</td></tr>
<tr><th>Return value</th><td>Returns zero if successful, otherwise returns minus error indicator value.
</td></tr>
<tr><th>Description</th><td>This deletes a value matching two integers from the search engine.
Once deleted, it will not be found any longer.
If there exist more than one, the first one will be deleted.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_int4_search">vce_get_int4_search</a>
<a href="#vce_init_int4_search">vce_init_int4_search</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_update_int4_search">vce_update_int4_search</a>
</td></tr>
</table><br><br>
<a name="vce_delete_int_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_delete_int_search</th></tr>
<tr><th>Summary</th><td>Delete a value from integer search engine</td></tr>
<tr><th>Category</th><td>search</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_delete_int_search( int index , int key )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Search descriptor.
</td></tr>
<tr><th>arg 2</Th><td>int key</td></tr>
<tr><th></th><td>Integer search key
</td></tr>
<tr><th>Return value</th><td>Returns zero if successful, otherwise minus error indicator value.
</td></tr>
<tr><th>Description</th><td>This deletes a value matching two integers from the search engine.
Once deleted, it will not be found any longer.
If there exist more than one, the first one will be deleted.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_int_search">vce_get_int_search</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_update_int_search">vce_update_int_search</a>
</td></tr>
</table><br><br>
<a name="vce_delete_string_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_delete_string_search</th></tr>
<tr><th>Summary</th><td>Delete a value from string search engine</td></tr>
<tr><th>Category</th><td>search</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_delete_string_search( int index , char *key )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Search descriptor.
</td></tr>
<tr><th>arg 2</Th><td>char *key</td></tr>
<tr><th></th><td>Search key string.
</td></tr>
<tr><th>Return value</th><td>Returns zero if successful, otherwise returns minus error indicator.
</td></tr>
<tr><th>Description</th><td>This deletes a couple of key and value matching with the
designated search key.
If there exist more than one, the first one will be deleted.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_string_search">vce_get_string_search</a>
<a href="#vce_init_string_search">vce_init_string_search</a>
<a href="#vce_update_string_search">vce_update_string_search</a>
</td></tr>
</table><br><br>
<a name="vce_delete_vstring_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_delete_vstring_search</th></tr>
<tr><th>Summary</th><td>Delete a value from string search engine</td></tr>
<tr><th>Category</th><td>search</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_delete_vstring_search( int index, char *key )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Search descriptor.
</td></tr>
<tr><th>arg 2</Th><td>char *key</td></tr>
<tr><th></th><td>Search key string.
</td></tr>
<tr><th>Return value</th><td>Returns zero if successful, otherwise returns minus error indicator value.
</td></tr>
<tr><th>Description</th><td>This deletes a couple of key and value matching
the designated search key.
If there exist more than one, the first one will be deleted.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_vstring_search">vce_get_vstring_search</a>
<a href="#vce_init_vstring_search">vce_init_vstring_search</a>
<a href="#vce_update_vstring_search">vce_update_vstring_search</a>
</td></tr>
</table><br><br>
<a name="vce_descape_string"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_descape_string</th></tr>
<tr><th>Summary</th><td>Convert an aescaped string to original string</td></tr>
<tr><th>Category</th><td></td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_descape_string( char *to, int tolen, char *from )</b></td>
<tr><th>arg 1</Th><td>char *to</td></tr>
<tr><th></th><td>Top address of destination string, which will contain
de-escaped(decoded) data.
</td></tr>
<tr><th>arg 2</Th><td>int tolen</td></tr>
<tr><th></th><td>Size of destination string.
</td></tr>
<tr><th>arg 3</Th><td>char *from</td></tr>
<tr><th></th><td>Top address of escaped source string.
</td></tr>
<tr><th>Return value</th><td>This returns length of the string outputted,
if the output destination buffer is adequate.
</td></tr>
<tr><th>Description</th><td>This restores the escaped string using vce_escape_string function.
If output destination buffer is too short,
this returns an error instead of destroying output.
However, note that contents of given buffer designated by "to"
argument will be overwritten.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_escape_string">vce_escape_string</a>
</td></tr>
</table><br><br>
<a name="vce_dump_buffer"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_dump_buffer</th></tr>
<tr><th>Summary</th><td>Dump binary data array using vce_errout.</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_dump_buffer( char *buf, int len )</b></td>
<tr><th>arg 1</Th><td>char *buf</td></tr>
<tr><th></th><td>Top address of data being dumped
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>Length of data being dumped
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>This logs all the array contents including binary data using
the vce_errout function.
This is so simple that displays dividing every 8 bytes in the buffer.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_errout">vce_errout</a>
</td></tr>
</table><br><br>
<a name="vce_encode_buffer_by_blowfish"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_encode_buffer_by_blowfish</th></tr>
<tr><th>Summary</th><td>Encrypt binary data array using Blowfish algorithm</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_encode_buffer_by_blowfish( char *buf , int len , char *k, int kl )</b></td>
<tr><th>arg 1</Th><td>char *buf</td></tr>
<tr><th></th><td>Top address of input buffer, which will be encrypted.
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>Length of input buffer
</td></tr>
<tr><th>arg 3</Th><td>char *k</td></tr>
<tr><th></th><td>Top address of encryption key data
</td></tr>
<tr><th>arg 4</Th><td>int kl</td></tr>
<tr><th></th><td>Length of encryption key
</td></tr>
<tr><th>Return value</th><td>Return minus return code when invalid arguments are given.
Otherwise returns 0.
</td></tr>
<tr><th>Description</th><td>Since the Blowfish algorithm is the block code in units of 8 bytes,
input other than length of multiples of 8 bytes are
not allowed to be entered within vce_encode_buffer_by_blowfish,
for avoiding unnecessary processing(VCE_EODDBUFSIZE).
Give 4 to 56 as argument "kl",
because the key length for Blowfish can range from 32 to 448 bits.
The "bf" program attached to VCE is the utility to encode files using
vce_encode_buffer_by_blowfish.
</td></tr>
<tr><th>See also</th><td>
<a href="#bf">bf</a>
<a href="#vce_decode_buffer_by_blowfish">vce_decode_buffer_by_blowfish</a>
</td></tr>
</table><br><br>
<a name="vce_encode_buffer_by_rijndael"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_encode_buffer_by_rijndael</th></tr>
<tr><th>Summary</th><td>Encrypt binary data array using Rijndael algorithm</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_encode_buffer_by_rijndael( char *buf , int len , char *k, int kl )</b></td>
<tr><th>arg 1</Th><td>char *buf</td></tr>
<tr><th></th><td>Top address of input buffer, which will be encrypted.
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>Length of input data
</td></tr>
<tr><th>arg 3</Th><td>char *k</td></tr>
<tr><th></th><td>Top address of encryption key
</td></tr>
<tr><th>arg 4</Th><td>int kl</td></tr>
<tr><th></th><td>Length of encryption key
</td></tr>
<tr><th>Return value</th><td>Returns minus error code when invalid arguments are given.
Otherwise returns 0.
</td></tr>
<tr><th>Description</th><td>The Rijndael algorithm is a block encryption algorithm
using 16/32 bytes unit.
vce_encode_buffer_by_rijndael also returns VCE_EODDBUFSIZE
when length of input buffer is not multiples of 16 bytes.
The key length can only be 16, 24 or 32 bytes.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_decode_buffer_by_rijndael">vce_decode_buffer_by_rijndael</a>
</td></tr>
</table><br><br>
<a name="vce_end_all_array"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_end_all_array</th></tr>
<tr><th>Summary</th><td>Release all VCE array.</td></tr>
<tr><th>Category</th><td>array</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_end_all_array( void )</b></td>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>Call vce_end_array against all VCE arrays maintained by VCE.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_init_array">vce_init_array</a>
</td></tr>
</table><br><br>
<a name="vce_end_array"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_end_array</th></tr>
<tr><th>Summary</th><td>Release a VCE array.</td></tr>
<tr><th>Category</th><td>array</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_end_array( int index )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Array descriptor, which is formerly returned by vce_init_array.
</td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td>Note that this releases an array itself, and not its elements.
All elements in the array will be released.
After invocation of vce_end_array, all the operations
concerning the array become unavailable.
vce_end_array function calls the FREE function inside it.
</td></tr>
<tr><th>See also</th><td>
<a href="#FREE">FREE</a>
<a href="#vce_init_array">vce_init_array</a>
</td></tr>
</table><br><br>
<a name="vce_errout"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_errout</th></tr>
<tr><th>Summary</th><td>Log output for VCE application</td></tr>
<tr><th>Category</th><td>core</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_errout( const char *format, ... )</b></td>
<tr><th>arg 1</Th><td>char *format</td></tr>
<tr><th></th><td>Format string. Same as "printf" libc function.
</td></tr>
<tr><th>arg 2</Th><td>...</td></tr>
<tr><th></th><td>Argument list. Same as "printf" function.
No argument is also acceptable.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="# vce_errout_set_another"> vce_errout_set_another</a>
<a href="# vce_verrout"> vce_verrout</a>
<a href="#vce_errout_config">vce_errout_config</a>
<a href="#vce_errout_v">vce_errout_v</a>
</td></tr>
</table><br><br>
<a name="vce_errout0"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_errout0</th></tr>
<tr><th>Summary</th><td>Print a string to stderr, and debug-output when win32.</td></tr>
<tr><th>Category</th><td>core</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_errout0( const char *s )</b></td>
<tr><th>arg 1</Th><td>char *s</td></tr>
<tr><th></th><td>Top address of string which will be printed out.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>This is the simplified version identical with vce_errout
not using vfprintf.
This is slightly faster.
In Win32 environment, it passes argument "s" to
OutputDebugString function, as well.
No output will be done when -1 is given to verbose mode.
Destination is same as vce_errout function's.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_errout">vce_errout</a>
<a href="#vce_errout0_v">vce_errout0_v</a>
</td></tr>
</table><br><br>
<a name="vce_errout0_v"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_errout0_v</th></tr>
<tr><th>Summary</th><td>Print a string to stderr when verbose mode.</td></tr>
<tr><th>Category</th><td>core</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_errout0_v( const char *s )</b></td>
<tr><th>arg 1</Th><td>char *s</td></tr>
<tr><th></th><td>Top address of string which will be printed out.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>LIke as vce_errout_v, this outputs errors only when verbose mode.
You cannot give any arguments to this function.
In Win32 environment, it passes argument "s" to
OutputDebugString function, as well.
No output will be done when -1 is given to verbose mode.
Destination is same as the vce_errout function.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_errout0">vce_errout0</a>
<a href="#vce_errout_v">vce_errout_v</a>
</td></tr>
</table><br><br>
<a name="vce_errout_config"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_errout_config</th></tr>
<tr><th>Summary</th><td>Set output directory of vce_errout() function.</td></tr>
<tr><th>Category</th><td>core</td></tr>
<tr><th>Compatibility</th><td>linux,win32,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_errout_config( const char *dirname, unsigned int rotate_size )</b></td>
<tr><th>arg 1</Th><td>char *dirname</td></tr>
<tr><th></th><td>Path string to the output directory.
</td></tr>
<tr><th>arg 2</Th><td>unsigned int rotate_size</td></tr>
<tr><th></th><td>Size of units of each divided log files.
For example, when 100*1024 is specified,
it will be output to another file every 100KB.
It will not divide, if 0 is specified.
</td></tr>
<tr><th>Return value</th><td>Returns minus value (VCE error code ). 0 if successful.
</td></tr>
<tr><th>Description</th><td>This sets up output directory for all VCE error output.
Error will be output to stderr (stdout for Windows) by default.
Designating a directory with vce_errout_config,
error output is saved within the directory
given the name
<code>stderr.PROCESS_NUMBER.PARTITION_NUMBER</code>
<BR>
PROCESS_NUMBER is getpid() of the server process using VCE,
and PARTITION_NUMBER starts from 0 and is incremented in turn,
according to the configuration of rotate_size.
It is standard to save logs using the rotation function and
log backup tools together.
No output at all when -1 is given to verbose mode.
</td></tr>
<tr><th>Example</th><td><pre>
  vce_errout( "Testing.\n" );    // Output this to stderr
  vce_errout_config( "/var/netgame1/error_output", 1000 );
  vce_errout( "Testing again.\n" ); // Output this to log directory divided each 1KB
</pre>  
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_errout">vce_errout</a>
</td></tr>
</table><br><br>
<a name="vce_errout_set_another"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_errout_set_another</th></tr>
<tr><th>Summary</th><td>pending</td></tr>
<tr><th>Category</th><td>core</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_errout_set_another(void (*callback)(int vmode,const char *str))</b></td>
<tr><th>arg 1</Th><td>void (*callback)(int vmode,const char *str)</td></tr>
<tr><th></th><td>pending
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>pending
</td></tr>
<tr><th>Bugs/TODO</th><td>pending
</td></tr>
<tr><th>See also</th><td>
<a href="# vce_errout_config"> vce_errout_config</a>
<a href="#vce_errout">vce_errout</a>
</td></tr>
</table><br><br>
<a name="vce_errout_v"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_errout_v</th></tr>
<tr><th>Summary</th><td>Print log message when VCE is set verbose mode</td></tr>
<tr><th>Category</th><td>core</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_errout_v( const char *format, ... )</b></td>
<tr><th>arg 1</Th><td>char *format</td></tr>
<tr><th></th><td>Format string. same as "printf" function.
</td></tr>
<tr><th>arg 2</Th><td>...</td></tr>
<tr><th></th><td>Argument list, same as "printf" function.
No argument is also acceptable.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>This outputs only when VCE is in verbose mode
(i.e. in case of vce_set_verbose_mode(1) ).
If a directory is designated with vce_errout_config function,
this outputs to the directory (in this case logs are rotated
automatically ).
No output will be done when -1 is given to verbose mode.
The output destination is same as the vce_errout function.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_errout">vce_errout</a>
<a href="#vce_errout_config">vce_errout_config</a>
</td></tr>
</table><br><br>
<a name="vce_escape_string"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_escape_string</th></tr>
<tr><th>Summary</th><td>Escape a string</td></tr>
<tr><th>Category</th><td>text</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_escape_string( char *to, int tolen, char *from, int fromlen )</b></td>
<tr><th>arg 1</Th><td>char *to</td></tr>
<tr><th></th><td>Top address of destination string.
Escaped string will be written in this buffer.
</td></tr>
<tr><th>arg 2</Th><td>int tolen</td></tr>
<tr><th></th><td>Size of destination size. It's safe choosing (fromlen*2+1) for
this buffer.
</td></tr>
<tr><th>arg 3</Th><td>char *from</td></tr>
<tr><th></th><td>Top address of source(plain) string.
</td></tr>
<tr><th>arg 4</Th><td>int fromlen</td></tr>
<tr><th></th><td>Length of source data.
This data is treated as binary data, so you can include '\0'
inside this data.
</td></tr>
<tr><th>Return value</th><td>When the output destination buffer is too short,
this returns an error (VCE_ETOOSHORT), instead of a broken string.
Destination string terminates with a null character.
If the buffer is sufficient, it returns length of string output.
</td></tr>
<tr><th>Description</th><td>This escapes '\0', '\n', '\\', '\r', '\"', '\'', '\032'
to have these letter not be included directly in output string.
Basic logic is equivalent to mysql_escape_string of MySQL,
but error check is stricter.
The letters escaped with this function can be restored
with vce_descape_string.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_descape_string">vce_descape_string</a>
</td></tr>
</table><br><br>
<a name="vce_extract_data_from_hex_text"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_extract_data_from_hex_text</th></tr>
<tr><th>Summary</th><td>Convert hextext format ASCII text into a binary data array.</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_extract_data_from_hex_text( const char *buf, int len, char *out, int outlen )</b></td>
<tr><th>arg 1</Th><td>char *buf</td></tr>
<tr><th></th><td>Top address of input ASCII text string.
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>Length of input text string ( in bytes )
</td></tr>
<tr><th>arg 3</Th><td>char *out</td></tr>
<tr><th></th><td>Top address of destination binary data buffer.
</td></tr>
<tr><th>arg 4</Th><td>int outlen</td></tr>
<tr><th></th><td>Size of destination binary data buffer.
</td></tr>
<tr><th>Return value</th><td>This returns VCE_EFORMAT if source text is not well formatted.
This also returns  negative error code when other errors.
Positive number (binary bytes) for complete success.
</td></tr>
<tr><th>Description</th><td>This reads hextext format buffer into a binary array
after checking validity of contents of "buf".
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_make_hex_text_from_buffer">vce_make_hex_text_from_buffer</a>
</td></tr>
</table><br><br>
<a name="vce_finalize"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_finalize</th></tr>
<tr><th>Summary</th><td>Release all resources used by VCE.</td></tr>
<tr><th>Category</th><td>core</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_finalize( void )</b></td>
<tr><th>Return value</th><td>Returns 0 if successful. Otherwise minus error indicator value.
</td></tr>
<tr><th>Description</th><td>This releases all the resources used by VCE.
All VCE function invocation after calling this function will be an
undefined action except vce_errout*.
</td></tr>
</table><br><br>
<a name="vce_free_array_object"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_free_array_object</th></tr>
<tr><th>Summary</th><td>Free an element of a VCE array.</td></tr>
<tr><th>Category</th><td>array</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_free_array_object( int index , void *p )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Array descriptor to specify VCE array.
</td></tr>
<tr><th>arg 2</Th><td>void *p</td></tr>
<tr><th></th><td>Top address of an element in the array.
</td></tr>
<tr><th>Return value</th><td>Returns 0 if successful. Otherwise negative error code.
</td></tr>
<tr><th>Description</th><td>vce_free_array_object function can be used within the ARRAY_SCAN macro.
This function never write anything onto the contents of the buffer
being released.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_alloc_array_object">vce_alloc_array_object</a>
<a href="#vce_free_array_object_all">vce_free_array_object_all</a>
<a href="#vce_init_array">vce_init_array</a>
</td></tr>
</table><br><br>
<a name="vce_free_array_object_all"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_free_array_object_all</th></tr>
<tr><th>Summary</th><td>Free all elements in an array</td></tr>
<tr><th>Category</th><td>array</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_free_array_object_all( int index )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Array descriptor to specify VCE array.
</td></tr>
<tr><th>Return value</th><td>NOne
</td></tr>
<tr><th>Description</th><td>Free all used elements in an array.
</td></tr>
<tr><th>Bugs/TODO</th><td>This is comparatively slow, because it releases one by one at the moment.
Speeding up through simultaneous entire
initialization is planned (version 1 and later).
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_free_array_object">vce_free_array_object</a>
<a href="#vce_init_array">vce_init_array</a>
</td></tr>
</table><br><br>
<a name="vce_get_array_maxnum"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_array_maxnum</th></tr>
<tr><th>Summary</th><td>Get max number of array elements</td></tr>
<tr><th>Category</th><td>array</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_get_array_maxnum( int index )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Array descriptor of target VCE array
</td></tr>
<tr><th>Return value</th><td>Max number of elements in the array.
</td></tr>
<tr><th>Description</th><td>This function returns max number of elemnts in the array.
Same as vce_init_array's "num" parameter.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_array_member_size">vce_get_array_member_size</a>
<a href="#vce_init_array">vce_init_array</a>
</td></tr>
</table><br><br>
<a name="vce_get_array_member_size"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_array_member_size</th></tr>
<tr><th>Summary</th><td>Get size of each members of an array</td></tr>
<tr><th>Category</th><td>array</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_get_array_member_size( int index )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Array descriptor of target VCE array
</td></tr>
<tr><th>Return value</th><td>Array member size (the first argument value of vce_init_array)
Return a negative error code, in case of invalid argument.
</td></tr>
<tr><th>Description</th><td>This is the value of the size argument of vce_init_array
function that gets the size of the array controlled by the VCE array
control routine.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_array_maxnum">vce_get_array_maxnum</a>
<a href="#vce_init_array">vce_init_array</a>
</td></tr>
</table><br><br>
<a name="vce_get_array_object_index"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_array_object_index</th></tr>
<tr><th>Summary</th><td>Get index number of an element in an VCE array.</td></tr>
<tr><th>Category</th><td>array</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_get_array_object_index( int index , void *p )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Array descriptor to specify VCE's array.
</td></tr>
<tr><th>arg 2</Th><td>void *p</td></tr>
<tr><th></th><td>Pointer to an element in the array.
</td></tr>
<tr><th>Return value</th><td>Return VCE_EINVAL, if an argument is invalid.
If a pointer is not a suitable value, return VCE_EALIGNMENT.
Return 0 or more as index, in case of success.
</td></tr>
<tr><th>Description</th><td>The vce_get_array_object_index function determines an index through
subtracting the designated pointer from an array's top pointer.
</td></tr>
</table><br><br>
<a name="vce_get_array_object_last"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_array_object_last</th></tr>
<tr><th>Summary</th><td>Get last element of VCE array.</td></tr>
<tr><th>Category</th><td>array</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void * vce_get_array_object_last( int index )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Array descriptor to specify VCE's array.
</td></tr>
<tr><th>Return value</th><td>Pointer to the last element of the array.
Returns NULL if no element is available.
</td></tr>
<tr><th>Description</th><td>This obtains the pointer to the last element among the VCE arrays in use.
Since vce_alloc_array_object is always added to the head of the link in use,
FIFO-like processing can be done by using vce_alloc_array_object and this
function, in other words, the array that only allows addition to the head
and extraction from the tail.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_alloc_array_object">vce_alloc_array_object</a>
<a href="#vce_get_array_object_next">vce_get_array_object_next</a>
<a href="#vce_get_array_object_top">vce_get_array_object_top</a>
</td></tr>
</table><br><br>
<a name="vce_get_array_object_next"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_array_object_next</th></tr>
<tr><th>Summary</th><td>Get an VCE array element succeedinng given elemnt</td></tr>
<tr><th>Category</th><td>array</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void * vce_get_array_object_next( int index , void *p )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Array descriptor of the VCE's array.
</td></tr>
<tr><th>arg 2</Th><td>void *p</td></tr>
<tr><th></th><td>vce_get_array_object_next returns an element in the array
next to the element specified by parameter "p".
</td></tr>
<tr><th>Return value</th><td>Pointer to next element.
Null pointer if next element is not found.
</td></tr>
<tr><th>Description</th><td>vce_get_array_object_next is used within the ARRAY_SCAN macro.
Regular applications should not use this function directly.
The ARRAY_SCAN macro is safer and sure to use.
</td></tr>
<tr><th>See also</th><td>
<a href="#ARRAY_SCAN">ARRAY_SCAN</a>
<a href="#vce_get_array_object_top">vce_get_array_object_top</a>
</td></tr>
</table><br><br>
<a name="vce_get_array_object_pointer_by_index"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_array_object_pointer_by_index</th></tr>
<tr><th>Summary</th><td>Get a VCE array element by index number</td></tr>
<tr><th>Category</th><td>array</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void *vce_get_array_object_pointer_by_index( int index, int objindex )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Array descriptor to specify VCE's array
</td></tr>
<tr><th>arg 2</Th><td>int objindex</td></tr>
<tr><th></th><td>Index of the element which you want to get.
</td></tr>
<tr><th>Return value</th><td>Pointer to the element.
</td></tr>
<tr><th>Description</th><td>Normally, VCE elements are accessed with ARRAY_SCAN or a pointer;
but you can also access the element by specifying index of it
by this function.
As returning a NULL pointer,
the contents of an error may be known by using vce_get_last_error.
</td></tr>
<tr><th>Example</th><td>  // Initialize all elements of array without checking if they're used
  for(int i=0;;i++){
      sometype *t = vce_get_array_object_pointer_by_index( memind, i );
      if( t == NULL )break;
      t->someparam = somevalue;
  }
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_array_object_pointer_by_index_only_used">vce_get_array_object_pointer_by_index_only_used</a>
<a href="#vce_init_array">vce_init_array</a>
</td></tr>
</table><br><br>
<a name="vce_get_array_object_pointer_by_index_only_used"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_array_object_pointer_by_index_only_used</th></tr>
<tr><th>Summary</th><td>Get a VCE array element by index number, which are being used</td></tr>
<tr><th>Category</th><td>array</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void * vce_get_array_object_pointer_by_index_only_used( int index, int objindex )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Array descriptor to specify VCE's array
</td></tr>
<tr><th>arg 2</Th><td>int objindex</td></tr>
<tr><th></th><td>Index number of the element which you want to get.
</td></tr>
<tr><th>Return value</th><td>Pointer to the element. Returns NULL pointer if the element is not used
currently.
</td></tr>
<tr><th>Description</th><td>Almost same as vce_get_array_object_pointer_by_index,
but you can select used elements using this function.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_array_object_pointer_by_index">vce_get_array_object_pointer_by_index</a>
<a href="#vce_init_array">vce_init_array</a>
</td></tr>
</table><br><br>
<a name="vce_get_array_object_top"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_array_object_top</th></tr>
<tr><th>Summary</th><td></td></tr>
<tr><th>Category</th><td>array</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void * vce_get_array_object_top( int index )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Array descriptor to specify VCE's array.
</td></tr>
<tr><th>Return value</th><td>Pointer to an element in the array.
Null pointer if there is no allocated element in the array.
</td></tr>
<tr><th>Description</th><td>vce_get_array_object_top is used inside the ARRAY_SCAN macro.
The ARRAY_SCAN macro is implemented for scanning all the array
elements in use, and this function fetches the head of those elements.
It is often useful for normal
applications to directly use the ARRAY_SCAN macro, not this function.
</td></tr>
<tr><th>See also</th><td>
<a href="#ARRAY_SCAN">ARRAY_SCAN</a>
<a href="#vce_get_array_object_next">vce_get_array_object_next</a>
</td></tr>
</table><br><br>
<a name="vce_get_array_usenum"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_array_usenum</th></tr>
<tr><th>Summary</th><td>Count how many</td></tr>
<tr><th>Category</th><td>array</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_get_array_usenum( int index )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Array descriptor to specify VCE's array.
</td></tr>
<tr><th>Return value</th><td>Number of currently used elements in an array.
</td></tr>
<tr><th>Description</th><td>Get number of elements currently in-use, without scanning
through the array.
This function is really fast because it does not scan the array.
</td></tr>
<tr><th>See also</th><td>
<a href="#ARRAY_SCAN">ARRAY_SCAN</a>
<a href="#vce_init_array">vce_init_array</a>
</td></tr>
</table><br><br>
<a name="vce_get_current_utime"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_current_utime</th></tr>
<tr><th>Summary</th><td>Get current time by VCEI64 data type</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,darwin</td></tr>
<tr><th>Prototype</th><td><b>VCEI64 vce_get_current_utime( void )</b></td>
<tr><th>Return value</th><td>The current time.
In UNIX environment, this function will convert "timeval" structure
into VCEI64 type.
In this case, "timeval" is got by gettimeofday function.
In Win32 environment, this function will convert "SYSTEMTIME"
into VCEI64 type.
In this case, "SYSTEMTIME" is got by GetSystemTime function.
</td></tr>
<tr><th>Description</th><td>The source value of timeval
is a value obtained by converting returned value from
gettimeofday().
VCE renews the return value each time vce_heartbeat is invoked.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_set_internal_timer">vce_set_internal_timer</a>
</td></tr>
</table><br><br>
<a name="vce_get_int2_or_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_int2_or_search</th></tr>
<tr><th>Summary</th><td>Search a value in 2-integer search engine</td></tr>
<tr><th>Category</th><td>search</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void* vce_get_int2_or_search( int index, int key0, int key1, void **next_ptr, int *next_index )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Search descriptor.
</td></tr>
<tr><th>arg 2</Th><td>int key0</td></tr>
<tr><th></th><td>First integer search key.
</td></tr>
<tr><th>arg 3</Th><td>int key1</td></tr>
<tr><th></th><td>Second integer seach key.
</td></tr>
<tr><th>arg 4</Th><td>void **next_ptr</td></tr>
<tr><th></th><td>PENDING.
</td></tr>
<tr><th>arg 5</Th><td>int next_index</td></tr>
<tr><th></th><td>PENDING.
</td></tr>
<tr><th>Return value</th><td>Pointer to an element matched.
</td></tr>
<tr><th>Description</th><td>PENDING.
</td></tr>
<tr><th>Example</th><td><pre>
  int i2is = vce_init_int2_search( 10, 5, "foo" );
       .
       .
       .
  int input_IP   = 0x23445599;
  int input_Port = 0;
  int next_index = 0;
  void *cinfop, *next_ptr = NULL;

  while (1)
  {
    cinfop = vce_get_int2_or_search( i2si, input_IP, input_Port, &next_ptr, &next_index);
    if ( !cinfop ) break;
       .
       .
       .
  }
</pre>
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_delete_int2_search">vce_delete_int2_search</a>
<a href="#vce_get_int2_search">vce_get_int2_search</a>
<a href="#vce_init_int2_search">vce_init_int2_search</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_update_int2_search">vce_update_int2_search</a>
</td></tr>
</table><br><br>
<a name="vce_get_int2_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_int2_search</th></tr>
<tr><th>Summary</th><td>Search a value in 2-integer search engine</td></tr>
<tr><th>Category</th><td>search</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void* vce_get_int2_search( int index , int key0 , int key1 )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Search descriptor.
</td></tr>
<tr><th>arg 2</Th><td>int key0</td></tr>
<tr><th></th><td>First integer search key.
</td></tr>
<tr><th>arg 3</Th><td>int key1</td></tr>
<tr><th></th><td>Second integer seach key.
</td></tr>
<tr><th>Return value</th><td>Pointer to an element matched.
</td></tr>
<tr><th>Description</th><td>This fetches only a values matching with two search keys
at the same time.
Refer to vce_init_int_search for searching method.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_delete_int2_search">vce_delete_int2_search</a>
<a href="#vce_get_int2_or_search">vce_get_int2_or_search</a>
<a href="#vce_init_int2_search">vce_init_int2_search</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_update_int2_search">vce_update_int2_search</a>
</td></tr>
</table><br><br>
<a name="vce_get_int4_or_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_int4_or_search</th></tr>
<tr><th>Summary</th><td>Search a value in 4-integer search engine</td></tr>
<tr><th>Category</th><td>search</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void* vce_get_int4_or_search( int index, int key0, int key1, int key2, int key3, void **next_ptr, int *next_index )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Search descriptor.
</td></tr>
<tr><th>arg 2</Th><td>int key0</td></tr>
<tr><th></th><td>First integer search key.
</td></tr>
<tr><th>arg 3</Th><td>int key1</td></tr>
<tr><th></th><td>Second integer seach key.
</td></tr>
<tr><th>arg 4</Th><td>int key2</td></tr>
<tr><th></th><td>Third integer seach key.
</td></tr>
<tr><th>arg 5</Th><td>int key3</td></tr>
<tr><th></th><td>Fourth integer seach key.
</td></tr>
<tr><th>arg 6</Th><td>void **next_ptr</td></tr>
<tr><th></th><td>PENDING.
</td></tr>
<tr><th>arg 7</Th><td>int next_index</td></tr>
<tr><th></th><td>PENDING.
</td></tr>
<tr><th>Return value</th><td>Pointer to an element matched.
</td></tr>
<tr><th>Description</th><td>PENDING.
</td></tr>
<tr><th>Example</th><td><pre>
  int i4is = vce_init_int4_search( 10, 5, "foo" );
       .
       .
       .
  int input_key0 = 0x23445599;
  int input_key1 = 0;
  int input_key2 = 0;
  int input_key3 = 0;
  int next_index = 0;
  void *cinfop, *next_ptr = NULL;

  while (1)
  {
    cinfop = vce_get_int4_or_search( i4si, input_key0, input_key1,
                                     input_key2, input_key3, &next_ptr,
                                     &next_index);
    if ( !cinfop ) break;
       .
       .
       .
  }
</pre>
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_delete_int4_search">vce_delete_int4_search</a>
<a href="#vce_get_int4_search">vce_get_int4_search</a>
<a href="#vce_init_int4_search">vce_init_int4_search</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_update_int4_search">vce_update_int4_search</a>
</td></tr>
</table><br><br>
<a name="vce_get_int4_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_int4_search</th></tr>
<tr><th>Summary</th><td>Search a value in 4-integer search engine</td></tr>
<tr><th>Category</th><td>search</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void* vce_get_int4_search( int index , int key0 , int key1, int key2, int key3  )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Search descriptor.
</td></tr>
<tr><th>arg 2</Th><td>int key0</td></tr>
<tr><th></th><td>First integer search key.
</td></tr>
<tr><th>arg 3</Th><td>int key1</td></tr>
<tr><th></th><td>Second integer seach key.
</td></tr>
<tr><th>arg 4</Th><td>int key2</td></tr>
<tr><th></th><td>Third integer seach key.
</td></tr>
<tr><th>arg 5</Th><td>int key3</td></tr>
<tr><th></th><td>Fourth integer seach key.
</td></tr>
<tr><th>Return value</th><td>Pointer to an element matched.
</td></tr>
<tr><th>Description</th><td>This fetches only a values matching with two search keys
at the same time.
Refer to vce_init_int_search for searching method.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_delete_int4_search">vce_delete_int4_search</a>
<a href="#vce_get_int4_or_search">vce_get_int4_or_search</a>
<a href="#vce_init_int4_search">vce_init_int4_search</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_update_int4_search">vce_update_int4_search</a>
</td></tr>
</table><br><br>
<a name="vce_get_int_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_int_search</th></tr>
<tr><th>Summary</th><td>Search a value in a integer seach engine</td></tr>
<tr><th>Category</th><td>search</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void * vce_get_int_search( int index , int key )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Search descriptor.
</td></tr>
<tr><th>arg 2</Th><td>int key</td></tr>
<tr><th></th><td>Integer search key.
</td></tr>
<tr><th>Return value</th><td>Result of search value.
Inside search engine, each value is not saved directly as it is,
but is saved as a pointer to the value.
It returns its pointer, when it is found.
If not found, returns NULL pointer.
</td></tr>
<tr><th>Description</th><td>First you register a value with search engine initialized
by vce_init_int_search using vce_update_int_search,
and fetch a value using vce_get_int_search.
vce_get_int_search searches a value using integer search engine.
vce_get_int_search is extremely fast,
and if hash table is large enough,
it can reach the search speed of below 1 microseconds irrespective
with how many elements are included in the search engine.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_init_int_search">vce_init_int_search</a>
</td></tr>
</table><br><br>
<a name="vce_get_ipv4_addr_by_name"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_ipv4_addr_by_name</th></tr>
<tr><th>Summary</th><td>Get network byte order IPv4 address from host name string</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_get_ipv4_addr_by_name( unsigned int *a, const char *s );</b></td>
<tr><th>arg 1</Th><td>unsigned int *a</td></tr>
<tr><th></th><td>Pointer to output IPv4 network byte-order address.
equivalent to in_addr.s_addr.
</td></tr>
<tr><th>arg 2</Th><td>char *s</td></tr>
<tr><th></th><td>Hostname. "192.168.1.2" and "www.vce-lab.net" are acceptable.
</td></tr>
<tr><th>Return value</th><td>Returns 0 if successful. Otherwise minus error indicator value.
</td></tr>
<tr><th>Description</th><td>In UNIX systems, inet_aton(), and gethostbyname() are called sequently.
In Win32 systems, inet_addr(), and gethostbyname() are called sequently.
In PlanetWeb, this is not compatible with DNS resolving.
</td></tr>
</table><br><br>
<a name="vce_get_last_error"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_last_error</th></tr>
<tr><th>Summary</th><td>Get last error code occured inside VCE library.</td></tr>
<tr><th>Category</th><td>err</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_get_last_error(void);</b></td>
<tr><th>Return value</th><td>Error code.
</td></tr>
<tr><th>Description</th><td>The error numbers obtained through by this function are
all defined in vce.h.
Accordingly, details of such error can be known,
or vce_strerror can be used to record it to a log.
However, the contents of string returned by
vce_strerror may possibly be modified in the future,
such output string should not be parsed and used for
further processing.
The error codes defined in vce.h will not be modified.
(becomes a missing number if deleted)
</td></tr>
<tr><th>Example</th><td><pre>
// vce_tcpcontext_create often meets errors...
tcpcontext_t t = vce_tcpcontext_create( .... );
if( !t ){
    vce_errout( "Cannot create tcpcontext! %s\n",
    vce_strerror( vce_get_last_error() ) );
}
</pre>
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_strerror">vce_strerror</a>
</td></tr>
</table><br><br>
<a name="vce_get_netstat_string"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_netstat_string</th></tr>
<tr><th>Summary</th><td>Get all connection information maintained by VCE in string format</td></tr>
<tr><th>Category</th><td>log</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_get_netstat_string( char *buf, int maxlen )</b></td>
<tr><th>arg 1</Th><td>char *buf</td></tr>
<tr><th></th><td>Top address of destination string buffer.
</td></tr>
<tr><th>arg 2</Th><td>int maxlen</td></tr>
<tr><th></th><td>Size of destination string buffer.
</td></tr>
<tr><th>Return value</th><td>Returns zero if buffer is not filled up.
Otherwise(if filled) returns VCE_EFULL.
</td></tr>
<tr><th>Description</th><td>This fetches information regarding all connections administrated
by VCE in a string buffer.
This looks like output of the UNIX netstat command.
Information of respective connections are "PARAM=VALUE" separated
with commas, and one line represents one connection (socket).
Basic 4 types of lines are "circ","conn","listen_circ"
and "listen_conn".
Types of information displayed in "conn" is the most various. 

<UL>
<LI>In cases of "type=conn"<BR>
"type=conn" represents a normal connection.
<UL>
<LI>r=NUM<BR>
Length of recv buffer (plain)
<LI>w=NUM<BR>
Length of send buffer (plain)
<LI>er=NUM<BR>
Length of recv buffer (encoded)
<LI>ew=NUM<BR>
Length of send buffer (encoded)
<LI>rem=STR<BR>
Remote address, output of vce_conn_get_remote_addr_string
<LI>loc=STR<BR>
Local address, output of vce_conn_get_local_addr_string
<LI>fd=NUM<BR>
Socket fd of operating system.
<LI>s=NUM<BR>
Serial number of conn_t within VCE
<LI>last=NUM<BR>
Date of last access
<LI>timeo=NUM<BR>
Remaining time till timeout
<LI>nego=NUM<BR>
Cipher negotiation state
</ul>

<li>In case of "type=circ"<BR>
"type=circ" represents a virtual circuit (circ_t)
<ul>
<LI>r=NUM<BR>
Length of reading buffer (plain)
<LI>rem=STR<BR>
Remote address, output of vce_circ_get_remote_addr_string
<LI>loc=STR<BR>
Local address, displays local address of its parent conn_t 
<LI>s=NUM<BR>
Serial number of circ_t
<LI>s=NUM<BR>
Serial number of circ_t
<LI>last=NUM<BR>
Date of last access
</ul>

<LI>In case of "type=listen_circ", and "type=listen_conn"<BR>
One each of these types are displayed for respective
waiting tcpcontexts, though not representing
connections connected with other hosts.
<ul>
<LI>loc=STR<BR>
Local address, binding a socket.
<LI>fd=NUM File Descriptor of a socket.
</ul>
</ul>
An application needs to allocate memory for output buffer and
give it to this function.
Please note that you have to allocate relatively big output buffer
because this function uses 200 bytes for each line at most.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_stat">vce_get_stat</a>
</td></tr>
</table><br><br>
<a name="vce_get_search_usenum"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_search_usenum</th></tr>
<tr><th>Summary</th><td>Get number of used entry of search engine</td></tr>
<tr><th>Category</th><td>search</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_get_search_usenum( int index )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Search descriptor.
</td></tr>
<tr><th>Return value</th><td>Returns number of entries currently used.
Returns error code if error.
</td></tr>
<tr><th>Description</th><td>With regard to a search engine,
entries will increase with update and decrease with delete.
If you forget to delete after updating search engine,
all the entries are used up to maximum number.
This kind of program bug often happens in server program.

Checking the number of usage of entries periodically
using this function will help debugging search
engine related programming.
This function is usable among all kinds of search engines.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_init_int_search">vce_init_int_search</a>
</td></tr>
</table><br><br>
<a name="vce_get_stat"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_stat</th></tr>
<tr><th>Summary</th><td>Get overall VCE activity statistics information.</td></tr>
<tr><th>Category</th><td>log</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_get_stat( vce_stat_t *v )</b></td>
<tr><th>arg 1</Th><td>vce_stat_t *v</td></tr>
<tr><th></th><td>Pointer to vce_stat_t which contains statistics information.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>This function stores entire VCE statistical information in
vce_stat_t structure.
Meanings of structure members are as follows 
<UL>
<LI>time_t boot_time<BR>
Startup time of vce_initialize (time_t)
<LI>VCEI64 recv_byte,send_byte<BR>
Total write/read bytes
<LI>VCEI64 send_syscall, send_syscall_e<BR>
Number of invocation of the system call send(),
"_e" represents error occurrence.
<LI>VCEI64 recv_syscall, recv_syscall_e<BR>
Number of invocation of system call recv(),
"_e" represents error occurrence.
<LI>VCEI64 accept_syscall, accept_syscall_e<BR>
Number of invocation of system call accept(),
"_e" represents error occurrence.
<LI>VCEI64 connect_syscall, connect_syscall_e<BR>
Number of invocation of system call connect(),
"_e" represents error occurrence.
<LI>conn_free, conn_alloc, conn_close, conn_write<BR>
Number of invocation of respective VCE functions
<LI>keyex<BR>
Total number of key exchanges using DiffieHellman
key exchange. This is used for load test of key exchanging or others.
<LI>tcpcontext_create,tcpcontext_cleanup,tcpcontext_connect<BR>
Number of invocation of respective functions.
Note that only successful invocation is counted.
<LI>conn_timeout<BR>
Number of connections (conn_t) that met timeout.
<LI>log_count<BR>
Number of invocation of vce_errout or vce_errout0.
</ul>
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_stat">vce_conn_get_stat</a>
<a href="#vce_tcpcontext_get_stat">vce_tcpcontext_get_stat</a>
</td></tr>
</table><br><br>
<a name="vce_get_string_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_string_search</th></tr>
<tr><th>Summary</th><td>Search a value in string search engine</td></tr>
<tr><th>Category</th><td>search</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void * vce_get_string_search( int index , char *key )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Search descriptor.
</td></tr>
<tr><th>arg 2</Th><td>char *key</td></tr>
<tr><th></th><td>Search key string.
</td></tr>
<tr><th>Return value</th><td>Returns registered pointer value in this search engine if
the search engine can find search key. Otherwise returns NULL pointer.
</td></tr>
<tr><th>Description</th><td>This searches a value by key string.
Please refer to explanation of integer search engine
"vce_init_int_search" for detail.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_delete_string_search">vce_delete_string_search</a>
<a href="#vce_get_int_search">vce_get_int_search</a>
<a href="#vce_init_string_search">vce_init_string_search</a>
<a href="#vce_update_string_search">vce_update_string_search</a>
</td></tr>
</table><br><br>
<a name="vce_get_tcp_packet_read_size"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_tcp_packet_read_size</th></tr>
<tr><th>Summary</th><td>PENDING</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32</td></tr>
<tr><th>Prototype</th><td><b>void vce_get_tcp_packet_read_size(int *original, int *processing)</b></td>
<tr><th>arg 1</Th><td>int *original</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>arg 2</Th><td>int *processing</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>Return value</th><td>PENDING
</td></tr>
<tr><th>Description</th><td>PENDING
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_tcp_packet_read_size">vce_get_tcp_packet_read_size</a>
</td></tr>
</table><br><br>
<a name="vce_get_tcp_packet_write_size"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_tcp_packet_write_size</th></tr>
<tr><th>Summary</th><td>PENDING</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32</td></tr>
<tr><th>Prototype</th><td><b>void vce_get_tcp_packet_write_size(int *original, int *processing)</b></td>
<tr><th>arg 1</Th><td>int *original</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>arg 2</Th><td>int *processing</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>PENDING
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_tcp_packet_read_size">vce_get_tcp_packet_read_size</a>
</td></tr>
</table><br><br>
<a name="vce_get_version"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_version</th></tr>
<tr><th>Summary</th><td>Get VCE's version numbers</td></tr>
<tr><th>Category</th><td>core</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_get_version( int *majv, int *minv , int *rel )</b></td>
<tr><th>arg 1</Th><td>int *majv</td></tr>
<tr><th></th><td>Major version of VCE library. 0 if VCE version is "0.2.1".
</td></tr>
<tr><th>arg 2</Th><td>int *minv</td></tr>
<tr><th></th><td>Minor version number of VCE. 2 if VCE version is "0.2.1".
</td></tr>
<tr><th>arg 3</Th><td>int *rel</td></tr>
<tr><th></th><td>VCE's release version. 1 if VCE version is "0.2.1".
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>The version number is embedded in the VCE library.
The vce_get_version function gets those numbers as an int value.
</td></tr>
</table><br><br>
<a name="vce_get_vstring_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_get_vstring_search</th></tr>
<tr><th>Summary</th><td>Search a value in arbitrary length string search engine</td></tr>
<tr><th>Category</th><td>search</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void * vce_get_vstring_search( int index, char *key )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Search descriptor.
</td></tr>
<tr><th>arg 2</Th><td>char *key</td></tr>
<tr><th></th><td>Search key string.
</td></tr>
<tr><th>Return value</th><td>Returns registered valid pointer if search is successful.
If no entry is found, returns NULL pointer.
</td></tr>
<tr><th>Description</th><td>This searches a value by a key string of the arbitrary length.
Please refer to explanation of integer search engine
"vce_init_int_search" for detail.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_init_vstring_search">vce_init_vstring_search</a>
</td></tr>
</table><br><br>
<a name="vce_heartbeat"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_heartbeat</th></tr>
<tr><th>Summary</th><td></td></tr>
<tr><th>Category</th><td>core</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_heartbeat( void )</b></td>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>This runs VCE I/O routine once, to flush all incoming/outgoing data.
vce_mainloop function keeps calling this function.
More flexible user main routines can be made using
this function instead of vce_mainloop.
Note that the functions designated by the
vce_set_mainloop_callback function will not be called as
driving VCE with this function.
By default, vce_heartbeat returns straight after it invocation,
however, starting up a server as is will cause full usage of the CPU time.
This situation can be avoided through adjusting the sleep
time using the vce_set_heartbeat_wait_flag function.
Of course, the adjustment to avoid full usage of the CPU time may
also be done on the application side,
and in fact, that will enable best suited CPU time usage
depending on your application.
</td></tr>
<tr><th>Example</th><td><pre>
  #include "vce.h"
  int main()
  {
      while(1){
          user_function();
          vce_heartbeat();
      }
  }
</pre>
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_mainloop">vce_mainloop</a>
<a href="#vce_set_heartbeat_wait_flag">vce_set_heartbeat_wait_flag</a>
<a href="#vce_set_mainloop_callback">vce_set_mainloop_callback</a>
</td></tr>
</table><br><br>
<a name="vce_httptext_divide_header_and_content"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_httptext_divide_header_and_content</th></tr>
<tr><th>Summary</th><td>Divide message body and request header in HTTP input data.</td></tr>
<tr><th>Category</th><td>text</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_httptext_divide_header_and_content( char *in , int inlen, char **head, int *headlen, char **body, int *bodylen )</b></td>
<tr><th>arg 1</Th><td>char *in</td></tr>
<tr><th></th><td>Top address of input data buffer.
</td></tr>
<tr><th>arg 2</Th><td>int inlen</td></tr>
<tr><th></th><td>Length of input data
</td></tr>
<tr><th>arg 3</Th><td>char **head</td></tr>
<tr><th></th><td>Array of pointer to each header lines
</td></tr>
<tr><th>arg 4</Th><td>int *headlen</td></tr>
<tr><th></th><td>Array of int which contains length of each header lines.
Pointer result parameter.
</td></tr>
<tr><th>arg 5</Th><td>char **body</td></tr>
<tr><th></th><td>Pointer to pointer to message body.
</td></tr>
<tr><th>arg 6</Th><td>int *bodylen</td></tr>
<tr><th></th><td>Pointer to length of message body.
</td></tr>
<tr><th>Return value</th><td>In case a header is not existing (no delimiters),
headlen = 0 and the returned value will be 0.
In case the message body is not existing,
body=NULL, bodylen = 0, and the returned value will be 0.
If neither is existing, headlen=0, body=NULL, bodylen=0,
and VCE_EFORMAT is returned.
</td></tr>
<tr><th>Description</th><td>This separates request headers and message body in HTTP incoming data.
Everything is processed on memory.
"\r\n\r\n" is deemed as a turning point, though it corresponds with
"\n\n".
This function is compulsory as implementing the high-speed programmed
HTTP server using VCE.
A judgment whether the actual HTTP method is appropriate or
not is left to an application, because separation of a header and
data body is done based only on a blank delimiter of HTTP.
</td></tr>
<tr><th>See also</th><td>
<a href="#hextext">hextext</a>
</td></tr>
</table><br><br>
<a name="vce_httptext_get_header_info"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_httptext_get_header_info</th></tr>
<tr><th>Summary</th><td>Extract value from whole HTTP request header</td></tr>
<tr><th>Category</th><td>text</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_httptext_get_header_info( char *h, int hlen , char *item , char *out, int outlen )</b></td>
<tr><th>arg 1</Th><td>char *h</td></tr>
<tr><th></th><td>Pointer to a data buffer which contains whole HTTP header.
</td></tr>
<tr><th>arg 2</Th><td>int hlen</td></tr>
<tr><th></th><td>Length of whole HTTP header.
</td></tr>
<tr><th>arg 3</Th><td>char *item</td></tr>
<tr><th></th><td>Name of request header to get. For example, "Content-Length".
</td></tr>
<tr><th>arg 4</Th><td>char *out</td></tr>
<tr><th></th><td>Top address of output buffer. Delimiter newline character will not
included in output buffer.
</td></tr>
<tr><th>arg 5</Th><td>int outlen</td></tr>
<tr><th></th><td>Length of output data in bytes.
</td></tr>
<tr><th>Return value</th><td>Returns number of copied characters.
Returns zero and empty string if no entry is found.
</td></tr>
<tr><th>Description</th><td>Return length of copied string.
When an item is not found, return an empty character string,
and the return value is 0.
</td></tr>
</table><br><br>
<a name="vce_if_included_in_array"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_if_included_in_array</th></tr>
<tr><th>Summary</th><td>Test if given element is correctly included in a VCE array.</td></tr>
<tr><th>Category</th><td>array</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_if_included_in_array( int index, void *p )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Array descriptor to specify VCE's array.
</td></tr>
<tr><th>arg 2</Th><td>void *p</td></tr>
<tr><th></th><td>Pointer to an element in the array.
</td></tr>
<tr><th>Return value</th><td>Return 1, if it is included in the specified array.
If not,return 0. In case of invalid argument, return error code.
</td></tr>
<tr><th>Description</th><td>This checks if the element designated by void *p is included
in the array.
To check if array elements are included in an array properly,
subtract the head address from p first, then divide the
difference by the size of array elements to obtain the remainder.
When the remainder is not 0, the elements are not
arranged properly.
Even if the remainder is 0, as the quotient is not in the range from 0
to the number of array
elements negative 1, the elements are arranged outside the range-an error.
</td></tr>
<tr><th>See also</th><td>
<a href="#ARRAY_SCAN">ARRAY_SCAN</a>
<a href="#vce_get_array_object_index">vce_get_array_object_index</a>
<a href="#vce_init_array">vce_init_array</a>
</td></tr>
</table><br><br>
<a name="vce_init_array"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_init_array</th></tr>
<tr><th>Summary</th><td>Initialize a new VCE array.</td></tr>
<tr><th>Category</th><td>array</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_init_array ( size_t size , int num , char *nm )</b></td>
<tr><th>arg 1</Th><td>size_t size</td></tr>
<tr><th></th><td>Size of each elements in the array. Byte count.
</td></tr>
<tr><th>arg 2</Th><td>int num</td></tr>
<tr><th></th><td>Number of lements of the array.
</td></tr>
<tr><th>arg 3</Th><td>char *nm</td></tr>
<tr><th></th><td>Name of the array. This name will help your debugging
because VCE will print out this name when any problem is occured.
</td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td>This zero-clears an array through allocating necessary memory for the array,
and initializes the in-use list at the same time.
VCE arrays are implemented for realizing high-speed array initialization,
searching freelist and releasing buffer through implementing the empty list.
vce_init_array consumes memory roughly estimated as (element size plus 20)
times (number of elements) in bytes.
The int value returned by vce_init_array is like UNIX files' file descriptor,
that is used for later access to arrays.
The VCE array is used as a basic routine of VCE processing.
vce_init_array function uses the MALLOC function internally.
</td></tr>
<tr><th>See also</th><td>
<a href="#ARRAY_SCAN">ARRAY_SCAN</a>
<a href="#MALLOC">MALLOC</a>
<a href="#vce_alloc_array_object">vce_alloc_array_object</a>
<a href="#vce_end_array">vce_end_array</a>
<a href="#vce_free_array_object">vce_free_array_object</a>
<a href="#vce_free_array_object_all">vce_free_array_object_all</a>
</td></tr>
</table><br><br>
<a name="vce_init_int2_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_init_int2_search</th></tr>
<tr><th>Summary</th><td>Initialize a search engine which uses 2 integers as search key</td></tr>
<tr><th>Category</th><td>search</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_init_int2_search( int hashtbl_size , int ent_num , char *sname )</b></td>
<tr><th>arg 1</Th><td>int hashtbl_size</td></tr>
<tr><th></th><td>Size of search hash table. Please have a look at vce_init_int_search
for size hints.
</td></tr>
<tr><th>arg 2</Th><td>int ent_num</td></tr>
<tr><th></th><td>Max number of registered entries in this search engine.
</td></tr>
<tr><th>arg 3</Th><td>char *sname</td></tr>
<tr><th></th><td>Name of this search engine.
</td></tr>
<tr><th>Return value</th><td>Search descriptor, which will be used when calling search engine routines.
You specify search engine by this descriptor.
Returns larger than or equal to zero if successful, otherwise
returns minus error indicator value.
</td></tr>
<tr><th>Description</th><td>This initializes a search engine with a couple of 2 integers.
2-integer search is mainly used for purposes such as searching
for a pointer to client structure with a search key of
the Internet client address
(IPv4,32bit address + 16bit port).
Especially, vce_init_int2_search executes such search at high speed.
This is used inside packet vectorizer routines.
Please refer to integer search engine for detail explanation.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_delete_int2_search">vce_delete_int2_search</a>
<a href="#vce_get_int2_search">vce_get_int2_search</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_update_int2_search">vce_update_int2_search</a>
</td></tr>
</table><br><br>
<a name="vce_init_int4_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_init_int4_search</th></tr>
<tr><th>Summary</th><td>Initialize a search engine which uses 4 integers as search key</td></tr>
<tr><th>Category</th><td>search</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_init_int4_search( int hashtbl_size , int ent_num , char *sname )</b></td>
<tr><th>arg 1</Th><td>int hashtbl_size</td></tr>
<tr><th></th><td>Size of search hash table. Please have a look at vce_init_int_search
for size hints.
</td></tr>
<tr><th>arg 2</Th><td>int ent_num</td></tr>
<tr><th></th><td>Max number of registered entries in this search engine.
</td></tr>
<tr><th>arg 3</Th><td>char *sname</td></tr>
<tr><th></th><td>Name of this search engine.
</td></tr>
<tr><th>Return value</th><td>Search descriptor, which will be used when calling search engine routines.
You specify search engine by this descriptor.
Returns larger than or equal to zero if successful, otherwise
returns minus error indicator value.
</td></tr>
<tr><th>Description</th><td>This initializes a search engine with a couple of 4 integers.
4-integer search is mainly used for purposes such as searching
for a pointer to client structure with a search key of
the Internet client address
(IPv4,32bit address + 16bit port).
Especially, vce_init_int4_search executes such search at high speed.
This is used inside packet vectorizer routines.
Please refer to integer search engine for detail explanation.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_delete_int4_search">vce_delete_int4_search</a>
<a href="#vce_get_int4_search">vce_get_int4_search</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_update_int4_search">vce_update_int4_search</a>
</td></tr>
</table><br><br>
<a name="vce_init_int_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_init_int_search</th></tr>
<tr><th>Summary</th><td>Initialize a search engine which uses integer values as a search key</td></tr>
<tr><th>Category</th><td>search</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_init_int_search( int hashtbl_size , int ent_num , char *sname )</b></td>
<tr><th>arg 1</Th><td>int hashtbl_size</td></tr>
<tr><th></th><td>Size of hash table.
You can get better searching performance if you choose
larger size at least from 10 to 30 percent of number of pointers.
For example, if you have 10K pointers maximum, you will set this size
to 1K or more.
Although it is preferable to make it bigger as possible,
but great amount of memory is required to make it larger.
This is a simple trade-off.
In case of 1 integer engine,
12 bytes are required for 1 hash table size.
And in case of 2 integer search engine,
16 bytes are required for 1 hash,
And string search engine will require 44 bytes in the same way.
</td></tr>
<tr><th>arg 2</Th><td>int ent_num</td></tr>
<tr><th></th><td>Number of registered elements contained in this search engine.
</td></tr>
<tr><th>arg 3</Th><td>char *sname</td></tr>
<tr><th></th><td>Name of this search engine.
</td></tr>
<tr><th>Return value</th><td>integer index to specify search engine.
It is used as the first argument at the time of future reference
like UNIX's file descriptor.
This value is called "search descriptor" in VCE.
Return negative error occurs, in case of error.
</td></tr>
<tr><th>Description</th><td>This returns search descriptor for initializing search engine
inside VCE and accessing it.
VCE's search engine implements searching facility
using hash table allocated statically within memory.
Information to be searched is stored in an array of a structure in advance,
and is used for finding elements of such array.<BR>

Therefore, you will update a pair of "search key" and "pointer to a value"
first of all, then finds such pointer through
designating search key after registration.
<BR>

This search engine can only be used for very limited purposes.
The best suited situation of using the search category
functions is that high-speed search using a simple search key from up
to tens of thousands of information,
for external DBMS would probably be prepared in order to perform
full-fledged saving and searching for vast amount of information.<BR>

In addition, it takes about 1ms per each search when an external
DBMS is used, whereas it only takes around 1us using the
functions including vce_init_int_search.
This difference in speed should be utilized aptly by your decision.
vce_init_int_search uses VCE arrays inside.
The maximum number of search engines can be tuned by vce_initialize_limited
function, by default 256.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_delete_int_search">vce_delete_int_search</a>
<a href="#vce_get_int_search">vce_get_int_search</a>
<a href="#vce_init_int2_search">vce_init_int2_search</a>
<a href="#vce_init_string_search">vce_init_string_search</a>
<a href="#vce_initialize_limited">vce_initialize_limited</a>
</td></tr>
</table><br><br>
<a name="vce_init_limit_t"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_init_limit_t</th></tr>
<tr><th>Summary</th><td>Initialize vce_limit_t structure with default value.</td></tr>
<tr><th>Category</th><td>core</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other.darwin</td></tr>
<tr><th>Prototype</th><td><b> void vce_init_limit_t( vce_limit_t *t )</b></td>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>It's always correct way to use vce_init_limit_t function when
you use vce_initialize_limited function.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_initialize_limited">vce_initialize_limited</a>
</td></tr>
</table><br><br>
<a name="vce_init_string_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_init_string_search</th></tr>
<tr><th>Summary</th><td>Initialize string search engine</td></tr>
<tr><th>Category</th><td>search</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_init_string_search( int hashtbl_size , int ent_num , char *sname )</b></td>
<tr><th>arg 1</Th><td>int hashtbl_size</td></tr>
<tr><th></th><td>Size of search hash table.
</td></tr>
<tr><th>arg 2</Th><td>int ent_num</td></tr>
<tr><th></th><td>Number of registered elements contained in this search engine.
</td></tr>
<tr><th>arg 3</Th><td>char *sname</td></tr>
<tr><th></th><td>Name of this search engine.
</td></tr>
<tr><th>Return value</th><td>Integer search descriptor
</td></tr>
<tr><th>Description</th><td>This initializes search engine having a string as search key.
This search engine is designed specially for small and quick
searching, so if you want to handle vast amount of information,
you would better use external RDMBS and like.
Because this string search engine has its focus on small and quick
searching, it will accept up to 32 byte string as its argument.
Please refer to descriptions of vce_init_int_search for
total search engine architecture.<BR>
vce_init_string_search will initialize string search engine,
and vce_update_string_search will register key and value into it,
and vce_get_string_search will find key and value pair.
finally vce_delete_string_search will remove key and value pair
from the search engine.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_delete_string_search">vce_delete_string_search</a>
<a href="#vce_get_string_search">vce_get_string_search</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_update_string_search">vce_update_string_search</a>
</td></tr>
</table><br><br>
<a name="vce_init_vstring_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_init_vstring_search</th></tr>
<tr><th>Summary</th><td>Initialize a search engine that uses an arbitrary length string</td></tr>
<tr><th>Category</th><td>search</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_init_vstring_search( int hashtbl_size, int ent_num, int key_len, char *sname )</b></td>
<tr><th>arg 1</Th><td>int hashtbl_size</td></tr>
<tr><th></th><td>Size of search hash table.
</td></tr>
<tr><th>arg 2</Th><td>int ent_num</td></tr>
<tr><th></th><td>Max number of registered entries in this search engine.
</td></tr>
<tr><th>arg 3</Th><td>key_len</td></tr>
<tr><th></th><td>Max length of search key string.
</td></tr>
<tr><th>arg 4</Th><td>char *sname</td></tr>
<tr><th></th><td>Name of this search engine.
</td></tr>
<tr><th>Return value</th><td>Returns larger than or equal to zero if successful,
otherwise returns minus error indicator value.
</td></tr>
<tr><th>Description</th><td>This initializes a search engine having string as search key.
Unlike vce_init_string_search, length of string can be designated
as an arbitrary value by key_len.
In case length of a character string is the same as
it of vce_init_string_search,
speed is the same. In other words, you can completely substitute it
by this.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_cleanup_search_engine">vce_cleanup_search_engine</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_init_string_search">vce_init_string_search</a>
</td></tr>
</table><br><br>
<a name="vce_initialize"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_initialize</th></tr>
<tr><th>Summary</th><td>Initialize VCE.</td></tr>
<tr><th>Category</th><td>core</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_initialize( void )</b></td>
<tr><th>Return value</th><td>Returns 0 if successful. Otherwise minus error indicator (see vce.h).
</td></tr>
<tr><th>Description</th><td>You have to call this function before calling VCE functions.
Required memory will be allocated inside this function.
This initializes Winsock in Windows environment.
For UNIX, it blocks SIGPIPE.
With regard to VCE for PlayStation(R)2 ,
invoke this function before initialization of a network by an application,
then invoke ce_set_socket_library_ok(1) at the point the socket library
is initialized. (refer to samples)
</td></tr>
<tr><th>Example</th><td>// In case of PS2  No socket library is provided by operating system
int main()
{
    vce_initialize();

    // load inet libraries
    // load device dependent modules ..
    // Dialing ...

    while( wait_for_socket_init() );
 
    vce_set_socket_library_ok(1);

    t = vce_tcpcontext_create( ... );
    while(1){
        vce_heartbeat();
    }
}
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_finalize">vce_finalize</a>
<a href="#vce_set_socket_library_ok">vce_set_socket_library_ok</a>
</td></tr>
</table><br><br>
<a name="vce_initialize_limited"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_initialize_limited</th></tr>
<tr><th>Summary</th><td>Initialize VCE with limited memory configuration</td></tr>
<tr><th>Category</th><td>core</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_initialize_limited( vce_limit_t *lim )</b></td>
<tr><th>arg 1</Th><td>vce_limit_t *lim</td></tr>
<tr><th></th><td>Pointer to vce_limit_t containing limit information.
</td></tr>
<tr><th>Return value</th><td>Returns 0 if successful. Otherwise minus error indicator value (vce.h).
</td></tr>
<tr><th>Description</th><td>This is the same as vce_initialize,
though it allows tuning of memory consumption using
vce_limit_t structure.
You have to use vce_init_limit_t function to initialize
vce_limit_t structure with default values before passing it to
vce_initialize_limited function.
In particular, this is used in some situation where ultimate
tuning of memory capacity is demanded.
<PRE>
int max_tcpcontext     Max number of tcpcontext_t
int max_taskgroup      Max number of taskgroup_t
int max_conn           Max number of entire conn_t
int max_search  Max number of the entire search engine
int max_array   Max number of VCE arrays
int sendbuf_work_size  Size of work memory for sending
int recvbuf_work_size  Size of work memory for receiving
</pre>

They can be set with values 0 or larger.
Set -1 to use default value.
<BR>
Please note that you will have to pay attention to minimum
value of max_array. That is because VCE uses array engine inside it
<ul>
<LI>Always 2 arrays are occupied by VCE itself for conn,task
<LI>tcpcontext uses 4 or 5 per 1
<LI>switchcontext uses 3 per 1
<LI>monitoring client uses 2 per 1
<LI>monitoring server uses 5 (4 of them are for tcpcontext ) per 1
<LI>search engine uses 1 per 1
<LI>taskgroup uses 1 per 1
</ul>
These VCE services will return VCE_EARRAY if array is not enough.
So, you may increase max_array if you meet VCE_EARRAY error code.
In addition, when you increase max_array for 1,
it requires 72 bytes of memory accordingly.
In Linux/win32 environment, max_array defaults to 256,
but in PS2 envoronment, it defaults to 32.
<BR>
<BR>
This function can also be used for the purpose of enlarging the
maximum default value, as well as saving memory
for larger scale applications.
A typical case may change default maximum number of simultaneous
connections of 1000 to larger value.
This function can be used for such purpose, provided that,
attention must be paid to keeping the maximum number of connections
below 1024 by the kernel settings or the limit of the
user process space among most of linux/freeBSD OS's.
To exceed this limit, in most of the cases,
modification of the kernel settings or recompilation is required.
Please look at <a href="linuxtune.html>here</a> for detail tuning of Linux.
</td></tr>
<tr><th>Example</th><td><pre>
int main(){
    // Don't use shared memory and search engine for game clients
    vce_limit_t lim;
    lim.max_tcpcontext = 1;
    lim.max_taskgroup = -1;
    lim.max_conn = 1;
    lim.max_search = 0;
    lim.max_array = 0;
    lim.sendbuf_work_size = -1;
    lim.recvbuf_work_size = -1;
    vce_initialize_limited( &lim );
    vce_finalize();
}
</pre>
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_init_limit_t">vce_init_limit_t</a>
<a href="#vce_initialize">vce_initialize</a>
</td></tr>
</table><br><br>
<a name="vce_istore_init"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_istore_init</th></tr>
<tr><th>Summary</th><td>Save data which has identical integer key into a file</td></tr>
<tr><th>Category</th><td>istore</td></tr>
<tr><th>Compatibility</th><td>linux</td></tr>
<tr><th>Prototype</th><td><b>int vce_istore_init( istore *is, char *dname , int dircheck )</b></td>
<tr><th>arg 1</Th><td>istore *is</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 2</Th><td>char *dname</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 3</Th><td>int dircheck</td></tr>
<tr><th></th><td></td></tr>
<tr><th>Return value</th><td>Returns zero if successful, otherwise minus error code.
</td></tr>
<tr><th>Description</th><td>This function is obsolete.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_istore_load">vce_istore_load</a>
<a href="#vce_istore_save">vce_istore_save</a>
</td></tr>
</table><br><br>
<a name="vce_istore_load"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_istore_load</th></tr>
<tr><th>Summary</th><td>An istore function to read data from file</td></tr>
<tr><th>Category</th><td>istore</td></tr>
<tr><th>Compatibility</th><td>linux</td></tr>
<tr><th>Prototype</th><td><b>int vce_istore_load( istore *is, unsigned int k, char *buf, int len )</b></td>
<tr><th>arg 1</Th><td>istore *is</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 2</Th><td>unsigned int k</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 3</Th><td>char *buf</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 4</Th><td>int len</td></tr>
<tr><th></th><td></td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_istore_init">vce_istore_init</a>
<a href="#vce_istore_save">vce_istore_save</a>
</td></tr>
</table><br><br>
<a name="vce_istore_save"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_istore_save</th></tr>
<tr><th>Summary</th><td>An istore function to save data to file.</td></tr>
<tr><th>Category</th><td>istore</td></tr>
<tr><th>Compatibility</th><td>linux</td></tr>
<tr><th>Prototype</th><td><b>int vce_istore_save( istore *is, unsigned int k, char *buf, int len )</b></td>
<tr><th>arg 1</Th><td>istore *is</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 2</Th><td>unsigned int k</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 3</Th><td>char *buf</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 4</Th><td>int len</td></tr>
<tr><th></th><td></td></tr>
<tr><th>Return value</th><td>Returns 0 if success, otherwise minus error code.
</td></tr>
<tr><th>Description</th><td>This function is obsolete.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_istore_init">vce_istore_init</a>
<a href="#vce_istore_load">vce_istore_load</a>
</td></tr>
</table><br><br>
<a name="vce_iterate_int2_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_iterate_int2_search</th></tr>
<tr><th>Summary</th><td>Process all entries maintained by a 2-integer search engine</td></tr>
<tr><th>Category</th><td>search</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_iterate_int2_search( int index, int (*callback)(void*))</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Search descriptor.
</td></tr>
<tr><th>arg 2</Th><td>int (*callback(void*))</td></tr>
<tr><th></th><td>A callback function to define processing details.
Pointer to an entry registered in search engine is assigned to
the first argument of the callback function.
When the callback function returns negative value,
this function will return it as is, and terminates halfway.
</td></tr>
<tr><th>Return value</th><td>Integeger search descriptor
</td></tr>
<tr><th>Description</th><td>In case you want to process every entry stored in a search engine,
this function will call a callback function against all of them,
and you can do any processing inside the callback function.
You may be able to imagine script language Ruby's iterator.
Please note that you don't use "update" and "delete" control
in the callback processing function.
For instance, when functions such as vce_delete_int2_search is executed,
a list structure administrated by the search engine
will be changed in some invocation sequences.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_init_int2_search">vce_init_int2_search</a>
</td></tr>
</table><br><br>
<a name="vce_iterate_int4_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_iterate_int4_search</th></tr>
<tr><th>Summary</th><td>Process all entries maintained by a 4-integer search engine</td></tr>
<tr><th>Category</th><td>search</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_iterate_int4_search( int index, int (*callback)(void*))</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Search descriptor.
</td></tr>
<tr><th>arg 2</Th><td>int (*callback(void*))</td></tr>
<tr><th></th><td>A callback function to define processing details.
Pointer to an entry registered in search engine is assigned to
the first argument of the callback function.
When the callback function returns negative value,
this function will return it as is, and terminates halfway.
</td></tr>
<tr><th>Return value</th><td>Integeger search descriptor
</td></tr>
<tr><th>Description</th><td>In case you want to process every entry stored in a search engine,
this function will call a callback function against all of them,
and you can do any processing inside the callback function.
You may be able to imagine script language Ruby's iterator.
Please note that you don't use "update" and "delete" control
in the callback processing function.
For instance, when functions such as vce_delete_int4_search is executed,
a list structure administrated by the search engine
will be changed in some invocation sequences.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_init_int4_search">vce_init_int4_search</a>
</td></tr>
</table><br><br>
<a name="vce_limit_clear"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_limit_clear</th></tr>
<tr><th>Summary</th><td>Initialize vce_limit_t structure (Clear with default value -1 )</td></tr>
<tr><th>Category</th><td>core</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_limit_clear( vce_limit_t *t )</b></td>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>This function initializes all member of vce_limit_t structre  with
default value -1. By calling vce_initialize_limited function with
vce_limit_t structure initialized by vce_limit_clear,
vce uses default settings in every configuration.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_initialize_limited">vce_initialize_limited</a>
</td></tr>
</table><br><br>
<a name="vce_log_add_monitor_command"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_log_add_monitor_command</th></tr>
<tr><th>Summary</th><td></td></tr>
<tr><th>Category</th><td>log</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_log_add_monitor_command()</b></td>
<tr><th>arg 1</Th><td>int type</td></tr>
<tr><th></th><td>a log type
</td></tr>
<tr><th>arg 2</Th><td>char *id</td></tr>
<tr><th></th><td>an ID
</td></tr>
<tr><th>arg 3</Th><td>char *char_name</td></tr>
<tr><th></th><td>a character name
</td></tr>
<tr><th>arg 4</Th><td>char *format</td></tr>
<tr><th></th><td>a format string.
</td></tr>
<tr><th>Return value</th><td>Returns 0 if successful, otherwise minus error indicator value.
</td></tr>
<tr><th>Description</th><td></td></tr>
</table><br><br>
<a name="vce_log_add_type"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_log_add_type</th></tr>
<tr><th>Summary</th><td>add log type</td></tr>
<tr><th>Category</th><td>log</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_log_add_type( int type, char *tag )</b></td>
<tr><th>arg 1</Th><td>int type</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 2</Th><td>char *tag</td></tr>
<tr><th></th><td></td></tr>
<tr><th>Return value</th><td>Returns 0 if successful, otherwise minus error indicator value.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="# vce_log_set_type_mask_by_name"> vce_log_set_type_mask_by_name</a>
<a href="#vce_log_set_type_mask">vce_log_set_type_mask</a>
</td></tr>
</table><br><br>
<a name="vce_log_get_types"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_log_get_types</th></tr>
<tr><th>Summary</th><td>PENDING</td></tr>
<tr><th>Category</th><td>log</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_log_get_types( char *buf, int buf_len )</b></td>
<tr><th>arg 1</Th><td>char *buf</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>arg 2</Th><td>int buf_len</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_log_add_type">vce_log_add_type</a>
<a href="#vce_log_set_type_mask">vce_log_set_type_mask</a>
<a href="#vce_log_set_type_mask_by_name">vce_log_set_type_mask_by_name</a>
</td></tr>
</table><br><br>
<a name="vce_log_gettime_long"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_log_gettime_long</th></tr>
<tr><th>Summary</th><td>PENDING</td></tr>
<tr><th>Category</th><td>log</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_log_gettime_long( char *buf, int len )</b></td>
<tr><th>arg 1</Th><td>char *buf</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_log_gettime_normal">vce_log_gettime_normal</a>
<a href="#vce_log_gettime_short">vce_log_gettime_short</a>
</td></tr>
</table><br><br>
<a name="vce_log_gettime_normal"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_log_gettime_normal</th></tr>
<tr><th>Summary</th><td>PENDING</td></tr>
<tr><th>Category</th><td>log</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_log_gettime_normal( char *buf, int len )</b></td>
<tr><th>arg 1</Th><td>char *buf</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_log_gettime_long">vce_log_gettime_long</a>
<a href="#vce_log_gettime_short">vce_log_gettime_short</a>
</td></tr>
</table><br><br>
<a name="vce_log_gettime_short"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_log_gettime_short</th></tr>
<tr><th>Summary</th><td>PENDING</td></tr>
<tr><th>Category</th><td>log</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_log_gettime_short( char *buf, int len )</b></td>
<tr><th>arg 1</Th><td>char *buf</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_log_gettime_long">vce_log_gettime_long</a>
<a href="#vce_log_gettime_normal">vce_log_gettime_normal</a>
</td></tr>
</table><br><br>
<a name="vce_log_init"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_log_init</th></tr>
<tr><th>Summary</th><td></td></tr>
<tr><th>Category</th><td>log</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_log_init( printf_func_t printf_func )</b></td>
<tr><th>arg 1</Th><td>printf_func_t printf_func</td></tr>
<tr><th></th><td></td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
</table><br><br>
<a name="vce_log_parse"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_log_parse</th></tr>
<tr><th>Summary</th><td></td></tr>
<tr><th>Category</th><td>log</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_log_parse( const char *line, int line_len, char *date, int date_len, char *type, int type_len, char *id, int id_len, char *name, int name_len, char *text, int text_len )</b></td>
<tr><th>arg 1</Th><td>const char *line</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>arg 2</Th><td>int line_len</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>arg 3</Th><td>char *date</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>arg 4</Th><td>int date_len</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>arg 5</Th><td>char *type</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>arg 6</Th><td>int type_len</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>arg 7</Th><td>char *id</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>arg 8</Th><td>int id_len</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>arg 9</Th><td>char *name</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>arg 10</Th><td>int name_len</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>arg 11</Th><td>char *text</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>arg 12</Th><td>int text_len</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
</table><br><br>
<a name="vce_log_print"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_log_print</th></tr>
<tr><th>Summary</th><td></td></tr>
<tr><th>Category</th><td>log</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_log_print( int type, char *id, char *char_name, char *format, ... )</b></td>
<tr><th>arg 1</Th><td>int type</td></tr>
<tr><th></th><td>A log type
</td></tr>
<tr><th>arg 2</Th><td>char *id</td></tr>
<tr><th></th><td>An ID
</td></tr>
<tr><th>arg 3</Th><td>char *char_name</td></tr>
<tr><th></th><td>A character name
</td></tr>
<tr><th>arg 4</Th><td>char *format</td></tr>
<tr><th></th><td>A format string
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_log_vprint">vce_log_vprint</a>
</td></tr>
</table><br><br>
<a name="vce_log_set_gettime_func"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_log_set_gettime_func</th></tr>
<tr><th>Summary</th><td>PENDING</td></tr>
<tr><th>Category</th><td>log</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_log_set_gettime_func( gettime_func_t gettime )</b></td>
<tr><th>arg 1</Th><td>gettime_func_t gettime</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_log_gettime_long">vce_log_gettime_long</a>
<a href="#vce_log_gettime_normal">vce_log_gettime_normal</a>
<a href="#vce_log_gettime_short">vce_log_gettime_short</a>
</td></tr>
</table><br><br>
<a name="vce_log_set_type_mask"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_log_set_type_mask</th></tr>
<tr><th>Summary</th><td></td></tr>
<tr><th>Category</th><td>log</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_log_set_type_mask( unsigned int mask )</b></td>
<tr><th>arg 1</Th><td>unsigned int mask</td></tr>
<tr><th></th><td>a log type to be enabled.
</td></tr>
<tr><th>Return value</th><td>None.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="# vce_log_set_type_mask_by_name"> vce_log_set_type_mask_by_name</a>
<a href="#vce_log_add_type">vce_log_add_type</a>
</td></tr>
</table><br><br>
<a name="vce_log_set_type_mask_by_name"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_log_set_type_mask_by_name</th></tr>
<tr><th>Summary</th><td></td></tr>
<tr><th>Category</th><td>log</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_log_set_type_mask_by_name( char *name, int on_off )</b></td>
<tr><th>arg 1</Th><td>char *name</td></tr>
<tr><th></th><td>a name of log type to be enabled.
</td></tr>
<tr><th>arg 2</Th><td>int on_off</td></tr>
<tr><th></th><td>on/off
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="# vce_log_set_type_mask"> vce_log_set_type_mask</a>
<a href="#vce_log_add_type">vce_log_add_type</a>
</td></tr>
</table><br><br>
<a name="vce_log_vprint"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_log_vprint</th></tr>
<tr><th>Summary</th><td></td></tr>
<tr><th>Category</th><td>log</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_log_vprint( int type, char *id, char *char_name, char *format, va_list va )</b></td>
<tr><th>arg 1</Th><td>int type</td></tr>
<tr><th></th><td>log type
</td></tr>
<tr><th>arg 2</Th><td>char *id</td></tr>
<tr><th></th><td>an ID
</td></tr>
<tr><th>arg 3</Th><td>char *char_name</td></tr>
<tr><th></th><td>a character name
</td></tr>
<tr><th>arg 4</Th><td>char *format</td></tr>
<tr><th></th><td>a format string.
</td></tr>
<tr><th>arg 5</Th><td>va_list va</td></tr>
<tr><th></th><td>a parameter list
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_log_print">vce_log_print</a>
</td></tr>
</table><br><br>
<a name="vce_logwriter_connect"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_logwriter_connect</th></tr>
<tr><th>Summary</th><td></td></tr>
<tr><th>Category</th><td>logwriter</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>logwriter_t *vce_logwriter_connect( char *addr, int port, int id )</b></td>
<tr><th>arg 1</Th><td>char *addr</td></tr>
<tr><th></th><td>an address to connect.
</td></tr>
<tr><th>arg 2</Th><td>int port</td></tr>
<tr><th></th><td>a port number to connect.
</td></tr>
<tr><th>arg 3</Th><td>int id</td></tr>
<tr><th></th><td>An ID to identify. Normally a service port of program.
</td></tr>
<tr><th>Return value</th><td>Returns created logwriter. Returns NULL if fail.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="# vce_logwriter_poll"> vce_logwriter_poll</a>
<a href="#vce_logwriter_init">vce_logwriter_init</a>
</td></tr>
</table><br><br>
<a name="vce_logwriter_init"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_logwriter_init</th></tr>
<tr><th>Summary</th><td></td></tr>
<tr><th>Category</th><td>logwriter</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_logwriter_init( int num )</b></td>
<tr><th>arg 1</Th><td>int num</td></tr>
<tr><th></th><td>a number of log writer.
</td></tr>
<tr><th>Return value</th><td>Return 0 if successful, otherwise minus error indicator value.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_logwriter_connect">vce_logwriter_connect</a>
</td></tr>
</table><br><br>
<a name="vce_logwriter_poll"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_logwriter_poll</th></tr>
<tr><th>Summary</th><td></td></tr>
<tr><th>Category</th><td>logwriter</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_logwriter_poll</b></td>
<tr><th>Return value</th><td>Returns 0 if sccessful, otherwise minus error indicator value.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_logwriter_connect">vce_logwriter_connect</a>
</td></tr>
</table><br><br>
<a name="vce_logwriter_printf"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_logwriter_printf</th></tr>
<tr><th>Summary</th><td></td></tr>
<tr><th>Category</th><td>logwriter</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_logwriter_printf( logwriter_t *w, const char *format, ... )</b></td>
<tr><th>arg 1</Th><td>logwriter_t *w</td></tr>
<tr><th></th><td>A writing logwriter.
</td></tr>
<tr><th>arg 2</Th><td>char *format</td></tr>
<tr><th></th><td>A format string.
</td></tr>
<tr><th>Return value</th><td>Returns 0 if sccessful, otherwise minus error indicator value.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_logwriter_poll">vce_logwriter_poll</a>
<a href="#vce_logwriter_vprintf">vce_logwriter_vprintf</a>
</td></tr>
</table><br><br>
<a name="vce_logwriter_vprintf"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_logwriter_vprintf</th></tr>
<tr><th>Summary</th><td></td></tr>
<tr><th>Category</th><td>logwriter</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_logwriter_vprintf( logwriter_t *w, const char *format, va_list va )</b></td>
<tr><th>arg 1</Th><td>logwriter_t *w</td></tr>
<tr><th></th><td>A writing logwriter.
</td></tr>
<tr><th>arg 2</Th><td>char *format</td></tr>
<tr><th></th><td>A format string.
</td></tr>
<tr><th>arg 3</Th><td>va_list va</td></tr>
<tr><th></th><td>A parameter list
</td></tr>
<tr><th>Return value</th><td>Returns 0 if sccessful, otherwise minus error indicator value.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_logwriter_poll">vce_logwriter_poll</a>
<a href="#vce_logwriter_printf">vce_logwriter_printf</a>
</td></tr>
</table><br><br>
<a name="vce_mainloop"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_mainloop</th></tr>
<tr><th>Summary</th><td></td></tr>
<tr><th>Category</th><td>core</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_mainloop(void)</b></td>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>By calling this function, CPU will be occupied by VCE.
This function will never return.
When vce_set_mainloop_callback function defines a callback function,
the defined function will be permanently called from
within this function.
If the function returns the value other than 0,
vce_mainloop returns the value sent back from that function
and will terminate.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_set_mainloop_callback">vce_set_mainloop_callback</a>
</td></tr>
</table><br><br>
<a name="vce_make_binary_array_from_hex"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_make_binary_array_from_hex</th></tr>
<tr><th>Summary</th><td>Convert hex text into binary data array.</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_make_binary_array_from_hex( char *out, int outlen, const char *hex )</b></td>
<tr><th>arg 1</Th><td>char *out</td></tr>
<tr><th></th><td>Top address of destination buffer. Binary data will be filled
to this buffer.
</td></tr>
<tr><th>arg 2</Th><td>int outlen</td></tr>
<tr><th></th><td>Length of input string.
If this is not even number, it adds 0 value at the end of input string,
and keep processesing going.
</td></tr>
<tr><th>arg 3</Th><td>char *hex</td></tr>
<tr><th></th><td>Input data string.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>This creates an array of binary data from a string
such as "788ab0d8ce8df6".
Since one byte is created by two letters,
when data of an odd-numbered characters is designated,
it generates binary data having simply added 0 at the end,
then outputs.
In general, designate even-numbered characters for outputting.
An inverse function is vce_make_hex_from_binary_array
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_make_hex_from_binary_array">vce_make_hex_from_binary_array</a>
</td></tr>
</table><br><br>
<a name="vce_make_binary_array_from_line"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_make_binary_array_from_line</th></tr>
<tr><th>Summary</th><td>Convert 1 line of ASCII text into a binary data array.</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_make_binary_array_from_line( const char *line, int linelen, char *out, int *outlen, int *uselen )</b></td>
<tr><th>arg 1</Th><td>char *line</td></tr>
<tr><th></th><td>Top address of input line
</td></tr>
<tr><th>arg 2</Th><td>int linelen</td></tr>
<tr><th></th><td>Length of input line
</td></tr>
<tr><th>arg 3</Th><td>char *out</td></tr>
<tr><th></th><td>Output buffer
</td></tr>
<tr><th>arg 4</Th><td>int *outlen</td></tr>
<tr><th></th><td>Length of output buffer. This is value-result parameter.
Firstly it have to contain max length of output buffer,
and then this function fills this parameter with
how many bytes are used actually.
</td></tr>
<tr><th>arg 5</Th><td>int *uselen</td></tr>
<tr><th></th><td>Returns how many bytes actually read from input text.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>This creates a binary array from a text line.
You can specify a text line in some loose format,
for example it can be terminated by "\r\n" or "\n".
When successful, it returns actual embedded length of the array
stored in "outlen", and actual read length of input
line is stored in "uselen" argument.
</td></tr>
</table><br><br>
<a name="vce_make_hex_from_binary_array"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_make_hex_from_binary_array</th></tr>
<tr><th>Summary</th><td>Make a hex string from a binary array</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_make_hex_from_binary_array( char *out, int outlen, const char *buf,int len, int folding)</b></td>
<tr><th>arg 1</Th><td>char *out</td></tr>
<tr><th></th><td>Top address of output string buffer.
</td></tr>
<tr><th>arg 2</Th><td>int outlen</td></tr>
<tr><th></th><td>Length of output string buffer.
</td></tr>
<tr><th>arg 3</Th><td>char *buf</td></tr>
<tr><th></th><td>Top address of input binary data.
</td></tr>
<tr><th>arg 4</Th><td>int len</td></tr>
<tr><th></th><td>Length of input binary data.
</td></tr>
<tr><th>arg 5</Th><td>int folding</td></tr>
<tr><th></th><td>A flag to decide whether folding every 32 characters
(16 bytes of input) or net. Set 1 for folding, otherwise 0.
In case of folding=0, output string will become a single line without
any carriage return, even though the input length comes to be
particularly long. When fold=1, a "\n" code is added
to the end of output string according to the UNIX way.
</td></tr>
<tr><th>Return value</th><td>Returns VCE_EFULL if output buffer is filled up.
Otherwise returns how many bytes are filled.
(null terminator character is not included)
</td></tr>
<tr><th>Description</th><td>Since one byte becomes two characters after conversion,
successful results will always lead the output to have
twice as many characters as input characters do.
For instance, "abc" will become "616263". This function is
used by vce_make_hex_text_from_buffer internally.
</td></tr>
<tr><th>See also</th><td>
<a href="#hextext">hextext</a>
<a href="#vce_make_hex_text_from_buffer">vce_make_hex_text_from_buffer</a>
</td></tr>
</table><br><br>
<a name="vce_make_hex_text_from_buffer"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_make_hex_text_from_buffer</th></tr>
<tr><th>Summary</th><td>Make hextext format ASCII text from a binary data array.</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_make_hex_text_from_buffer( const char *buf , int len , char *out , int outlen )</b></td>
<tr><th>arg 1</Th><td>char *buf</td></tr>
<tr><th></th><td>Top address of input binary data.
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>Length of input binary data.
</td></tr>
<tr><th>arg 3</Th><td>char *out</td></tr>
<tr><th></th><td>Top address of output string buffer.
</td></tr>
<tr><th>arg 4</Th><td>int outlen</td></tr>
<tr><th></th><td>Size of output string buffer.
</td></tr>
<tr><th>Return value</th><td>Returns VCE_EFULL if outout buffer is filled up.
Otherwise returns how many bytes are filled. ( null terminator
character is not included).
</td></tr>
<tr><th>Description</th><td>One byte becomes two characters after conversion.
Necessary information to decode its buffer is described in
leading data header.
For proving its contents, a check-sum value by SHA-1 and
length of content are contained.
When reading, this function checks all these information
is correct.
Converted string can be restored with
vce_make_binary_array_from_hex function.
</td></tr>
<tr><th>See also</th><td>
<a href="#hextext">hextext</a>
<a href="#vce_extract_data_from_hex_text">vce_extract_data_from_hex_text</a>
<a href="#vce_make_binary_array_from_hex">vce_make_binary_array_from_hex</a>
</td></tr>
</table><br><br>
<a name="vce_makecstr"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_makecstr</th></tr>
<tr><th>Summary</th><td>Initialize C string from non-null-terminated buffer</td></tr>
<tr><th>Category</th><td>text</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>char * vce_makecstr( char *out, int outlen, char *in, int inlen )</b></td>
<tr><th>arg 1</Th><td>char *out</td></tr>
<tr><th></th><td>Top address of output buffer which will contain C string.
</td></tr>
<tr><th>arg 2</Th><td>int outlen</td></tr>
<tr><th></th><td>Max length of output string. This includes terminator null character.
So, if you specify 10 to this parameter, you will get upto 9 characters
in this output buffer, and 1 terminator character.
</td></tr>
<tr><th>arg 3</Th><td>char *in</td></tr>
<tr><th></th><td>Top address of input buffer.
</td></tr>
<tr><th>arg 4</Th><td>int inlen</td></tr>
<tr><th></th><td>Length of input data.
This data is not terminated by C's null character,
so you have 10 characters if you specify 10 this parameter.
</td></tr>
<tr><th>Return value</th><td>Return parameter "out" as it is.
</td></tr>
<tr><th>Description</th><td>In many cases such as protocol processing,
data usually consists of "length and content",
however for outputting with printf, data should be converted to
a string in C format.
This function converts "length and content" data to
C format string with NULL termination.
</td></tr>
</table><br><br>
<a name="vce_monitor_client_add"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_client_add</th></tr>
<tr><th>Summary</th><td>Add a target to monitoring client</td></tr>
<tr><th>Category</th><td>monitor</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_monitor_client_add( monitor_ent_t *m )</b></td>
<tr><th>arg 1</Th><td>monitor_ent_t *m</td></tr>
<tr><th></th><td>Pointer to the structure which contains configuration information.
</td></tr>
<tr><th>Return value</th><td>Returns zero if successful, otherwize minus error code.
</td></tr>
<tr><th>Description</th><td>Add a new host to monitor client.
It is convenient if you use an vce_monitor_ent_init function in
order to initialize the structure which stores setting information.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_monitor_client_add">vce_monitor_client_add</a>
<a href="#vce_monitor_client_enable">vce_monitor_client_enable</a>
</td></tr>
</table><br><br>
<a name="vce_monitor_client_call"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_client_call</th></tr>
<tr><th>Summary</th><td>Send a command to the monitored process</td></tr>
<tr><th>Category</th><td>monitor</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_monitor_client_call( int id, int serial, char *s )</b></td>
<tr><th>arg 1</Th><td>int id</td></tr>
<tr><th></th><td>ID number of monitor configuration
</td></tr>
<tr><th>arg 2</Th><td>int serial</td></tr>
<tr><th></th><td>a serial number.
</td></tr>
<tr><th>arg 3</Th><td>char *s</td></tr>
<tr><th></th><td>A string to send.
</td></tr>
<tr><th>Return value</th><td>Returns plus value if successful, otherwize minus or zero.
</td></tr>
<tr><th>Description</th><td>Send designated string to a process which is being monitored.
If it succeeds, transmitted number of bytes will be returned.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_monitor_client_add">vce_monitor_client_add</a>
<a href="#vce_monitor_client_callable">vce_monitor_client_callable</a>
<a href="#vce_monitor_client_enable">vce_monitor_client_enable</a>
</td></tr>
</table><br><br>
<a name="vce_monitor_client_callable"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_client_callable</th></tr>
<tr><th>Summary</th><td>Check if it can send a command to the monitored process</td></tr>
<tr><th>Category</th><td>monitor</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_monitor_client_callable( int id )</b></td>
<tr><th>arg 1</Th><td>int id</td></tr>
<tr><th></th><td>ID number of monitor configuration which will be checkd by
this function.
</td></tr>
<tr><th>Return value</th><td>Returns plus value if sendable, otherwize minus or zero.
Please note that you have to check this return
value is <B>larger than zero.</b>
</td></tr>
<tr><th>Description</th><td>Check whether a command can be transmitted or not, to
a process which is under monitoring.
You specify the process by ID number.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_monitor_client_add">vce_monitor_client_add</a>
<a href="#vce_monitor_client_call">vce_monitor_client_call</a>
<a href="#vce_monitor_client_enable">vce_monitor_client_enable</a>
</td></tr>
</table><br><br>
<a name="vce_monitor_client_connect"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_client_connect</th></tr>
<tr><th>Summary</th><td>Connect to monitoring entry</td></tr>
<tr><th>Category</th><td>monitor</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_monitor_client_connect( int id )</b></td>
<tr><th>arg 1</Th><td>int id</td></tr>
<tr><th></th><td>ID number of monitor configuration.
</td></tr>
<tr><th>Return value</th><td>Returns zero if successful, otherwize minus error code.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_monitor_client_add">vce_monitor_client_add</a>
<a href="#vce_monitor_client_delete">vce_monitor_client_delete</a>
<a href="#vce_monitor_client_disconnect">vce_monitor_client_disconnect</a>
<a href="#vce_monitor_client_enable">vce_monitor_client_enable</a>
</td></tr>
</table><br><br>
<a name="vce_monitor_client_connected"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_client_connected</th></tr>
<tr><th>Summary</th><td>Check whether connected or not</td></tr>
<tr><th>Category</th><td>monitor</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_monitor_client_connected( int id )</b></td>
<tr><th>arg 1</Th><td>int id</td></tr>
<tr><th></th><td>ID number of monitor configuration.
</td></tr>
<tr><th>Return value</th><td>Returns 1 if connected, otherwize zero.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_monitor_client_add">vce_monitor_client_add</a>
<a href="#vce_monitor_client_delete">vce_monitor_client_delete</a>
<a href="#vce_monitor_client_disconnect">vce_monitor_client_disconnect</a>
<a href="#vce_monitor_client_enable">vce_monitor_client_enable</a>
</td></tr>
</table><br><br>
<a name="vce_monitor_client_delete"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_client_delete</th></tr>
<tr><th>Summary</th><td>Delete a monitor client</td></tr>
<tr><th>Category</th><td>monitor</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_monitor_client_delete( monitor_ent_t *m )</b></td>
<tr><th>arg 1</Th><td>int id</td></tr>
<tr><th></th><td>ID number of monitor configuration.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>Delete a monitor entry instance from memory, and stop monitoring
from now on.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_monitor_client_add">vce_monitor_client_add</a>
<a href="#vce_monitor_client_enable">vce_monitor_client_enable</a>
</td></tr>
</table><br><br>
<a name="vce_monitor_client_disable"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_client_disable</th></tr>
<tr><th>Summary</th><td>Stop monitoring client and release all resources</td></tr>
<tr><th>Category</th><td>monitor</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_monitor_client_disable(void)</b></td>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>Stop monitoring client initialized by vce_monitor_client_enable
and release all related resources.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_monitor_client_enable">vce_monitor_client_enable</a>
</td></tr>
</table><br><br>
<a name="vce_monitor_client_disconnect"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_client_disconnect</th></tr>
<tr><th>Summary</th><td>Disonnect to monitoring entry</td></tr>
<tr><th>Category</th><td>monitor</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_monitor_client_disconnect( int id )</b></td>
<tr><th>arg 1</Th><td>int id</td></tr>
<tr><th></th><td>ID number of monitor configuration.
</td></tr>
<tr><th>Return value</th><td>Returns zero if successful, otherwize minus error code.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_monitor_client_add">vce_monitor_client_add</a>
<a href="#vce_monitor_client_delete">vce_monitor_client_delete</a>
<a href="#vce_monitor_client_disconnect">vce_monitor_client_disconnect</a>
<a href="#vce_monitor_client_enable">vce_monitor_client_enable</a>
</td></tr>
</table><br><br>
<a name="vce_monitor_client_enable"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_client_enable</th></tr>
<tr><th>Summary</th><td>Initialize and enable monitoring client</td></tr>
<tr><th>Category</th><td>monitor</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_monitor_client_enable( int maxmonitor )</b></td>
<tr><th>arg 1</Th><td>int maxmonitor</td></tr>
<tr><th></th><td>Max number of monitored servers
</td></tr>
<tr><th>Return value</th><td>Returns zero if successful, otherwize returns minus error code.
</td></tr>
<tr><th>Description</th><td>Initialize a monitoring client.
No communication is performed only by initializing.
It can connect to a remote server which is monitored,
if the remote host is specified by
vce_monitor_client_add function after initializing using this
function.
Monitoring server in remote process(host)
have to be activated by vce_monitor_server_enable function
before enabling monitoring to be connected.
Please look at <a href="monitor.html">VCE monitoring</a>.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_monitor_client_add">vce_monitor_client_add</a>
<a href="#vce_monitor_server_enable">vce_monitor_server_enable</a>
</td></tr>
</table><br><br>
<a name="vce_monitor_client_set_replywatcher"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_client_set_replywatcher</th></tr>
<tr><th>Summary</th><td>Set client monitor a callback function that processes reply from server.</td></tr>
<tr><th>Category</th><td>monitor</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_monitor_client_set_replywatcher( void (*w)(int id, int serial, int result, char*data,int len))</b></td>
<tr><th>arg 1</Th><td>void (*w)(int id, char*data, int len )</td></tr>
<tr><th></th><td>Pointer to callback function.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>Specify a callback function to catch a reply from a remote host
which is being monitored.
This callback function will be called, with an argument containing
C string sent from a remote host being monitored.
Please look at <a href="monitor.html">VCE monitoring</a>
for precise format of the string.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_monitor_client_enable">vce_monitor_client_enable</a>
</td></tr>
</table><br><br>
<a name="vce_monitor_ent_init"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_ent_init</th></tr>
<tr><th>Summary</th><td>Initialize configuration structure for monitoring client</td></tr>
<tr><th>Category</th><td>monitor</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_monitor_ent_init( monitor_ent_t *m, int id, char *host, unsigned short port, char *pass )</b></td>
<tr><th>arg 1</Th><td>monitor_ent_t *m</td></tr>
<tr><th></th><td>Pointer to the target structure
</td></tr>
<tr><th>arg 2</Th><td>int id</td></tr>
<tr><th></th><td>ID number of the configuration
</td></tr>
<tr><th>arg 3</Th><td>char *host</td></tr>
<tr><th></th><td>Hostname of the target host
</td></tr>
<tr><th>arg 4</Th><td>unsigned short port</td></tr>
<tr><th></th><td>Port number of the process which will be monitored
</td></tr>
<tr><th>arg 5</Th><td>char *pass</td></tr>
<tr><th></th><td>a key string of the process which will be monitored
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>Initialize a configuration structure which is used for adding
a new host to a monitor client.
The value is only substituted simply.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_monitor_client_add">vce_monitor_client_add</a>
<a href="#vce_monitor_client_enable">vce_monitor_client_enable</a>
</td></tr>
</table><br><br>
<a name="vce_monitor_server_add_command"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_server_add_command</th></tr>
<tr><th>Summary</th><td>Add command for monitoring server</td></tr>
<tr><th>Category</th><td>monitor</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_monitor_server_add_command( char* name, int argc, int (*callback)( conn_t _c, int argc, char **argv), char *desc )</b></td>
<tr><th>arg 1</Th><td>char *name</td></tr>
<tr><th></th><td>name of command
</td></tr>
<tr><th>arg 2</Th><td>int argc</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 3</Th><td> int (*callback)( conn_t _c, int argc, char **argv )</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 4</Th><td> char *desc</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>Return value</th><td>PENDING
</td></tr>
<tr><th>Description</th><td>PENDING
</td></tr>
</table><br><br>
<a name="vce_monitor_server_add_stantdard_commands"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_server_add_stantdard_commands</th></tr>
<tr><th>Summary</th><td></td></tr>
<tr><th>Category</th><td>monitor</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_monitor_server_add_standard_commands()</b></td>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_monitor_server_add_command">vce_monitor_server_add_command</a>
</td></tr>
</table><br><br>
<a name="vce_monitor_server_disable"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_server_disable</th></tr>
<tr><th>Summary</th><td>Disable monitoring server</td></tr>
<tr><th>Category</th><td>monitor</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_monitor_server_disable(void)</b></td>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>Stop monitoring server, and release all related memory.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_monitor_server_enable">vce_monitor_server_enable</a>
</td></tr>
</table><br><br>
<a name="vce_monitor_server_enable"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_server_enable</th></tr>
<tr><th>Summary</th><td>Enable monitoring server task</td></tr>
<tr><th>Category</th><td>monitor</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_monitor_server_enable( int listen_port, int maxcon, char *key )</b></td>
<tr><th>arg 1</Th><td>int listen_port</td></tr>
<tr><th></th><td>Specify port number for listening to monitor client.
Default port number(9099) is selected when specifying zero.
</td></tr>
<tr><th>arg 2</Th><td>int maxcon</td></tr>
<tr><th></th><td>Max number of monitoring clients
</td></tr>
<tr><th>arg 3</Th><td>char *key</td></tr>
<tr><th></th><td>Password string for access restriction
</td></tr>
<tr><th>Return value</th><td>Returns zero if successful, otherwize returns minus error code.
</td></tr>
<tr><th>Description</th><td>It activates server for remote monitoring.
By calling this function, it becomes possible to monitor a process from
a remote.
Monitoring protocol uses RIJNDAEL with 16 byte key inside,
and it calls the callback function using text parser,
and carries out the command by using string command line.

By using this function, it is also possible to carry
out remote maintenance against "swp" of VCE.
Therefore "swpadm", remote maintenance program for the swp,
uses monitor client.
It is convenient to use a series of monitoring routines,
if you would like to attach a remote monitor function
to your server program.
Please refer to the "VCE monitoring" for the detail of the monitor routines.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_monitor_client_enable">vce_monitor_client_enable</a>
</td></tr>
</table><br><br>
<a name="vce_monitor_server_reply"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_monitor_server_reply</th></tr>
<tr><th>Summary</th><td></td></tr>
<tr><th>Category</th><td>monitor</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_monitor_server_reply( conn_t _c, int result, char *output )</b></td>
<tr><th>arg 1</Th><td>conn_t _c</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 2</Th><td>int result</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 3</Th><td> char *output</td></tr>
<tr><th></th><td></td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td></td></tr>
</table><br><br>
<a name="vce_profiler_cleanup"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_profiler_cleanup</th></tr>
<tr><th>Summary</th><td>clean up all used memory by VCE profiler routines</td></tr>
<tr><th>Category</th><td>profiler</td></tr>
<tr><th>Compatibility</th><td>linux,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_profiler_cleanup( void )</b></td>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>Release all resources occupied by VCE profiler.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_profiler_init">vce_profiler_init</a>
</td></tr>
</table><br><br>
<a name="vce_profiler_in"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_profiler_in</th></tr>
<tr><th>Summary</th><td>start profiling in a code part(start timer)</td></tr>
<tr><th>Category</th><td>profiler</td></tr>
<tr><th>Compatibility</th><td>linux,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_profiler_in( char *tag )</b></td>
<tr><th>arg 1</Th><td>char *tag</td></tr>
<tr><th></th><td>Top address of string containing tag name .
</td></tr>
<tr><th>Return value</th><td>Returns zero if successful.
Returns error code when any errors.
</td></tr>
<tr><th>Description</th><td>This function activates a timer with a tag.
When the timer started by this function is not stopped by
vce_profiler_out function,
it will remain being active.
Trying to start the timer while the timer is being activated
will return an error (VCE_EALREADY).
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_profiler_init">vce_profiler_init</a>
<a href="#vce_profiler_out">vce_profiler_out</a>
</td></tr>
</table><br><br>
<a name="vce_profiler_init"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_profiler_init</th></tr>
<tr><th>Summary</th><td>profiler routines implemented by gettimeofday</td></tr>
<tr><th>Category</th><td>profiler</td></tr>
<tr><th>Compatibility</th><td>linux,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_profiler_init( int max_tags )</b></td>
<tr><th>arg 1</Th><td>int max_tags</td></tr>
<tr><th></th><td>Max number of profiler tags.
</td></tr>
<tr><th>Return value</th><td>Returns if initialization is successful.
Returns minus error indicator value if failed.
</td></tr>
<tr><th>Description</th><td>VCE can execute accurate profiling that have precision
about several tens of microseconds by using the gettimeofday.
This function initializes the profiler routine.
By using the max_tags argument, maximum length of time measurement
is determined.
This indicates how many tags will be set at most, which are designated
by the vce_profiler_[in|out] function.
Inside vce_profiler_init, VCE profiler needs one VCE array and one
VCE search engine.
Please note that when you are using vce_initialize_limited function
to save memory usage.

VCE profiler operates based on "tag" information, and implements
execution time measurement on an application level.
In other words, VCE uses vce_profiler_in function to
activate timer, and stops counting time with vce_profiler_out
function.
The same "tag" string is designated in both functions, and both
functions operate in pair way.
So, please be careful if you want to profile some C function
that has two or more return(s) statement.
In addition, multiple profiling at the
same time is possible since each tag is independently count.

VCE provides these profiling mechanism because
<ul>
<LI>The standard profiler does not have a task to reset and fetch values
during the program is running.
<LI>Default profiler does not have good portability/compatibility.
</ul>
</td></tr>
<tr><th>Example</th><td><pre>
  int main(){
      vce_profiler_init(100);
      subroutine();
  }
  void subroutine()
  {
      vce_profiler_in( "subroutine"); // Start timer
      if( ... ){
          vce_profiler_out( "subroutine" ); // Need _out here
          return;
      }
      vce_profiler_out( "subroutine"); // Need _out here, too
      return;
  }
</pre>  
</td></tr>
<tr><th>Bugs/TODO</th><td>By using gettimeofday directly with vce_profiler_[in|out]
function, it will probably get a bit slower than standard profiling.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_initialize_limited">vce_initialize_limited</a>
<a href="#vce_profiler_cleanup">vce_profiler_cleanup</a>
<a href="#vce_profiler_in">vce_profiler_in</a>
<a href="#vce_profiler_out">vce_profiler_out</a>
</td></tr>
</table><br><br>
<a name="vce_profiler_out"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_profiler_out</th></tr>
<tr><th>Summary</th><td>stop timer invoked by vce_profiler_in</td></tr>
<tr><th>Category</th><td>profiler</td></tr>
<tr><th>Compatibility</th><td></td></tr>
<tr><th>Prototype</th><td><b>int vce_profiler_out( char *tag )</b></td>
<tr><th>arg 1</Th><td>char *tag</td></tr>
<tr><th></th><td>Top address of string containing profiler tag name.
</td></tr>
<tr><th>Return value</th><td>Returns zero if successful.
Returns minus error code when any error occured.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_profiler_in">vce_profiler_in</a>
<a href="#vce_profiler_init">vce_profiler_init</a>
</td></tr>
</table><br><br>
<a name="vce_profiler_save_stats"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_profiler_save_stats</th></tr>
<tr><th>Summary</th><td>print out VCE profiler status in a file</td></tr>
<tr><th>Category</th><td>profiler</td></tr>
<tr><th>Compatibility</th><td>linux,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_profiler_save_stats( char *path )</b></td>
<tr><th>arg 1</Th><td>char *path</td></tr>
<tr><th></th><td>Path name of output file.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>Print out current status of VCE internal profiler routines.
This output is formatted same as vce_read_simple_config_file function.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_profiler_init">vce_profiler_init</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_acceptwatcher_deny"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_acceptwatcher_deny</th></tr>
<tr><th>Summary</th><td>accept watcher for TCP conn_t which denies all connection.</td></tr>
<tr><th>Category</th><td>watcher</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_protocol_acceptwatcher_deny( conn_t c )</b></td>
<tr><th>arg 1</Th><td>conn_t c</td></tr>
<tr><th></th><td>An instance of conn_t, which is newly accepted by a server tcpcontext_t.
</td></tr>
<tr><th>Return value</th><td>This function always returns -1, so no new connections are accepted.
</td></tr>
<tr><th>Description</th><td>This function is passed to vce_tcpcontext_create function
as its argument.
When this function is set in a TCPcontext, all connections
are rejected and any client cannot connect to the server.
This function is for debugging.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_acceptwatcher_noop">vce_protocol_acceptwatcher_noop</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_acceptwatcher_noop"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_acceptwatcher_noop</th></tr>
<tr><th>Summary</th><td>accept() watcher for TCP conn_t which accepts all connection.</td></tr>
<tr><th>Category</th><td>watcher</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_protocol_acceptwatcher_noop( conn_t c )</b></td>
<tr><th>arg 1</Th><td>conn_t c</td></tr>
<tr><th></th><td>An instance of conn_t, which is newly accepted by a server tcpcontext_t.
</td></tr>
<tr><th>Return value</th><td>Always returns zero, so automatically all new connections are
accepted without any limitation.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_acceptwatcher_deny">vce_protocol_acceptwatcher_deny</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_acceptwatcher_vec0"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_acceptwatcher_vec0</th></tr>
<tr><th>Summary</th><td>A default callback function when packet-vectorizer accept()s.</td></tr>
<tr><th>Category</th><td>watcher</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_protocol_acceptwatcher_vec0( conn_t ct )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>Newly accepted conn_t.
</td></tr>
<tr><th>Return value</th><td>Returns zero if successful, otherwise returns minus error indicator value.
</td></tr>
<tr><th>Description</th><td>Generally, this function is not used directly from your application.
When VCE's "swp" gets new request from a client,
it uses this function to tell main server ( vecmain server )
that new client is comming.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_closewatcher_noop"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_closewatcher_noop</th></tr>
<tr><th>Summary</th><td>TCP connection close watcher which does nothing</td></tr>
<tr><th>Category</th><td>watcher</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_protocol_closewatcher_noop( conn_t c )</b></td>
<tr><th>arg 1</Th><td>conn_t c</td></tr>
<tr><th></th><td>An instance of conn_t which will be closed by this function call.
</td></tr>
<tr><th>Return value</th><td>This function always returns zero.
</td></tr>
<tr><th>Description</th><td>This callback function can be set in TCPcontext.
This function do not perform anything, so all request for new
TCP connection from clients are accepted.
You can use "NULL" instead of this function, but you'd better
use this function because your source code will be more cleaner.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_closewatcher_vec0"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_closewatcher_vec0</th></tr>
<tr><th>Summary</th><td>A default callback function when packet-vectorizer notices EOF.</td></tr>
<tr><th>Category</th><td>watcher</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_protocol_closewatcher_vec0( conn_t ct )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>Instance of conn_t which has got a new EOF signal.
</td></tr>
<tr><th>Return value</th><td>Returns 0 if successful, otherwise minus error code.
</td></tr>
<tr><th>Description</th><td>Generally, this function will not called directly from your application.
When VCE's "swp" meets EOF in TCP session between it and client,
it uses this function to tell the fact to backend server.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_parser_bin16"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_parser_bin16</th></tr>
<tr><th>Summary</th><td>Get a bin16 record and call callback function.</td></tr>
<tr><th>Category</th><td>parser</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_protocol_parser_bin16( conn_t c )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>target conn_t
</td></tr>
<tr><th>Return value</th><td>Returns zero if received data is not enough.
Returns return value of callback function as it is,
if data record is complete and could call protocol callback function.
</td></tr>
<tr><th>Description</th><td>vce_protocol_parser_bin16 function detects and fetches data record
from raw data sent to a conn_t (not a circ_t).
It fetches a protocol record that is named bin16.
Each time a record is detected, a callback function is called.
The callback function is set when vce_tcpcontext_create.

<BR>
In VCE application, you may want to use bin16 protocol
in almost all cases, because VCE is very good at processing
"many small packets".
<BR>
<BR>
<B> Content of bin16 protocol</B><BR>
One record passed through a socket is formatted as follows.
Here you will see C-like virtual code
<pre>
struct packet
{
unsigned short content_length;
char buf[content_length];
}
</pre>

This means that 10-byte data brings about 12-byte of
actual data sent (10 + sizeof(unsigned short)).
<BR><BR>
<B>Callback function definition</B><BR>
Definition of a callback function is
<PRE>
int callback( conn_t *c, char *data, int len )
</pRE>
<code>conn_t *c</code> is for target connection,
and <code>char *data</code> is for pointer to the buffer,
<code>int len</code> is length of the input buffer.

</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_parser_bin32">vce_protocol_parser_bin32</a>
<a href="#vce_protocol_parser_text">vce_protocol_parser_text</a>
<a href="#vce_protocol_unparser_bin16">vce_protocol_unparser_bin16</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_vecprotocol_parser_bin16">vce_vecprotocol_parser_bin16</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_parser_bin32"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_parser_bin32</th></tr>
<tr><th>Summary</th><td>Get a bin32 record and call callback function</td></tr>
<tr><th>Category</th><td>parser</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_protocol_parser_bin32( conn_t c )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>target conn_t
</td></tr>
<tr><th>Return value</th><td>Returns zero if received data is not completed.
Returns return value of protocol callback function
if data record is completed, and could call protocol callback function.
</td></tr>
<tr><th>Description</th><td>This function is designed for finding a record from received data
by a conn_t, and is applicable up to the 32-bit(4G) record length.
Since such long data record would just become the cause of quality
problem actually, detection is possible up to the length of
BIN32DATA_MAX.
When input record is longer than BIN32DATA_MAX,
that record is judged as a server-cracking, and
protocol error will be returned.
VCE shuts down the connection in this case.
BIN32DATA_MAX is defined within vce.h.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_parser_bin16">vce_protocol_parser_bin16</a>
<a href="#vce_protocol_unparser_bin32">vce_protocol_unparser_bin32</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_parser_text"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_parser_text</th></tr>
<tr><th>Summary</th><td>Get each line from stream and call protocol callback function</td></tr>
<tr><th>Category</th><td>parser</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_protocol_parser_text( conn_t c )</b></td>
<tr><th>arg 1</Th><td>conn_t c</td></tr>
<tr><th></th><td>target conn_t
</td></tr>
<tr><th>Return value</th><td>Returns zero if received data is not completed.
Returns return value of protocol callback function
if data record is completed, and could call protocol callback function.
</td></tr>
<tr><th>Description</th><td>This function fetches a line from received data by a conn_t,
by text parsing.
You should note that third person between your server and
clients will probably/accidentaly see content of the packets if you don't
use encryption. Text protocol is the most easy protocol to be
inspected by some sniffering program like "tcpdump".
<BR>
There are two types of delimiter characters for breaking line,
which are "\n" and "\r\n".
Also, input data to protocol callback function is NOT a C character
string with NULL-termination.
Therefore, data must be converted to the C string by using
vce_makecstr function.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_parser_bin16">vce_protocol_parser_bin16</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_parser_through"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_parser_through</th></tr>
<tr><th>Summary</th><td>A protocol parser for calling callback without reading records.</td></tr>
<tr><th>Category</th><td>parser</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_protocol_parser_through( conn_t ct )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>target conn_t
</td></tr>
<tr><th>Return value</th><td>It returns callback function's reeturn value as it is.
Therefore the connection is shut down automatically when the callback
function returns negative value.
</td></tr>
<tr><th>Description</th><td>Some protocols do not have a concept of record.
This parser function is designed for use of these cases.
This function does not perform any processing before
passing the input data to protocol callback function.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_parser_bin16">vce_protocol_parser_bin16</a>
<a href="#vce_protocol_unparser_through">vce_protocol_unparser_through</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_parser_vec0"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_parser_vec0</th></tr>
<tr><th>Summary</th><td>A parser for packet-vectorizer which accepts data from clients.</td></tr>
<tr><th>Category</th><td>parser</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_protocol_parser_vec0( conn_t ct )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>Target conn_t. This parser will read received data from
this connection.
</td></tr>
<tr><th>Return value</th><td>Returns zero if successful, otherwise returns minus error indicator value.
</td></tr>
<tr><th>Description</th><td>This function vectorizes the data that is entered to the specified
conn_t connection, and writes the data to the socket connected
to the backend main server that is applicable for vectorization.
Your application will not use this function directly,
because in ordinary cases you should use VCE's default "swp" server.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vp">vp</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_parser_vecmain_client"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_parser_vecmain_client</th></tr>
<tr><th>Summary</th><td>A parser for processing data from server</td></tr>
<tr><th>Category</th><td>parser</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_protocol_parser_vecmain_client( conn_t ct )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>Target conn_t.
</td></tr>
<tr><th>Return value</th><td>Returns 0 if success, otherwise minus error code.
</td></tr>
<tr><th>Description</th><td>This function will not used by your application directly,
but used by "swp" server program which is attached to VCE package.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_parser_vecmain_server"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_parser_vecmain_server</th></tr>
<tr><th>Summary</th><td>A data-parser for packet-vectorize-aware server</td></tr>
<tr><th>Category</th><td>parser</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_protocol_parser_vecmain_server( conn_t ct )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>Target conn_t.
</td></tr>
<tr><th>Return value</th><td>Returns 0 if successful, otherwise minus error code.
</td></tr>
<tr><th>Description</th><td>You will register this function as a parser function
when calling vce_tcpcontext_create.
You can make use of "swp" proxy server by using this function.
This function observes the data input from the connection and
analyzes it, then takes out the information of virtual circuit (circ_t).
If there is any received data from virtual circuit,
protocol parser function will be called-back.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_pcallback_dump"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_pcallback_dump</th></tr>
<tr><th>Summary</th><td>Protocol callback function for dumping data input from TCP connection</td></tr>
<tr><th>Category</th><td>pcallback</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_protocol_pcallback_dump( conn_t ct, char *data, int len )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>Processing conn_t. Note that this is not a circ_t.
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>Top address of received data.
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>Length of received data.
</td></tr>
<tr><th>Return value</th><td>Always returns zero because this function tramsmits nothing.
</td></tr>
<tr><th>Description</th><td>This function dumps all input data received by conn_t.
This function is prepared for
the purpose of debugging.
This function is called as a "protocol callback function".
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_pcallback_echo_bin16">vce_protocol_pcallback_echo_bin16</a>
<a href="#vce_protocol_pcallback_noop">vce_protocol_pcallback_noop</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_pcallback_echo_bin16"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_pcallback_echo_bin16</th></tr>
<tr><th>Summary</th><td>Echo callback function for normal TCP bin16 protocol</td></tr>
<tr><th>Category</th><td>pcallback</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_protocol_pcallback_echo_bin16( conn_t ct, char *data, int len )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>Processing conn_t. Note that this is not circ_t.
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>Top address of received data
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>Length of received data
</td></tr>
<tr><th>Return value</th><td>Returns minus value if error occured.
Returns larger than zero if transmit is successful.
</td></tr>
<tr><th>Description</th><td>This function is a protocol callback function,
which is specified when calling
vce_tcpcontext_set_conn_parser function.
This function echoes input data into output buffer as it is.
To use this function, you have to have bin16 parser by
vce_tcpcontext_set_conn_parser, and vce_protocol_parser_bin16.
<BR>
In actual application, you should use your original protocol
callback function, but you may be able to use this echo function
for your debugging.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_pcallback_dump">vce_protocol_pcallback_dump</a>
<a href="#vce_protocol_pcallback_noop">vce_protocol_pcallback_noop</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_vecprotocol_pcallback_echo_bin16">vce_vecprotocol_pcallback_echo_bin16</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_pcallback_echo_text"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_pcallback_echo_text</th></tr>
<tr><th>Summary</th><td>Echo callback function for normal TCP text line-based protocol</td></tr>
<tr><th>Category</th><td>pcallback</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_protocol_pcallback_echo_text(conn_t ct, char *data, int len )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>Processing conn_t.
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>Top address of received data
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>Length of received data.
</td></tr>
<tr><th>Return value</th><td>Returns minus error indicator value.
Returns larger than zero if tramsmit is successful.
</td></tr>
<tr><th>Description</th><td>Copies input data into output buffer using text protocol unparser
( vce_protocol_unparser_text function).
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_pcallback_echo_bin16">vce_protocol_pcallback_echo_bin16</a>
<a href="#vce_protocol_unparser_text">vce_protocol_unparser_text</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_pcallback_noop"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_pcallback_noop</th></tr>
<tr><th>Summary</th><td>No-Operation callback function for normal TCP connection ( conn_t )</td></tr>
<tr><th>Category</th><td>pcallback</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_protocol_pcallback_noop( conn_t ct ,char *data , int len )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>Processing conn_t. Note that this is not circ_t.
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>Top address of received data.
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>Length of received data (in bytes).
</td></tr>
<tr><th>Return value</th><td>Always returns zero, because this function transmits nothing.
</td></tr>
<tr><th>Description</th><td>This function will be specified as an argument to
vce_tcpcontext_set_conn_parser function.
This function just throws away all input data from the conn_t.
In most cases your application don't use this funciton,
but use your original protocol callback function made by yourself.
You may be able to use this function to make your server be quiet
temporarily.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_pcallback_dump">vce_protocol_pcallback_dump</a>
<a href="#vce_protocol_pcallback_echo_bin16">vce_protocol_pcallback_echo_bin16</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_unparser_bin16"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_unparser_bin16</th></tr>
<tr><th>Summary</th><td>Format data into bin16 protocol and write it to a connection.</td></tr>
<tr><th>Category</th><td>parser</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_protocol_unparser_bin16( conn_t ct, char *data , int len  )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>target conn_t
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>Pointer to input data, which will be transmitted after processing.
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>Length of input data.
</td></tr>
<tr><th>Return value</th><td>Returns number of bytes which is written into the conn_t.
Returns minus error code when any error.
Because this function sends a small data header at the same time,
so number of bytes will be 2 bytes larger than written data itself.
You can consult vce_protocol_parser_bin16 function for detail
content of each records.
</td></tr>
<tr><th>Description</th><td>This function is a formatter function for bin16 protocol.
This function sends a data record into a conn_t.
The record is formatted like [header + data].
The header part is always 2 bytes.
<B>Length of sent data</B><BR>
bin16 protocol does not corrupt outgoing data, just it chooses
from two choices send it completely, or do not send.
For example when you want to send 20 bytes of data,
this funciton will return 22 (20 + 2 )  or minus error code.
</td></tr>
<tr><th>Example</th><td>  // Example of protocol callback function for echoing server
  int callback( conn_t ct, char *data, int len )
  {
      return vce_protocol_unparser_bin16( ct,data,len );
  }
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_parser_bin16">vce_protocol_parser_bin16</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_unparser_bin32"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_unparser_bin32</th></tr>
<tr><th>Summary</th><td>Write a BIN32 record to a conn_t instance</td></tr>
<tr><th>Category</th><td>parser</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_protocol_unparser_bin32( conn_t ct, char *data, int len )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>target conn_t
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>Pointer to input data which will be transmitted after processing.
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>Length(byets) of input data.
</td></tr>
<tr><th>Return value</th><td>Returns number of bytes which is put out.
Returns minus error code if any errors.
SUccessful return value is always 4 bytes larger than input
data length.
</td></tr>
<tr><th>Description</th><td>bin32 protocol is used when you want to send larger packets than
64kb size, which is the maximum size of bin16 protocol.
You can send larger size packets, but at most BIN32DATA_MAX bytes.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_parser_bin32">vce_protocol_parser_bin32</a>
<a href="#vce_protocol_unparser_bin16">vce_protocol_unparser_bin16</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_unparser_text"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_unparser_text</th></tr>
<tr><th>Summary</th><td>write a text protocol line into conn_t</td></tr>
<tr><th>Category</th><td>parser</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_protocol_unparser_text( conn_t ct, char *data, int len )</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>target conn_t
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>Pointer to input data which will be transmitted after processing.
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>Length(bytes) of input data
</td></tr>
<tr><th>Return value</th><td>Returns number of bytes which is put out.
Returns minus error code when any errors.
Successful return value is always 1 bytes larger than
original input data.
</td></tr>
<tr><th>Description</th><td>This function will write input data without any escaping,
or any processing.
This function will add "\n" at the tail of input data,
so length of outgoing data is always 1 byte larger than original data.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_unparser_bin16">vce_protocol_unparser_bin16</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_protocol_unparser_through"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_protocol_unparser_through</th></tr>
<tr><th>Summary</th><td>Write data directly into a TCP connection.</td></tr>
<tr><th>Category</th><td>parser</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_protocol_unparser_through( conn_t ct, char *data, int len)</b></td>
<tr><th>arg 1</Th><td>conn_t ct</td></tr>
<tr><th></th><td>target conn_t
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>Pointer to input data which will be transmitted after processing.
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>Length(bytes) of input data.
</td></tr>
<tr><th>Return value</th><td>Length of transmitted data(in bytes).
Returns minus error indicator value if any error occured.
</td></tr>
<tr><th>Description</th><td>This function will write input data into conn_t.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_parser_through">vce_protocol_parser_through</a>
<a href="#vce_protocol_unparser_bin16">vce_protocol_unparser_bin16</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_read_plain_text_file"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_read_plain_text_file</th></tr>
<tr><th>Summary</th><td>Read plain text file by callback function</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_read_plain_text_file( const char *filename, int (*callback)(char*,in,char*))</b></td>
<tr><th>arg 1</Th><td>char *filename</td></tr>
<tr><th></th><td>Filename of configuration file.
</td></tr>
<tr><th>arg 2</Th><td>int (*callback) (char *filename,int lineno,char *line )</td></tr>
<tr><th></th><td>Callback function for processing content of file.
</td></tr>
<tr><th>Return value</th><td>Returns VCE_EACCESSFILE if the file is not readable.
Returns zero if successful.
If callback function returned minus value,
this function quits read-loop and returns the value
which is returned by the callback function.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_read_simple_config_file">vce_read_simple_config_file</a>
</td></tr>
</table><br><br>
<a name="vce_read_simple_config_file"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_read_simple_config_file</th></tr>
<tr><th>Summary</th><td>Read simple text configuration file by callback function</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_read_simple_config_file( const char *filename, int ( *callback ) ( char *,int,char *,char *) )</b></td>
<tr><th>arg 1</Th><td>char *filename</td></tr>
<tr><th></th><td>Filename of configuration file being read.
</td></tr>
<tr><th>arg 2</Th><td>int (*callback) (char *filename,int lineno,char *param, char *value)</td></tr>
<tr><th></th><td>Callback function for parsing content of file.
</td></tr>
<tr><th>Return value</th><td>Returns VCE_EACCESSFILE if the file is not readable.
Returns zero if successful.
If callback function returned minus value,
this function quits read-loop and returns the value
which is returned by the callback function.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#swp">swp</a>
<a href="#vce_copy_cstring_upto">vce_copy_cstring_upto</a>
<a href="#vp">vp</a>
</td></tr>
</table><br><br>
<a name="vce_replace_malloc_funcs"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_replace_malloc_funcs</th></tr>
<tr><th>Summary</th><td>Replace malloc function used inside VCE.</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_replace_malloc_funcs( void*(*a)(size_t), void*(*r)(void*,size_t), void(*f)(void*))</b></td>
<tr><th>arg 1</Th><td>void * (*a)(size_t)</td></tr>
<tr><th></th><td>Pointer to memory allocator function.
Ignore if this parameter is set NULL.
</td></tr>
<tr><th>arg 2</Th><td>void*(*a)(void*,size_t)</td></tr>
<tr><th></th><td>Pointer to memory re-allocator function.
Ignore if this parameter is set NULL.
</td></tr>
<tr><th>arg 3</Th><td>void (*f)(void*)</td></tr>
<tr><th></th><td>Pointer to memory free function.
Ignore if this parameter is set NULL.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
</table><br><br>
<a name="vce_save_statlog"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_save_statlog</th></tr>
<tr><th>Summary</th><td></td></tr>
<tr><th>Category</th><td>log</td></tr>
<tr><th>Compatibility</th><td>linux,win32,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_save_statlog( char *path )</b></td>
<tr><th>arg 1</Th><td>char *path</td></tr>
<tr><th></th><td>Pathname of log file.
</td></tr>
<tr><th>Return value</th><td>Returns zero if successful, otherwise returns minus error indicator value.
</td></tr>
<tr><th>Description</th><td></td></tr>
</table><br><br>
<a name="vce_scandir"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_scandir</th></tr>
<tr><th>Summary</th><td>Scan a UNIX directory. Can be filtered by file-name suffix.</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_scandir( char *path, char *suf, int (*callback)(char *path) );</b></td>
<tr><th>arg 1</Th><td>char *path</td></tr>
<tr><th></th><td>Path string to the directory.
</td></tr>
<tr><th>arg 2</Th><td>char *suf</td></tr>
<tr><th></th><td>File name suffix. Scan the directory, and try to find files
looking at suffixes.
You can use empty string "" to disable this siffix check.
You have to include period in this parameter, for example ".bmp"
This function finds directories too.
</td></tr>
<tr><th>arg 3</Th><td>int (*callback)(char *path)</td></tr>
<tr><th></th><td>Callback function. This function will be called every time
a file is found.
</td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>Bugs/TODO</th><td>This function cannot handle full pathname longer than 4096 bytes.
</td></tr>
</table><br><br>
<a name="vce_set_heartbeat_wait_flag"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_set_heartbeat_wait_flag</th></tr>
<tr><th>Summary</th><td>Control vce_heartbeat's sleep timer adjustment.</td></tr>
<tr><th>Category</th><td>core</td></tr>
<tr><th>Compatibility</th><td></td></tr>
<tr><th>Prototype</th><td><b>void vce_set_heartbeat_wait_flag( int flag )</b></td>
<tr><th>arg 1</Th><td>int flag</td></tr>
<tr><th></th><td>wait flag will be off when 0, or on if 1.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_heartbeat">vce_heartbeat</a>
</td></tr>
</table><br><br>
<a name="vce_set_internal_timer"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_set_internal_timer</th></tr>
<tr><th>Summary</th><td>Update VCE's internal timer</td></tr>
<tr><th>Category</th><td></td></tr>
<tr><th>Compatibility</th><td>other</td></tr>
<tr><th>Prototype</th><td><b>void vce_set_internal_timer( time_t t, unsigned int microsec )</b></td>
<tr><th>arg 1</Th><td>time_t t</td></tr>
<tr><th></th><td>time(sec) to be set.
</td></tr>
<tr><th>arg 2</Th><td>unsigned int microsec</td></tr>
<tr><th></th><td>time(microseconds) to be set.
This have to be between 0 and 999999.
Adopt (microsec mod 1000000) when microsec is larger than 999999.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
</table><br><br>
<a name="vce_set_mainloop_callback"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_set_mainloop_callback</th></tr>
<tr><th>Summary</th><td></td></tr>
<tr><th>Category</th><td>core</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_set_mainloop_callback( int (*f)(void) )</b></td>
<tr><th>arg 1</Th><td>int (*f)(void)</td></tr>
<tr><th></th><td>Pointer to callback function.
</td></tr>
<tr><th>Return value</th><td>None. always success.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_heartbeat">vce_heartbeat</a>
<a href="#vce_mainloop">vce_mainloop</a>
</td></tr>
</table><br><br>
<a name="vce_set_read_write_log_mode"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_set_read_write_log_mode</th></tr>
<tr><th>Summary</th><td>Set log mode flag to print VCE's read/write system calls</td></tr>
<tr><th>Category</th><td>core</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_set_read_write_log_mode( int mode )</b></td>
<tr><th>arg 1</Th><td>int mode</td></tr>
<tr><th></th><td>Output log information if set 1. Nothing will output if zero.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_set_verbose_mode">vce_set_verbose_mode</a>
</td></tr>
</table><br><br>
<a name="vce_set_socket_library_ok"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_set_socket_library_ok</th></tr>
<tr><th>Summary</th><td>Notify VCE that underlying socket library is initialized .</td></tr>
<tr><th>Category</th><td>core</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_set_socket_library_ok( int flag )</b></td>
<tr><th>arg 1</Th><td>int flag</td></tr>
<tr><th></th><td>Initialize flag. Set 1 if socket library is already OK,
otherwise 0.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_initialize">vce_initialize</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_set_verbose_mode"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_set_verbose_mode</th></tr>
<tr><th>Summary</th><td>Configure verbose mode for entire VCE library.</td></tr>
<tr><th>Category</th><td>core</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_set_verbose_mode( int mode )</b></td>
<tr><th>arg 1</Th><td>int mode</td></tr>
<tr><th></th><td>Set verbose mode if larger than zero. Normal mode is set if zero.
"Totaly quiet mode" if -1.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
</table><br><br>
<a name="vce_sha1_buffer_checksum"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_sha1_buffer_checksum</th></tr>
<tr><th>Summary</th><td>Calcurate SHA-1 checksum of a binary data array.</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_sha1_buffer_checksum( const char *buf , int len , char *out , int outlen )</b></td>
<tr><th>arg 1</Th><td>char *buf</td></tr>
<tr><th></th><td>Top address of input data. Calcurate checksum against this buffer.
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>Length of intput data being processed.
</td></tr>
<tr><th>arg 3</Th><td>char *out</td></tr>
<tr><th></th><td>Top address of destination buffer.
</td></tr>
<tr><th>arg 4</Th><td>int outlen</td></tr>
<tr><th></th><td>Size of destination buffer ( in bytes)
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#hextext">hextext</a>
<a href="#vce_sha1_file_checksum">vce_sha1_file_checksum</a>
</td></tr>
</table><br><br>
<a name="vce_sha1_file_checksum"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_sha1_file_checksum</th></tr>
<tr><th>Summary</th><td>Calcurate SHA-1 checksum of a file.</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_sha1_file_checksum( const char *path , char *out , int len )</b></td>
<tr><th>arg 1</Th><td>char *path</td></tr>
<tr><th></th><td>Filename.
</td></tr>
<tr><th>arg 2</Th><td>char *out</td></tr>
<tr><th></th><td>Top address of destination buffer.
Calcurated checksum will be filled in this buffer.
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>Size of destination buffer (in bytes)
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#hextext">hextext</a>
<a href="#vce_sha1_buffer_checksum">vce_sha1_buffer_checksum</a>
</td></tr>
</table><br><br>
<a name="vce_show_array_usage"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_show_array_usage</th></tr>
<tr><th>Summary</th><td>Print all information about a VCE array.</td></tr>
<tr><th>Category</th><td>array</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_show_array_usage( int index , int show_all )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Array descriptor to specify VCE's array.
</td></tr>
<tr><th>arg 2</Th><td>int show_all</td></tr>
<tr><th></th><td>Set 1 if you want description about all elements in VCE array,
otherwise set zero.
You will get huge amount of output string by setting 1.
</td></tr>
<tr><th>Return value</th><td>Return number of elements which are currently used.
</td></tr>
<tr><th>Description</th><td>This function is created for debugging.
It designates an array, and information about the elements controlled by the
array will be output to a log.
NOTE If the VCE library that is built with the setting
to suppress an error output is linked, this function will output
nothing even when VCE_ESUPPORT is returned.
</td></tr>
<tr><th>Bugs/TODO</th><td>Since this function uses the standard error output for outputting,
calling of this function becomes invalid when the
work environment is Win32GUI where the standard error output is not usable.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_init_array">vce_init_array</a>
</td></tr>
</table><br><br>
<a name="vce_snprintf"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_snprintf</th></tr>
<tr><th>Summary</th><td>wrapper function for libc's snprintf</td></tr>
<tr><th>Category</th><td>text</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_snprintf( char *out, int len, const char *format, ... )</b></td>
<tr><th>arg 1</Th><td>char *out</td></tr>
<tr><th></th><td>Top address of output string buffer.
</td></tr>
<tr><th>arg 2</Th><td>int len</td></tr>
<tr><th></th><td>Length of output buffer.
</td></tr>
<tr><th>arg 3</Th><td>char *format</td></tr>
<tr><th></th><td>Format string
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
</table><br><br>
<a name="vce_strcmptail"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_strcmptail</th></tr>
<tr><th>Summary</th><td>Compare tail characters of 2 strings,</td></tr>
<tr><th>Category</th><td>text</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_strcmptail( char *s1, char *s2 )</b></td>
<tr><th>arg 1</Th><td>char *s1</td></tr>
<tr><th></th><td>Pointer to first string
</td></tr>
<tr><th>arg 2</Th><td>char *s2</td></tr>
<tr><th></th><td>pointer to second string
</td></tr>
<tr><th>Return value</th><td>Returns 0 if two strings are completely same.
If not, returns non-zero value.
</td></tr>
<tr><th>Description</th><td>Compare end of two strings.
</td></tr>
</table><br><br>
<a name="vce_strerror"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_strerror</th></tr>
<tr><th>Summary</th><td>Convert VCE error code into string.</td></tr>
<tr><th>Category</th><td>err</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>char *vce_strerror( int ecode );</b></td>
<tr><th>arg 1</Th><td>int ecode</td></tr>
<tr><th></th><td>Error code defined in vce.h.
</td></tr>
<tr><th>Return value</th><td>Pointer to returned string.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_last_error">vce_get_last_error</a>
</td></tr>
</table><br><br>
<a name="vce_strerror_close_reason"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_strerror_close_reason</th></tr>
<tr><th>Summary</th><td>Convert VCE CLOSE_REASON code into string.</td></tr>
<tr><th>Category</th><td>err</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>char *vce_strerror_close_reason( CLOSE_REASON reason );</b></td>
<tr><th>arg 1</Th><td>CLOSE_REASON reason</td></tr>
<tr><th></th><td>CLOSE_REASON Error code defined in vce.h.
</td></tr>
<tr><th>Return value</th><td>Pointer to returned string.
</td></tr>
<tr><th>Description</th><td></td></tr>
</table><br><br>
<a name="vce_strlenmax"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_strlenmax</th></tr>
<tr><th>Summary</th><td>strlen with max length</td></tr>
<tr><th>Category</th><td>text</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_strlenmax( char *s, int max )</b></td>
<tr><th>arg 1</Th><td>char *s</td></tr>
<tr><th></th><td>Top address of string.
</td></tr>
<tr><th>arg 2</Th><td>int max</td></tr>
<tr><th></th><td>Max length of string.
</td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td></td></tr>
</table><br><br>
<a name="vce_strncat"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_strncat</th></tr>
<tr><th>Summary</th><td>Append a C string to another C string</td></tr>
<tr><th>Category</th><td>text</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_strncat( char *out, int outlen, char *append )</b></td>
<tr><th>arg 1</Th><td>char *out</td></tr>
<tr><th></th><td>Top address of string which will be expanded.
</td></tr>
<tr><th>arg 2</Th><td>int outlen</td></tr>
<tr><th></th><td>Max length of expanded string ( including last null character).
</td></tr>
<tr><th>arg 3</Th><td>char *append</td></tr>
<tr><th></th><td>Top address of string which will be appended to parameter "out".
</td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td></td></tr>
</table><br><br>
<a name="vce_strncpy"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_strncpy</th></tr>
<tr><th>Summary</th><td>copies C string</td></tr>
<tr><th>Category</th><td>text</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_strncpy( char *to, int to_len, const char *from, int from_len )</b></td>
<tr><th>arg 1</Th><td>char *to</td></tr>
<tr><th></th><td>Top address of destination string.
</td></tr>
<tr><th>arg 2</Th><td>int to_len</td></tr>
<tr><th></th><td>Size of destination string buffer.
</td></tr>
<tr><th>arg 3</Th><td>const char *from</td></tr>
<tr><th></th><td>Top address of copy source string.
</td></tr>
<tr><th>arg 4</Th><td>int from_len</td></tr>
<tr><th></th><td>How many bytes are copied.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
</table><br><br>
<a name="vce_switchcontext_cleanup"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_switchcontext_cleanup</th></tr>
<tr><th>Summary</th><td>Free a switch context</td></tr>
<tr><th>Category</th><td></td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_switchcontext_cleanup( switchcontext_t sw )</b></td>
<tr><th>arg 1</Th><td>switchcontext_t sw</td></tr>
<tr><th></th><td>switch context to be freed
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_switchcontext_create">vce_switchcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_switchcontext_create"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_switchcontext_create</th></tr>
<tr><th>Summary</th><td>Allocate and initialize an instance of connection switch context.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>switchcontext_t vce_switchcontext_create( vprent_t *st, int num, tcpcontext_t fectx, tcpcontext_t svctx, int rjbuf_size, SW_ACCEPTER_POLICY accepter_policy )</b></td>
<tr><th>arg 1</Th><td>vprent_t *st</td></tr>
<tr><th></th><td>Top address of switching table array.
</td></tr>
<tr><th>arg 2</Th><td>int num</td></tr>
<tr><th></th><td>Number of elements of switching table array.
</td></tr>
<tr><th>arg 3</Th><td>tcpcontext_t fectx</td></tr>
<tr><th></th><td>instance of tcpcontext_t for frontend (client side) communication.
</td></tr>
<tr><th>arg 4</Th><td>tcpcontext_t svctx</td></tr>
<tr><th></th><td>instance of tcpcontext_t for backend (server side) communication.
</td></tr>
<tr><th>arg 5</Th><td>int rjbuf_size</td></tr>
<tr><th></th><td>Size of temporary buffer which contains rejected data from
"switching source server".
</td></tr>
<tr><th>arg 6</Th><td>SW_ACCEPTER_POLICY accepter_policy</td></tr>
<tr><th></th><td></td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_switchcontext_cleanup">vce_switchcontext_cleanup</a>
</td></tr>
</table><br><br>
<a name="vce_switchtable_read_from_file"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_switchtable_read_from_file</th></tr>
<tr><th>Summary</th><td>Read connection switching table from a text file</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_switchtable_read_from_file( char *fn, vprent_t *sw, int *num )</b></td>
<tr><th>arg 1</Th><td>char *fn</td></tr>
<tr><th></th><td>Path name of input file.
</td></tr>
<tr><th>arg 2</Th><td>vprent_t *sw</td></tr>
<tr><th></th><td>Array of vprent_t which will contain switch entry configuration.
</td></tr>
<tr><th>arg 3</Th><td>int *num</td></tr>
<tr><th></th><td>value-result parameter. Max number of "sw" array is set,
and then returns number of elements actually filled in this array.
</td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_switchcontext_create">vce_switchcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_switchtable_show"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_switchtable_show</th></tr>
<tr><th>Summary</th><td>Display all member of switching table</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_switchtable_show( const switchent_t *sw, int num )</b></td>
<tr><th>arg 1</Th><td>switchent_t *sw</td></tr>
<tr><th></th><td>Top address of switching table(array) to be shown.
</td></tr>
<tr><th>arg 2</Th><td>int num</td></tr>
<tr><th></th><td>Number of elements of switching table array.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_switchtable_read_from_file">vce_switchtable_read_from_file</a>
</td></tr>
</table><br><br>
<a name="vce_taskcontext_cleanup"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_taskcontext_cleanup</th></tr>
<tr><th>Summary</th><td>Free and clean up task data structure</td></tr>
<tr><th>Category</th><td>task</td></tr>
<tr><th>Compatibility</th><td>linux,win32,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_taskcontext_cleanup( taskcontext_t tp )</b></td>
<tr><th>arg 1</Th><td>taskcontext_t tp</td></tr>
<tr><th></th><td>A task to be freed
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>Free taskcontext.
After this, task's callback function will never invoked.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_taskcontext_create">vce_taskcontext_create</a>
<a href="#vce_taskgroup_create">vce_taskgroup_create</a>
</td></tr>
</table><br><br>
<a name="vce_taskcontext_create"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_taskcontext_create</th></tr>
<tr><th>Summary</th><td>Create a task context.</td></tr>
<tr><th>Category</th><td>task</td></tr>
<tr><th>Compatibility</th><td>linux,win32,darwin</td></tr>
<tr><th>Prototype</th><td><b>taskcontext_t vce_taskcontext_create( taskgroup_t tp, VCEI64 interval_us, int (*callback)( taskcontext_t tp, char *work, int len ), char *wk, int len )</b></td>
<tr><th>arg 1</Th><td>taskgroup_t tp</td></tr>
<tr><th></th><td>Specify a task group. New task will belong to this task group.
</td></tr>
<tr><th>arg 2</Th><td>VCEI64 interval_us</td></tr>
<tr><th></th><td>Interval time(microseconds) of task callback function.
Task callback function will be invocated this interval.
</td></tr>
<tr><th>arg 3</Th><td>int (*callback)( taskcontext_t tp, char * work, int len )</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 4</Th><td>char *wk</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 5</Th><td>int len</td></tr>
<tr><th></th><td>Length of work area.
</td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_taskgroup_create">vce_taskgroup_create</a>
</td></tr>
</table><br><br>
<a name="vce_taskcontext_get_elapsed_time"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_taskcontext_get_elapsed_time</th></tr>
<tr><th>Summary</th><td>Get elapsed time from initialization of taskcontext_t</td></tr>
<tr><th>Category</th><td>task</td></tr>
<tr><th>Compatibility</th><td>linux,win32,darwin</td></tr>
<tr><th>Prototype</th><td><b>VCEI64 vce_taskcontext_get_elapsed_time( taskcontext_t )</b></td>
<tr><th>arg 1</Th><td>taskcontext_t t</td></tr>
<tr><th></th><td>target task context.
</td></tr>
<tr><th>Return value</th><td>Elapsed time(microseconds casted to VCEI64 type)
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_taskcontext_create">vce_taskcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_taskcontext_get_id"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_taskcontext_get_id</th></tr>
<tr><th>Summary</th><td>Get task's id</td></tr>
<tr><th>Category</th><td>task</td></tr>
<tr><th>Compatibility</th><td>linux,win32,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_taskcontext_get_id( taskcontext_t tp )</b></td>
<tr><th>arg 1</Th><td>taskcontext_t tp</td></tr>
<tr><th></th><td>target task context.
</td></tr>
<tr><th>Return value</th><td>ID of task context.
</td></tr>
<tr><th>Description</th><td>All task have identical ID.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_taskcontext_create">vce_taskcontext_create</a>
<a href="#vce_taskgroup_create">vce_taskgroup_create</a>
</td></tr>
</table><br><br>
<a name="vce_taskcontext_get_workmem"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_taskcontext_get_workmem</th></tr>
<tr><th>Summary</th><td>Get pointer to work memory of a task</td></tr>
<tr><th>Category</th><td>task</td></tr>
<tr><th>Compatibility</th><td>linux,win32,darwin</td></tr>
<tr><th>Prototype</th><td><b>void *vce_taskcontext_get_workmem( taskcontext_t tp )</b></td>
<tr><th>arg 1</Th><td>taskcontext_t tp</td></tr>
<tr><th></th><td>target task context.
</td></tr>
<tr><th>Return value</th><td>Returns poitner to work area.
Returns NULL pointer if no work area is used.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_taskcontext_create">vce_taskcontext_create</a>
<a href="#vce_taskgroup_create">vce_taskgroup_create</a>
</td></tr>
</table><br><br>
<a name="vce_taskgroup_cleanup"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_taskgroup_cleanup</th></tr>
<tr><th>Summary</th><td>Free and clean up a task group</td></tr>
<tr><th>Category</th><td>task</td></tr>
<tr><th>Compatibility</th><td>linux,win32,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_taskgroup_cleanup( taskgroup_t tp )</b></td>
<tr><th>arg 1</Th><td>taskgroup_t tp</td></tr>
<tr><th></th><td>A task group to be freed.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>By freeing taskgroup, all related taskcontext will be stopped.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_taskgroup_create">vce_taskgroup_create</a>
</td></tr>
</table><br><br>
<a name="vce_taskgroup_create"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_taskgroup_create</th></tr>
<tr><th>Summary</th><td>Initialize task-group in VCE</td></tr>
<tr><th>Category</th><td>task</td></tr>
<tr><th>Compatibility</th><td>linux,win32,darwin</td></tr>
<tr><th>Prototype</th><td><b>taskgroup_t vce_taskgroup_create( VCEI64 granu_us, int num, int worksize, int per_loop, char *name )</b></td>
<tr><th>arg 1</Th><td>VCEI64 granu_us</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 2</Th><td>int num</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 3</Th><td>int worksize</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 4</Th><td>int per_loop</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 5</Th><td>char *name</td></tr>
<tr><th></th><td>Name of this task.
</td></tr>
<tr><th>Return value</th><td>Returns valid pointer if successful, otherwise NULL pointer.
Please note that type of return values is taskgroup_t, which is
typedef'ed.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_heartbeat">vce_heartbeat</a>
<a href="#vce_set_verbose_mode">vce_set_verbose_mode</a>
<a href="#vce_taskcontext_create">vce_taskcontext_create</a>
<a href="#vce_taskgroup_cleanup">vce_taskgroup_cleanup</a>
</td></tr>
</table><br><br>
<a name="vce_taskgroup_get_stat"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_taskgroup_get_stat</th></tr>
<tr><th>Summary</th><td>Get statistic information of a taskgroup</td></tr>
<tr><th>Category</th><td>task</td></tr>
<tr><th>Compatibility</th><td>linux,win32,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_taskgroup_get_stat( taskgroup_t tp, taskgroup_stat_t *s )</b></td>
<tr><th>arg 1</Th><td>taskgroup_t tp</td></tr>
<tr><th></th><td>target task group.
</td></tr>
<tr><th>arg 2</Th><td>taskgroup_stat_t *s</td></tr>
<tr><th></th><td>Top address of output status buffer.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_taskgroup_create">vce_taskgroup_create</a>
</td></tr>
</table><br><br>
<a name="vce_taskgroup_set_scan_log_mode"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_taskgroup_set_scan_log_mode</th></tr>
<tr><th>Summary</th><td>Configure taskgroup debug log output</td></tr>
<tr><th>Category</th><td>task</td></tr>
<tr><th>Compatibility</th><td>linux,win32,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_taskgroup_set_scan_log_mode( taskgroup_t tp, int v )</b></td>
<tr><th>arg 1</Th><td>taskgroup_t tp</td></tr>
<tr><th></th><td>taget taskgroup
</td></tr>
<tr><th>arg 2</Th><td>int v</td></tr>
<tr><th></th><td>Output debug log if not zero. Quiet if zero.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_taskgroup_create">vce_taskgroup_create</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_add_circ_ipv4_filter"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_add_circ_ipv4_filter</th></tr>
<tr><th>Summary</th><td>Filter IP address of comming circ_t connection to TCPcontext.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_tcpcontext_add_circ_ipv4_filter( tcpcontext_t tp, const char *net, const char *mask, int policy )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>Target TCPcontext.
</td></tr>
<tr><th>arg 2</Th><td>char *net</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 3</Th><td>char *mask</td></tr>
<tr><th></th><td>Netmask. For example, "255.255.255.0" is acceptable.
</td></tr>
<tr><th>arg 4</Th><td>int policy</td></tr>
<tr><th></th><td></td></tr>
<tr><th>Return value</th><td>Returns 0 if successful, otherwise minus error indicating code.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>Bugs/TODO</th><td>Currently, 128 IP filters are set at most.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_add_conn_ipv4_filter">vce_tcpcontext_add_conn_ipv4_filter</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_add_ipv4_filter"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_add_ipv4_filter</th></tr>
<tr><th>Summary</th><td>Filter IP address of comming conn_t connection to TCPcontext.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_tcpcontext_add_conn_ipv4_filter( tcpcontext_t tp, const char *net, const char *mask, int policy )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>Target TCPcontext which will have new filter configuration.
</td></tr>
<tr><th>arg 2</Th><td>char *net</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 3</Th><td>char *mask</td></tr>
<tr><th></th><td>Set netmask. For example, "255.255.255.0" is acceptable.
</td></tr>
<tr><th>arg 4</Th><td>int policy</td></tr>
<tr><th></th><td></td></tr>
<tr><th>Return value</th><td>Returns 0 if successful, otherwise returns minus error indicating code.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>Bugs/TODO</th><td>Currently, 128 IP filter can be set at most.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_add_circ_ipv4_filter">vce_tcpcontext_add_circ_ipv4_filter</a>
<a href="#vce_tcpcontext_delete_circ_ipv4_filter">vce_tcpcontext_delete_circ_ipv4_filter</a>
<a href="#vce_tcpcontext_delete_conn_ipv4_filter">vce_tcpcontext_delete_conn_ipv4_filter</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_circ_iterate"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_circ_iterate</th></tr>
<tr><th>Summary</th><td>Call a function against every circ_t elements in a tcpcontext_t</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_tcpcontext_circ_iterate( tcpcontext_t tt, int (*func)(circ_t c) )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tt</td></tr>
<tr><th></th><td>Target TCPcontext.
</td></tr>
<tr><th>arg 2</Th><td> int (*func)( circ_t c )</td></tr>
<tr><th></th><td></td></tr>
<tr><th>Return value</th><td>Returns 0 if successful, otherwise minus error indicating code.
Tipical cases are that the TCPcontext is not configured
for processing circ_t.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_conn_iterate">vce_tcpcontext_conn_iterate</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_cleanup"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_cleanup</th></tr>
<tr><th>Summary</th><td>Clean up a TCP context.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_tcpcontext_cleanup( tcpcontext_t tp )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>Pointer to tcpcontext_t. This pointer is obtained when calling
vce_tcpcontext_create. This function can used for freeing both server context
and client context .
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_clear_circ_ipv4_filter"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_clear_circ_ipv4_filter</th></tr>
<tr><th>Summary</th><td>Clear IP address filters for circ_t set in a TCP context.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_tcpcontext_clear_circ_ipv4_filter( tcpcontext_t tp )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>Target TCPcontext.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_add_circ_ipv4_filter">vce_tcpcontext_add_circ_ipv4_filter</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_clear_conn_ipv4_filter"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_clear_conn_ipv4_filter</th></tr>
<tr><th>Summary</th><td>Clear IP address filters for conn_t set in a TCP context.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_tcpcontext_clear_conn_ipv4_filter( tcpcontext_t tp )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>Target TCPcontext.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_add_conn_ipv4_filter">vce_tcpcontext_add_conn_ipv4_filter</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_conn_iterate"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_conn_iterate</th></tr>
<tr><th>Summary</th><td>Call a function against every element of a tcpcontext_t</td></tr>
<tr><th>Category</th><td></td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_tcpcontext_conn_iterate( tcpcontext_t tt, int (*f)(conn_t c))</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tt</td></tr>
<tr><th></th><td>Target TCPcontext.
</td></tr>
<tr><th>arg 2</Th><td>int (*f)(conn_t c)</td></tr>
<tr><th></th><td>Callback function which is called against every elements of
conn.
</td></tr>
<tr><th>Return value</th><td>Returns 0 if successful, otherwise minus error indicating code.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_circ_iterate">vce_tcpcontext_circ_iterate</a>
<a href="#vce_tcpcontext_get_all_connection">vce_tcpcontext_get_all_connection</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_connect"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_connect</th></tr>
<tr><th>Summary</th><td>Connect to a remote VCE server and set up a TCP connection.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>conn_t vce_tcpcontext_connect( tcpcontext_t tp, const char *hostname, unsigned short port );</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>TCPcontext containing configuration information for new
TCP connection.
</td></tr>
<tr><th>arg 2</Th><td>char *hname</td></tr>
<tr><th></th><td>Hostname to connect, or IPaddress string.
</td></tr>
<tr><th>arg 3</Th><td>unsigned short port</td></tr>
<tr><th></th><td>Port number to connect.
</td></tr>
<tr><th>Return value</th><td>Returns pointer to newly allocated conn_t struct, which is for
controlling one TCP connection. Returns NULL pointer when any error.
To get detailed error , you'll use vce_get_last_error.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_is_valid">vce_conn_is_valid</a>
<a href="#vce_conn_writable">vce_conn_writable</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_count_connections"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_count_connections</th></tr>
<tr><th>Summary</th><td>Count number of connections maintained by a tcpcontext</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_tcpcontext_count_connections( tcpcontext_t t, int *conn, int *circ )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t t</td></tr>
<tr><th></th><td>Target TCPcontext.
</td></tr>
<tr><th>arg 2</Th><td>int *conn</td></tr>
<tr><th></th><td>Top address of return buffer.
It will be ignored if set NULL.
</td></tr>
<tr><th>arg 3</Th><td>int *circ</td></tr>
<tr><th></th><td>Top address of return buffer. It will be ignored if set NULL.
</td></tr>
<tr><th>Return value</th><td>Returns 0 if successful, otherwise minus error indicator value.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_get_all_circuit">vce_tcpcontext_get_all_circuit</a>
<a href="#vce_tcpcontext_get_all_connection">vce_tcpcontext_get_all_connection</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_create"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_create</th></tr>
<tr><th>Summary</th><td>Initialize and allocate a TCP context.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>tcpcontext_t vce_tcpcontext_create( int flag, const char *bindaddr, unsigned short port, int maxcon, size_t rblen, size_t wblen, int timeout, VCE_BLOCK_CIPHER cipher, int shkeylen , int nonblock_connect, int nodelay, size_t statebuf_size )</b></td>
<tr><th>arg 1</Th><td>int flag</td></tr>
<tr><th></th><td>Basic configuration flag for TCPcontext's basic operation.
If 1, it will create IPv4 server tcpcontext.
If 0, it will create IPv4 client tcpcontext.
</td></tr>
<tr><th>arg 2</Th><td>char *bindaddr</td></tr>
<tr><th></th><td>IP address for binding a socket.
For ordinary usage, you use "0.0.0.0" for this.
If you want to bind a socket to a specific address, you can specify it
like "192.168.1.11"
</td></tr>
<tr><th>arg 3</Th><td> unsigned short port</td></tr>
<tr><th></th><td>Port number to bind a socket.
In UNIX(Linux), you have to be a super user when you want to use
port number less than 1024.
It's completely OK if it's larger than 7000.
</td></tr>
<tr><th>arg 4</Th><td>int maxcon</td></tr>
<tr><th></th><td>Max number of concurrrent TCP sessions.
VCE can support as many TCP sessions as the OS can handle,
but you can restrict number of TCP sessions less than OS limit.
In Linux you can use 1000 or more sessions, in MS-Windows
you can use 64(98/Me) or it depends on memory you have.
We don't recomend you to use too many TCP sessions (>2000)
in one machine for performance and security reasons.
You cannot specify this argument larger than the number that
you previously set by vce_initialize_limited function,
or Linux default value 1000.
</td></tr>
<tr><th>arg 5</Th><td>size_t rblen</td></tr>
<tr><th></th><td>Max length of receiving data from network.
This length is used by each TCP sessions ( conn_t ).
This length is not used by each circ_t.
You have to set this argument larger than 1024 when you want to use
encryption.
</td></tr>
<tr><th>arg 6</Th><td>size_t wblen</td></tr>
<tr><th></th><td>Max length of outgoing data to network.
This length is used by each TCP sessions ( conn_t ),
not by circ_t.
You have to set larger than 1024 if you want to use encryption.
Especially, if you use swp(switching proxy), you have to set
larger than 1MB(1024*1024).
</td></tr>
<tr><th>arg 7</Th><td>int timeout</td></tr>
<tr><th></th><td>TCP session timeout in seconds.
If a TCP session doesn't have outgoing data nor incoming data for a
length of time, VCE will close the session according to this configuration.
It rises an error if you try to write any data into closed(timed out)
TCP session.
</td></tr>
<tr><th>arg 8</Th><td>VCE_BLOCK_CIPHER cipher</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 9</Th><td>int shkeylen</td></tr>
<tr><th></th><td>If you want to use encrypted connection,
you should use one of them VCE_BLOCK_CIPHER_BLOWFISH,
VCE_BLOCK_CIPHER_RIJNDAEL, VCE_BLOCK_CIPHER_TWOFISH.
If you don't want to use encryption, you use VCE_BLOCK_CIPHER_NONE.
Each algorithm has different characteristics each other.
BLOWFISH is the fastest and oldest, but they say it's relatively
weaker. RIJNDAEL is relatively new and strong, but 20% slower.
Yes, let's use RIJNDAEL without thinking about it so long.
In our benchmark, RIJNDAEL at 800MHz PentiumIII can encode 20Mbit/s.
When you use encryption, you may not be able to ignore
server-side CPU high load.
</td></tr>
<tr><th>arg 10</Th><td>int nonblock_connect</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 11</Th><td>nodelay</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 12</Th><td>size_t statebuf_size</td></tr>
<tr><th></th><td></td></tr>
<tr><th>Return value</th><td>Return pointer to a TCPcontext.
Return NULL pointer if any error.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_circ_get_state">vce_circ_get_state</a>
<a href="#vce_conn_get_state">vce_conn_get_state</a>
<a href="#vce_initialize">vce_initialize</a>
<a href="#vce_initialize_limited">vce_initialize_limited</a>
<a href="#vce_tcpcontext_cleanup">vce_tcpcontext_cleanup</a>
<a href="#vce_tcpcontext_connect">vce_tcpcontext_connect</a>
<a href="#vce_tcpcontext_set_circ_acceptwatcher">vce_tcpcontext_set_circ_acceptwatcher</a>
<a href="#vce_tcpcontext_set_circ_closewatcher">vce_tcpcontext_set_circ_closewatcher</a>
<a href="#vce_tcpcontext_set_circ_parser">vce_tcpcontext_set_circ_parser</a>
<a href="#vce_tcpcontext_set_conn_acceptwatcher">vce_tcpcontext_set_conn_acceptwatcher</a>
<a href="#vce_tcpcontext_set_conn_closewatcher">vce_tcpcontext_set_conn_closewatcher</a>
<a href="#vce_tcpcontext_set_conn_parser">vce_tcpcontext_set_conn_parser</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_delete_circ_ipv4_filter"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_delete_circ_ipv4_filter</th></tr>
<tr><th>Summary</th><td>Remove IP filter configuration for circ_t.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_tcpcontext_delete_circ_ipv4_filter( tcpcontext_t tp, const char *net, const char *mask )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>Target TCPcontext.
</td></tr>
<tr><th>arg 2</Th><td>char *net</td></tr>
<tr><th></th><td>Network address of a filter which will be removed from the tcpcontext.
</td></tr>
<tr><th>arg 3</Th><td>char *mask</td></tr>
<tr><th></th><td>Netmask of a filter to be removed.
</td></tr>
<tr><th>Return value</th><td>Returns 0 if successful, otherwise minus error indicating code.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_add_circ_ipv4_filter">vce_tcpcontext_add_circ_ipv4_filter</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_delete_conn_ipv4_filter"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_delete_conn_ipv4_filter</th></tr>
<tr><th>Summary</th><td>Remove IP filter configuration for conn_t.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_tcpcontext_delete_conn_ipv4_filter( tcpcontext_t tp, const char *net, const char *mask )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>Target TCPcontext.
</td></tr>
<tr><th>arg 2</Th><td>char *net</td></tr>
<tr><th></th><td>Network address of a filter which will be removed.
</td></tr>
<tr><th>arg 3</Th><td>char *mask</td></tr>
<tr><th></th><td>Netmask of a filter which will be removed.
</td></tr>
<tr><th>Return value</th><td>Returns 0 if successful, otherwise minus error indicating code.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_add_conn_ipv4_filter">vce_tcpcontext_add_conn_ipv4_filter</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_enable_accept"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_enable_accept</th></tr>
<tr><th>Summary</th><td>PENDING</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_tcpcontext_enable_accept( tcpcontext_t tp, int flag )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>Target TCPcontext
</td></tr>
<tr><th>arg 2</Th><td>int flag</td></tr>
<tr><th></th><td>Accept next TCPconnection if set 1.
Deny all new TCPconnections if set 0.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_close_all_conn">vce_tcpcontext_close_all_conn</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_get_all_circuit"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_get_all_circuit</th></tr>
<tr><th>Summary</th><td>get all circuits included in a tcpcontext</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_tcpcontext_get_all_circuit( tcpcontext_t tt , circ_t *a, int max);</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tt</td></tr>
<tr><th></th><td>Target TCPcontext.
</td></tr>
<tr><th>arg 2</Th><td>circ_t *a</td></tr>
<tr><th></th><td>Top address of an array of circ_t.
</td></tr>
<tr><th>arg 3</Th><td>int max</td></tr>
<tr><th></th><td>Max number of elements of array parameter "a".
</td></tr>
<tr><th>Return value</th><td>Number of elements filled in given array.
This number must be larger than or equal to zero.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_count_connections">vce_tcpcontext_count_connections</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_get_all_connection"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_get_all_connection</th></tr>
<tr><th>Summary</th><td>get all connections included in a tcpcontext</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_tcpcontext_get_all_connection( tcpcontext_t t , conn_t *a, int max);</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t t</td></tr>
<tr><th></th><td>Target TCPcontext.
</td></tr>
<tr><th>arg 2</Th><td>conn_t *a</td></tr>
<tr><th></th><td>Top address of an array of conn_t.
</td></tr>
<tr><th>arg 3</Th><td>int max</td></tr>
<tr><th></th><td>Max number of elements of array parameter "a".
</td></tr>
<tr><th>Return value</th><td>Number of elements filled in given array.
This number must be larger than or equal to zero.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_count_connections">vce_tcpcontext_count_connections</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_get_stat"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_get_stat</th></tr>
<tr><th>Summary</th><td>Get tcpcontext's statistics information</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_tcpcontext_get_stat( tcpcontext_t tp, tcpcontext_stat_t *s )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>Target TCPcontext.
</td></tr>
<tr><th>arg 2</Th><td>tcpcontext_stat_t *s</td></tr>
<tr><th></th><td>Top address of tcpcontext_stat_t instance. It will save all
status information in this structure.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_conn_get_stat">vce_conn_get_stat</a>
<a href="#vce_get_stat">vce_get_stat</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_is_circ_mode"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_is_circ_mode</th></tr>
<tr><th>Summary</th><td>Check if a TCP context is set up for circ or conn.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_tcpcontext_is_circ_mode( tcpcontext_t tp )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>Target TCPcontext.
</td></tr>
<tr><th>Return value</th><td>Returns 1 if this TCPcontext is configured circ_t mode,
otherwise returns 0.
</td></tr>
<tr><th>Description</th><td></td></tr>
</table><br><br>
<a name="vce_tcpcontext_protocol_set_maxlength"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_protocol_set_maxlength</th></tr>
<tr><th>Summary</th><td>pending</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_tcpcontext_protocol_set_maxlength(tcpcontext_t ct,int maxlength,int(*errcall)(conn_t ct))</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t t</td></tr>
<tr><th></th><td>TCPcontext containing configuration information for new
TCP connection.
</td></tr>
<tr><th>arg 2</Th><td>int max_length</td></tr>
<tr><th></th><td>pending
</td></tr>
<tr><th>arg 3</Th><td>int(*errcall)(conn_t ct))</td></tr>
<tr><th></th><td>pending
</td></tr>
<tr><th>Return value</th><td>none
</td></tr>
<tr><th>Description</th><td>pending
</td></tr>
<tr><th>Bugs/TODO</th><td>pending
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_reset_compress"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_reset_compress</th></tr>
<tr><th>Summary</th><td></td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32</td></tr>
<tr><th>Prototype</th><td><b>void vce_tcpcontext_reset_compress( tcpcontext_t tp )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>PENDING
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_set_compress">vce_tcpcontext_set_compress</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_accept_max"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_accept_max</th></tr>
<tr><th>Summary</th><td>pending</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_tcpcontext_set_accept_max(tcpcontext_t t,int con_max,int (*accept_warning)(tcpcontext_t t))</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t t</td></tr>
<tr><th></th><td>TCPcontext containing configuration information for new
TCP connection.
</td></tr>
<tr><th>arg 2</Th><td>int con_max</td></tr>
<tr><th></th><td>pending
</td></tr>
<tr><th>arg 3</Th><td>int (*accept_warning)(tcpcontext_t t)</td></tr>
<tr><th></th><td>pending
</td></tr>
<tr><th>Return value</th><td>none
</td></tr>
<tr><th>Description</th><td>pending
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_circ_acceptwatcher"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_circ_acceptwatcher</th></tr>
<tr><th>Summary</th><td>Make TCPcontext use speficied function when new circ_t is accepted.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_tcpcontext_set_circ_acceptwatcher( tcpcontext_t tp, int (*aw)(circ_t) )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>Target TCPcontext
</td></tr>
<tr><th>arg 2</Th><td>int (*aw)(circ_t c )</td></tr>
<tr><th></th><td>Pointer to accept watcher function.
Parameter "c" stands for a newly accepted TCP connection.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_circ_closewatcher"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_circ_closewatcher</th></tr>
<tr><th>Summary</th><td>Make TCPcontext use specified function when circ_t is closed.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_tcpcontext_set_circ_closewatcher( tcpcontext_t tp, int (*cw)(circ_t,CLOSE_REASON) )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>Target TCPcontext.
</td></tr>
<tr><th>arg 2</Th><td>int (*cw)(circ_t c, CLOSE_REASON reason )</td></tr>
<tr><th></th><td>Pointer to close watcher function. Parameter "reason"
indicates why the connection is closed. You can consult "vce.h"
for CLOSE_REASON enum type.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_tcpcontext_set_conn_closewatcher">vce_tcpcontext_set_conn_closewatcher</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_circ_finalizer"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_circ_finalizer</th></tr>
<tr><th>Summary</th><td>Make TCPcontext use specified circ_t finalizer.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_tcpcontext_set_circ_finalizer( tcpcontext_t tp, void (*fin)(circ_t) )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>Target TCPcontext.
</td></tr>
<tr><th>arg 2</Th><td>void *fin(circ_t to_be_finalized )</td></tr>
<tr><th></th><td>Pointer to finalizer function.
"to_be_finalized" parameter stands for a circ_t that is being closed.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_tcpcontext_set_conn_finalizer">vce_tcpcontext_set_conn_finalizer</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_circ_hiwater_acceptwatcher"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_circ_hiwater_acceptwatcher</th></tr>
<tr><th>Summary</th><td></td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_tcpcontext_set_circ_hiwater_acceptwatcher( tcpcontext_t tp, int water, int (*aw)(circ_t, int))</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>Target TCPcontext
</td></tr>
<tr><th>arg 2</Th><td>int water</td></tr>
<tr><th></th><td>This number specifies high water number of concurrent sessions.
</td></tr>
<tr><th>arg 3</Th><td>int (*aw)(circ_t *c, int num )</td></tr>
<tr><th></th><td>Special accept watcher function for high water.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>This function is circ_t version of
vce_tcpcontext_set_conn_hiwater_acceptwatcher function.
Please look at its description.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_tcpcontext_set_conn_hiwater_acceptwatcher">vce_tcpcontext_set_conn_hiwater_acceptwatcher</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_circ_parser"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_circ_parser</th></tr>
<tr><th>Summary</th><td>Make TCPcontext use parser function when parsing data from circ_t.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_tcpcontext_set_circ_parser( tcpcontext_t tp, int (*parser)(circ_t), int (*pcallback)(circ_t,char*,int))</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>Target TCPcontext
</td></tr>
<tr><th>arg 2</Th><td>int (*parser)(circ_t c)</td></tr>
<tr><th></th><td>Pointer to parser function.
</td></tr>
<tr><th>arg 3</Th><td>int (*circcallback)(circ_t circ, char *data , int len )</td></tr>
<tr><th></th><td>Pointer to callback function which is called by parser function
when a data record is received.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_circ_switchresultwatcher"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_circ_switchresultwatcher</th></tr>
<tr><th>Summary</th><td>set tcpcontext a watcher function for the result of active connection switch.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_tcpcontext_set_circ_switchresultwatcher( tcpcontext_t t,int (*w)(circ_t,int,int,char*,int))</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t t</td></tr>
<tr><th></th><td>target tcpcontext_t
</td></tr>
<tr><th>arg 2</Th><td>int (*w)(circ_t c, int result, int dest_sv_id, char *data, int len)</td></tr>
<tr><th></th><td></td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_circ_switch">vce_circ_switch</a>
<a href="#vce_tcpcontext_set_circ_switchwatcher">vce_tcpcontext_set_circ_switchwatcher</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_circ_switchwatcher"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_circ_switchwatcher</th></tr>
<tr><th>Summary</th><td>set tcpcontext a watcher function for newly switched circ_t</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_tcpcontext_set_circ_switchwatcher( tcpcontext_t t, int (*sw)( circ_t, int, char *,int))</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t t</td></tr>
<tr><th></th><td>target tcpcontext_t
</td></tr>
<tr><th>arg 2</Th><td>int (*sw)(circ_t c, int from_id, char *data, int len )</td></tr>
<tr><th></th><td>Callback functoin which will be called if new circ_t is allocated.
</td></tr>
<tr><th>Return value</th><td>Returns zero if successful, otherwise returns minus error indicator value.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_circ_switch">vce_circ_switch</a>
<a href="#vce_tcpcontext_set_circ_switchresultwatcher">vce_tcpcontext_set_circ_switchresultwatcher</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_compress"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_compress</th></tr>
<tr><th>Summary</th><td>PENDING</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32</td></tr>
<tr><th>Prototype</th><td><b>void vce_tcpcontext_set_compress( tcpcontext_t tp , unsigned long size )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>arg 2</Th><td>unsigned long size</td></tr>
<tr><th></th><td>PENDING
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>PENDING
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_reset_compress">vce_tcpcontext_reset_compress</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_conn_acceptwatcher"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_conn_acceptwatcher</th></tr>
<tr><th>Summary</th><td>Make TCPcontext use specified accept watcher function</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_tcpcontext_set_conn_acceptwatcher( tcpcontext_t tp, int (*aw)(conn_t) )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>Target TCPcontext
</td></tr>
<tr><th>arg 2</Th><td>int (*aw)(conn_t c)</td></tr>
<tr><th></th><td>Accept watcher function. parameter "c" stands for a newly
accepted connection conn_t.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_tcpcontext_set_closewatcher">vce_tcpcontext_set_closewatcher</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_conn_call_parser_per_heartbeat"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_conn_call_parser_per_heartbeat</th></tr>
<tr><th>Summary</th><td>Adjust number of times of each conn_t parser call within a heartbeat</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_tcpcontext_set_conn_call_parser_per_heartbeat( tcpcontext_t tt, int v )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tt</td></tr>
<tr><th></th><td>Target TCpcontext.
</td></tr>
<tr><th>arg 2</Th><td>int v</td></tr>
<tr><th></th><td>Number of repetation. No operation is defined when setting minus
to this parameter.
</td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_heartbeat">vce_heartbeat</a>
<a href="#vce_tcpcontext_set_conn_parser">vce_tcpcontext_set_conn_parser</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_conn_closewatcher"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_conn_closewatcher</th></tr>
<tr><th>Summary</th><td>Make TCPcontext use specified close watcher function</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_tcpcontext_set_conn_closewatcher( tcpcontext_t tp, int (*cw)(conn_t,CLOSE_REASON) )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>Target TCPcontext.
</td></tr>
<tr><th>arg 2</Th><td>int (*cw)(conn_t c, CLOSE_REASON reason)</td></tr>
<tr><th></th><td></td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_tcpcontext_set_conn_acceptwatcher">vce_tcpcontext_set_conn_acceptwatcher</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_conn_finalizer"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_conn_finalizer</th></tr>
<tr><th>Summary</th><td>Make TCPcontext use specified conn_t finalizer .</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_tcpcontext_set_conn_finalizer( tcpcontext_t tp , void *finalizer(conn_t) )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>Pointer to target TCPcontext.
</td></tr>
<tr><th>arg 2</Th><td>void *finalizer(conn_t to_be_finalized )</td></tr>
<tr><th></th><td>Pointer to finalizer function.
"to_be_finalized" parameter stands for a connection which is
being closed.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_tcpcontext_set_circ_finalizer">vce_tcpcontext_set_circ_finalizer</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_conn_hiwater_acceptwatcher"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_conn_hiwater_acceptwatcher</th></tr>
<tr><th>Summary</th><td>Set a special high water accept watcher to a TCPcontext</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_tcpcontext_set_conn_hiwater_acceptwatcher( tcpcontext_t tp, int water, int (*aw)(conn_t,int))</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>Target TCPcontext
</td></tr>
<tr><th>arg 2</Th><td>int water</td></tr>
<tr><th></th><td>Number to specify high water, that means max number of
concurrent TCP sessions handled by the TCPcontext.
TCPcontext will call specified accept watcher function
when number of concurrent sessions are larger than this,
otherwise call default accept watcher.
</td></tr>
<tr><th>arg 3</Th><td>int (*aw)(conn_t c,int num)</td></tr>
<tr><th></th><td>accept watcher function that will be set to the TCPcontext.
This function is different from normal one because it will get
current number of concurrent sessions by "num" argument.
You can compare it with pre-set max number of sessions.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_tcpcontext_set_conn_acceptwatcher">vce_tcpcontext_set_conn_acceptwatcher</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_conn_kickip_array"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_conn_kickip_array</th></tr>
<tr><th>Summary</th><td>pending</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_tcpcontext_set_conn_kickip_array(tcpcontext_t tp,unsigned int *null_terminated_ipaddr_array)</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t t</td></tr>
<tr><th></th><td>TCPcontext containing configuration information for new
TCP connection.
</td></tr>
<tr><th>arg 2</Th><td>unsigned int *null_terminated_ipaddr_array</td></tr>
<tr><th></th><td>pending
</td></tr>
<tr><th>Return value</th><td>none
</td></tr>
<tr><th>Description</th><td>pending
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_conn_parser"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_conn_parser</th></tr>
<tr><th>Summary</th><td>Make TCPcontext use specified parser function</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_tcpcontext_set_conn_parser( tcpcontext_t tp, int (*parser)(conn_t),int (*pcallback)(conn_t,char*,int))</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>Target TCPcontext
</td></tr>
<tr><th>arg 2</Th><td>int (*parser)(conn_t c )</td></tr>
<tr><th></th><td>Pointer to parser function.
</td></tr>
<tr><th>arg 3</Th><td>int (*pcallback)(conn_t c,char *data, int len )</td></tr>
<tr><th></th><td>Callback function which is called every time when receiving
data record from the connection.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_tcpcontext_set_circ_parser">vce_tcpcontext_set_circ_parser</a>
<a href="#vce_tcpcontext_set_conn_call_parser_per_heartbeat">vce_tcpcontext_set_conn_call_parser_per_heartbeat</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_conn_safety_read"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_conn_safety_read</th></tr>
<tr><th>Summary</th><td>Set conn "safe read" mode.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_tcpcontext_set_conn_safety_read( tcpcontext_t tp, int per )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>Target TCPcontext.
"safety read" operation can be activated in both server TCPcontext
and client TCPcontext.
</td></tr>
<tr><th>arg 2</Th><td>int per</td></tr>
<tr><th></th><td></td></tr>
<tr><th>Return value</th><td>Returns 0 if successful, otherwise minus error indicating code.
</td></tr>
<tr><th>Description</th><td></td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_equal_io_splitrate"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_equal_io_splitrate</th></tr>
<tr><th>Summary</th><td>Configure number of connections to be flushed to network</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_tcpcontext_set_equal_io_splitrate( tcpcontext_t tt, int v )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tt</td></tr>
<tr><th></th><td>Target TCPcontext.
</td></tr>
<tr><th>arg 2</Th><td>int v</td></tr>
<tr><th></th><td>Process ( total / v ) connections among all connections in
one vce_heartbeat call.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
</table><br><br>
<a name="vce_tcpcontext_set_read_delay"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_set_read_delay</th></tr>
<tr><th>Summary</th><td>Emulate transportation delay on connections</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_tcpcontext_set_read_delay( tcpcontext_t tp, int min_delay_ms, int max_delay_ms , int distrib )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>Target TCPcontext
</td></tr>
<tr><th>arg 2</Th><td>int min_delay_ms</td></tr>
<tr><th></th><td></td></tr>
<tr><th>arg 3</Th><td>int max_delay_ms</td></tr>
<tr><th></th><td>Maximum latency in milliseconds
</td></tr>
<tr><th>arg 4</Th><td>int distrib</td></tr>
<tr><th></th><td></td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_timeout_control"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_timeout_control</th></tr>
<tr><th>Summary</th><td>Configure timeout operation on a tcpcontext_t.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>void vce_tcpcontext_timeout_control( tcpcontext_t tp, int recv_reset, int send_reset )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t t</td></tr>
<tr><th></th><td>Target TCPcontext.
</td></tr>
<tr><th>arg 2</Th><td>int recv_reset</td></tr>
<tr><th></th><td>By setting 1, it initializes timeout counter when any data is
received from client. By default, 1 is used.
</td></tr>
<tr><th>arg 3</Th><td>int send_reset</td></tr>
<tr><th></th><td>By setting 1, it initializes timeout counter when any data
is sent to client. Default is zero, but some application
sets this flag 1.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_tcpcontext_use_filter_file"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_tcpcontext_use_filter_file</th></tr>
<tr><th>Summary</th><td>Read a text file and configure TCPcontext's IP filter</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_tcpcontext_use_filter_file( tcpcontext_t tp, const char *path )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>Target TCPcontext.
</td></tr>
<tr><th>arg 2</Th><td>char *path</td></tr>
<tr><th></th><td>Pathname of the configuration file.
</td></tr>
<tr><th>Return value</th><td>Returns 0 if successful, otherwise minus error indicating code.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_add_circ_ipv4_filter">vce_tcpcontext_add_circ_ipv4_filter</a>
<a href="#vce_tcpcontext_add_conn_ipv4_filter">vce_tcpcontext_add_conn_ipv4_filter</a>
</td></tr>
</table><br><br>
<a name="vce_text_cmpnocase"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_text_cmpnocase</th></tr>
<tr><th>Summary</th><td>Case-insensitive C string comparison</td></tr>
<tr><th>Category</th><td>text</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_text_cmpnocase( char *s1, char *s2, int n )</b></td>
<tr><th>arg 1</Th><td>char *s1</td></tr>
<tr><th></th><td>Pointer to a string being compared. First one.
</td></tr>
<tr><th>arg 2</Th><td>char *s2</td></tr>
<tr><th></th><td>Pointer to a string being compared. Second one.
</td></tr>
<tr><th>arg 3</Th><td>int n</td></tr>
<tr><th></th><td>How many characters from the beginning are compared.
</td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td></td></tr>
</table><br><br>
<a name="vce_text_hashpjw"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_text_hashpjw</th></tr>
<tr><th>Summary</th><td>Hash a string into 32bit integer value</td></tr>
<tr><th>Category</th><td>text</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_text_hashpjw( char *s )</b></td>
<tr><th>arg 1</Th><td>char *s</td></tr>
<tr><th></th><td>Pointer to a string being hashed.
</td></tr>
<tr><th>Return value</th><td>Hash value
</td></tr>
<tr><th>Description</th><td>Calcurate hash code of the string.
Returned value will be smaller if the string is shorter.
</td></tr>
</table><br><br>
<a name="vce_text_split_index"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_text_split_index</th></tr>
<tr><th>Summary</th><td>Get address of the Nth token included in long string.</td></tr>
<tr><th>Category</th><td>text</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>char * vce_text_split_index( char *src, char c, int index )</b></td>
<tr><th>arg 1</Th><td>char *src</td></tr>
<tr><th></th><td>Top address of source string. This string will not overwritten
by this function.
</td></tr>
<tr><th>arg 2</Th><td>char c</td></tr>
<tr><th></th><td>Delimiter character. For example, ''
</td></tr>
<tr><th>arg 3</Th><td>int index</td></tr>
<tr><th></th><td>Index of token that will be split. First item is specified by index 0,
Second one will be 1.
</td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_text_split_index_get_string">vce_text_split_index_get_string</a>
</td></tr>
</table><br><br>
<a name="vce_text_split_index_get_int"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_text_split_index_get_int</th></tr>
<tr><th>Summary</th><td>Cut a string into tokens and return a integer</td></tr>
<tr><th>Category</th><td>text</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_text_split_index_get_int( char *src, char c, int index, int *v )</b></td>
<tr><th>arg 1</Th><td>char *src</td></tr>
<tr><th></th><td>Top address of a string processed.
</td></tr>
<tr><th>arg 2</Th><td>char c</td></tr>
<tr><th></th><td>Delimiter character.
</td></tr>
<tr><th>arg 3</Th><td>int index</td></tr>
<tr><th></th><td>Index number of token which will be got. First token will be got
by specifying index 0.
</td></tr>
<tr><th>arg 4</Th><td>int *v</td></tr>
<tr><th></th><td>Output integer.
</td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_text_split_index_get_string">vce_text_split_index_get_string</a>
</td></tr>
</table><br><br>
<a name="vce_text_split_index_get_string"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_text_split_index_get_string</th></tr>
<tr><th>Summary</th><td>Cut a string into tokens and return a token by string</td></tr>
<tr><th>Category</th><td>text</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_text_split_index_get_string( char *src, char c, int index, char *out, int outlen )</b></td>
<tr><th>arg 1</Th><td>char *src</td></tr>
<tr><th></th><td>Top address of source string.
</td></tr>
<tr><th>arg 2</Th><td>char c</td></tr>
<tr><th></th><td>Delimiter character.
</td></tr>
<tr><th>arg 3</Th><td>int index</td></tr>
<tr><th></th><td>Index number of the token which will be split out.
First item will be got by specifying 0.
</td></tr>
<tr><th>arg 4</Th><td>char *out</td></tr>
<tr><th></th><td>Output buffer.
</td></tr>
<tr><th>arg 5</Th><td>int outlen</td></tr>
<tr><th></th><td>Size of max output.
</td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_text_split_index">vce_text_split_index</a>
<a href="#vce_text_split_index_get_string">vce_text_split_index_get_string</a>
</td></tr>
</table><br><br>
<a name="vce_update_int2_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_update_int2_search</th></tr>
<tr><th>Summary</th><td>Add/Update a value into a 2 integer search engine.</td></tr>
<tr><th>Category</th><td>search</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_update_int2_search( int index , int key0 , int key1 , void *pointer )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Search descriptor.
</td></tr>
<tr><th>arg 2</Th><td>int key0</td></tr>
<tr><th></th><td>First integer search key.
</td></tr>
<tr><th>arg 3</Th><td>int key1</td></tr>
<tr><th></th><td>Second integer search key.
</td></tr>
<tr><th>arg 4</Th><td>void *pointer</td></tr>
<tr><th></th><td>Pointer to an entry, which will be registered in this search engine.
</td></tr>
<tr><th>Return value</th><td>Returns zero if successful, otherwise minus error indicator value.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_delete_int2_search">vce_delete_int2_search</a>
<a href="#vce_get_int2_search">vce_get_int2_search</a>
<a href="#vce_init_int2_search">vce_init_int2_search</a>
</td></tr>
</table><br><br>
<a name="vce_update_int4_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_update_int4_search</th></tr>
<tr><th>Summary</th><td>Add/Update a value into a 4 integer search engine.</td></tr>
<tr><th>Category</th><td>search</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_update_int4_search( int index , int key0 , int key1 , int key2, int key3, void *pointer )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Search descriptor.
</td></tr>
<tr><th>arg 2</Th><td>int key0</td></tr>
<tr><th></th><td>First integer search key.
</td></tr>
<tr><th>arg 3</Th><td>int key1</td></tr>
<tr><th></th><td>Second integer search key.
</td></tr>
<tr><th>arg 4</Th><td>int key2</td></tr>
<tr><th></th><td>Third integer search key.
</td></tr>
<tr><th>arg 5</Th><td>int key3</td></tr>
<tr><th></th><td>Fourth integer search key.
</td></tr>
<tr><th>arg 6</Th><td>void *pointer</td></tr>
<tr><th></th><td>Pointer to an entry, which will be registered in this search engine.
</td></tr>
<tr><th>Return value</th><td>Returns zero if successful, otherwise minus error indicator value.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_delete_int4_search">vce_delete_int4_search</a>
<a href="#vce_get_int4_search">vce_get_int4_search</a>
<a href="#vce_init_int4_search">vce_init_int4_search</a>
</td></tr>
</table><br><br>
<a name="vce_update_int_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_update_int_search</th></tr>
<tr><th>Summary</th><td>Add/Update an entry in search engine which uses integer to search key</td></tr>
<tr><th>Category</th><td>search</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_update_int_search( int index , int key , void *pointer )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Search descriptor. Got by vce_init_int_search function call in advance.
</td></tr>
<tr><th>arg 2</Th><td>int key</td></tr>
<tr><th></th><td>Search key. You should keep this key evenly distributed, so that
you can search entries faster.
</td></tr>
<tr><th>arg 3</Th><td>void *pointer</td></tr>
<tr><th></th><td>Pointer to an entry, which will be registered in the search engine.
</td></tr>
<tr><th>Return value</th><td>Returns zero if successful.
Returns minus error indicator value when any error occured.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_get_int_search">vce_get_int_search</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
</td></tr>
</table><br><br>
<a name="vce_update_string_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_update_string_search</th></tr>
<tr><th>Summary</th><td>Add/Update a value into string search engine</td></tr>
<tr><th>Category</th><td>search</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_update_string_search( int index , char *key , void *pointer )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Search descriptor.
</td></tr>
<tr><th>arg 2</Th><td>char *key</td></tr>
<tr><th></th><td>Search key string. Currently beginning 32 bytes are only used
when searching.
</td></tr>
<tr><th>arg 3</Th><td>void *pointer</td></tr>
<tr><th></th><td>Pointer to an entry which will be registered in the search engine.
</td></tr>
<tr><th>Return value</th><td>Returns zero if successful, otherwise returns minus error indicator.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_delete_string_search">vce_delete_string_search</a>
<a href="#vce_get_string_search">vce_get_string_search</a>
<a href="#vce_init_string_search">vce_init_string_search</a>
<a href="#vce_update_int_search">vce_update_int_search</a>
</td></tr>
</table><br><br>
<a name="vce_update_vstring_search"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_update_vstring_search</th></tr>
<tr><th>Summary</th><td>Add/Update a value into arbitrary length string search engine</td></tr>
<tr><th>Category</th><td>search</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_update_vstring_search( int index, char *key, void *pointer )</b></td>
<tr><th>arg 1</Th><td>int index</td></tr>
<tr><th></th><td>Search descriptor.
</td></tr>
<tr><th>arg 2</Th><td>char *key</td></tr>
<tr><th></th><td>Search key string.
</td></tr>
<tr><th>arg 3</Th><td>void *pointer</td></tr>
<tr><th></th><td>Pointer to an entry, which will be registered in this search engine.
</td></tr>
<tr><th>Return value</th><td>Returns zero if successful, otherwise returns minus error indicator value.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_delete_vstring_search">vce_delete_vstring_search</a>
<a href="#vce_init_int_search">vce_init_int_search</a>
<a href="#vce_init_vstring_search">vce_init_vstring_search</a>
</td></tr>
</table><br><br>
<a name="vce_utime_diff"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_utime_diff</th></tr>
<tr><th>Summary</th><td>get differential time of "struct timeval" in VCEI64 type</td></tr>
<tr><th>Category</th><td>util</td></tr>
<tr><th>Compatibility</th><td>linux,darwin</td></tr>
<tr><th>Prototype</th><td><b></b></td>
<tr><th>arg 1</Th><td>struct timeval *before</td></tr>
<tr><th></th><td>Previous time
</td></tr>
<tr><th>arg 2</Th><td>struct timeval *after</td></tr>
<tr><th></th><td>Later time
</td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td></td></tr>
</table><br><br>
<a name="vce_vec_init_mainserv"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vec_init_mainserv</th></tr>
<tr><th>Summary</th><td>Initialize server routine in packet-vectorize-aware server</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_vec_init_mainserv( tcpcontext_t tp, int maxcirc, int rbsize )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>Target TCPcontext.
</td></tr>
<tr><th>arg 2</Th><td>int maxcirc</td></tr>
<tr><th></th><td>Max number of circ_t, which is maintained by the TCPcontext.
Usually, this is set less than 100000.
</td></tr>
<tr><th>arg 3</Th><td>int rbsize</td></tr>
<tr><th></th><td>Length of read buffer per circ_t
</td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_vec_setup_linkage"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vec_setup_linkage</th></tr>
<tr><th>Summary</th><td>Link a packet vectorizer to server connection.</td></tr>
<tr><th>Category</th><td>tcp</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_vec_setup_linkage( tcpcontext_t tp, conn_t cp )</b></td>
<tr><th>arg 1</Th><td>tcpcontext_t tp</td></tr>
<tr><th></th><td>Target TCPcontext
</td></tr>
<tr><th>arg 2</Th><td>conn_t cp</td></tr>
<tr><th></th><td>Connect this conn_t to this TCPcontext.
To complete this action, this connection have to conected
to server.
</td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_vecprotocol_acceptwatcher_deny"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vecprotocol_acceptwatcher_deny</th></tr>
<tr><th>Summary</th><td>accept watcher for TCP circ_t connection which denies all connection</td></tr>
<tr><th>Category</th><td>watcher</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_vecprotocol_acceptwatcher_deny( circ_t c )</b></td>
<tr><th>arg 1</Th><td>circ_t c</td></tr>
<tr><th></th><td>An instance of circ_t which is newly accepted by SWP server.
</td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_vecprotocol_acceptwatcher_noop">vce_vecprotocol_acceptwatcher_noop</a>
</td></tr>
</table><br><br>
<a name="vce_vecprotocol_acceptwatcher_noop"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vecprotocol_acceptwatcher_noop</th></tr>
<tr><th>Summary</th><td>accept watcher for circ_t which accepts all connections.</td></tr>
<tr><th>Category</th><td>watcher</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_vecprotocol_acceptwatcher_noop( circ_t c )</b></td>
<tr><th>arg 1</Th><td>circ_t c</td></tr>
<tr><th></th><td>An instance of circ_t, which is newly accepted by SWP server.
</td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_vecprotocol_acceptwatcher_deny">vce_vecprotocol_acceptwatcher_deny</a>
</td></tr>
</table><br><br>
<a name="vce_vecprotocol_closewatcher_noop"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vecprotocol_closewatcher_noop</th></tr>
<tr><th>Summary</th><td>Close watcher for circ_t which does nothing</td></tr>
<tr><th>Category</th><td>watcher</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_vecprotocol_closewatcher_noop( circ_t c )</b></td>
<tr><th>arg 1</Th><td>circ_t c</td></tr>
<tr><th></th><td>Target circ_t being closed.
</td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_vecprotocol_parser_bin16"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vecprotocol_parser_bin16</th></tr>
<tr><th>Summary</th><td>Get a bin16 data record from circ_t and call a callback</td></tr>
<tr><th>Category</th><td>parser</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_vecprotocol_parser_bin16( circ_t cir )</b></td>
<tr><th>arg 1</Th><td>circ_t cir</td></tr>
<tr><th></th><td>Target circ_t
</td></tr>
<tr><th>Return value</th><td>Returns what is returnd by callback function.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_parser_bin16">vce_protocol_parser_bin16</a>
<a href="#vce_vecprotocol_unparser_bin16">vce_vecprotocol_unparser_bin16</a>
</td></tr>
</table><br><br>
<a name="vce_vecprotocol_parser_bin32"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vecprotocol_parser_bin32</th></tr>
<tr><th>Summary</th><td>Bin32 protocol parser for circ_t.</td></tr>
<tr><th>Category</th><td>parser</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_vecprotocol_parser_bin32( circ_t cir )</b></td>
<tr><th>arg 1</Th><td>circ_t cir</td></tr>
<tr><th></th><td>Target circ_t
</td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_vecprotocol_parser_bin16">vce_vecprotocol_parser_bin16</a>
</td></tr>
</table><br><br>
<a name="vce_vecprotocol_parser_text"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vecprotocol_parser_text</th></tr>
<tr><th>Summary</th><td>Get a text-line record from circ_t and call a callback</td></tr>
<tr><th>Category</th><td>parser</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_vecprotocol_parser_text( circ_t cir )</b></td>
<tr><th>arg 1</Th><td>circ_t cir</td></tr>
<tr><th></th><td>Target circ_t
</td></tr>
<tr><th>Return value</th><td>Returns what is returned by callback function.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_parser_text">vce_protocol_parser_text</a>
</td></tr>
</table><br><br>
<a name="vce_vecprotocol_parser_through"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vecprotocol_parser_through</th></tr>
<tr><th>Summary</th><td>No-op parser for circ_t</td></tr>
<tr><th>Category</th><td>parser</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_vecprotocol_parser_through( circ_t cir )</b></td>
<tr><th>arg 1</Th><td>circ_t cir</td></tr>
<tr><th></th><td>Target circ_t
</td></tr>
<tr><th>Return value</th><td>Returns what is returned by callback function.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_parser_through">vce_protocol_parser_through</a>
</td></tr>
</table><br><br>
<a name="vce_vecprotocol_pcallback_echo_bin16"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vecprotocol_pcallback_echo_bin16</th></tr>
<tr><th>Summary</th><td>Echo callback function for packet-vectorizer protocol(bin16 output)</td></tr>
<tr><th>Category</th><td>pcallback</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_vecprotocol_pcallback_echo_bin16( circ_t ct, char *data, int len )</b></td>
<tr><th>arg 1</Th><td>circ_t</td></tr>
<tr><th></th><td>Processing circ_t. Note that this is not conn_t.
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>Top address of received data.
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>Length of received data.
</td></tr>
<tr><th>Return value</th><td>Returns number of bytes tramsmitted.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_protocol_pcallback_dump">vce_protocol_pcallback_dump</a>
<a href="#vce_protocol_pcallback_echo_bin16">vce_protocol_pcallback_echo_bin16</a>
<a href="#vce_protocol_pcallback_noop">vce_protocol_pcallback_noop</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_vecprotocol_pcallback_echo_text"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vecprotocol_pcallback_echo_text</th></tr>
<tr><th>Summary</th><td>Echo callback function for packet-vectorizer protocol (text output)</td></tr>
<tr><th>Category</th><td>pcallback</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_vecprotocol_pcallback_echo_text(circ_t ct,char*data,int len)</b></td>
<tr><th>arg 1</Th><td>circ_t ct</td></tr>
<tr><th></th><td>Processing circ_t. Note that this is not a conn_t.
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>Top address of received data.
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>Length of received data.
</td></tr>
<tr><th>Return value</th><td>Number of bytes sent to the circ_t.
</td></tr>
<tr><th>Description</th><td>Echo callback function for circ_t, using text protocol.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_vecprotocol_pcallback_echo_bin16">vce_vecprotocol_pcallback_echo_bin16</a>
</td></tr>
</table><br><br>
<a name="vce_vecprotocol_unparser_bin16"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vecprotocol_unparser_bin16</th></tr>
<tr><th>Summary</th><td>Write bin16 data record into a virtual circuit within a TCP socket.</td></tr>
<tr><th>Category</th><td>parser</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_vecprotocol_unparser_bin16( circ_t ct, char *data , int len )</b></td>
<tr><th>arg 1</Th><td>circ_t ct</td></tr>
<tr><th></th><td>Target circ_t
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>Pointer to data, which will be sent
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>Length of data being sent
</td></tr>
<tr><th>Return value</th><td>Returns how many bytes are sent. This is usually (data_length + 2).
Returns minus error indicator value if any error is occured.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_vecprotocol_parser_bin16">vce_vecprotocol_parser_bin16</a>
</td></tr>
</table><br><br>
<a name="vce_vecprotocol_unparser_bin32"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vecprotocol_unparser_bin32</th></tr>
<tr><th>Summary</th><td>Write a Bin32 protocol data record to a circ_t</td></tr>
<tr><th>Category</th><td>parser</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_vecprotocol_unparser_bin32( circ_t ct, char *data, int len )</b></td>
<tr><th>arg 1</Th><td>circ_t ct</td></tr>
<tr><th></th><td>Target circ_t
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>Top address of data being sent
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>Length of data being sent (in bytes)
</td></tr>
<tr><th>Return value</th><td>Returns how many bytes are sent if successful.
Otherwise returns minus error indicator value.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_vecprotocol_unparser_bin16">vce_vecprotocol_unparser_bin16</a>
</td></tr>
</table><br><br>
<a name="vce_vecprotocol_unparser_text"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vecprotocol_unparser_text</th></tr>
<tr><th>Summary</th><td>Write a line of text protocol to a circ_t</td></tr>
<tr><th>Category</th><td>parser</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_vecprotocol_unparser_text( circ_t ct, char *data, int len )</b></td>
<tr><th>arg 1</Th><td>circ_t ct</td></tr>
<tr><th></th><td>Target circ_t
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>Top address of data being sent
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>Length of data being sent
</td></tr>
<tr><th>Return value</th><td></td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="# vce_vecprotocol_unparser_bin16"> vce_vecprotocol_unparser_bin16</a>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
</td></tr>
</table><br><br>
<a name="vce_vecprotocol_unparser_through"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_vecprotocol_unparser_through</th></tr>
<tr><th>Summary</th><td>Write raw data into circ_t without any record delimiters</td></tr>
<tr><th>Category</th><td>parser</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_vecprotocol_unparser_through( circ_t ct, char *data, int len )</b></td>
<tr><th>arg 1</Th><td>circ_t ct</td></tr>
<tr><th></th><td>Target circ_t
</td></tr>
<tr><th>arg 2</Th><td>char *data</td></tr>
<tr><th></th><td>Top address of data being sent
</td></tr>
<tr><th>arg 3</Th><td>int len</td></tr>
<tr><th></th><td>Length of data being sent
</td></tr>
<tr><th>Return value</th><td>Returns how many bytes are sent if successful.
Otherwise returns minus error indicator value.
</td></tr>
<tr><th>Description</th><td></td></tr>
<tr><th>See also</th><td>
<a href="#vce_tcpcontext_create">vce_tcpcontext_create</a>
<a href="#vce_vecprotocol_unparser_bin16">vce_vecprotocol_unparser_bin16</a>
<a href="#vce_vecprotocol_unparser_text">vce_vecprotocol_unparser_text</a>
</td></tr>
</table><br><br>
<a name="vce_verrout"></a>
<table id="funcdef">
<tr><th colspan="2" id="funcdef_title">
vce_verrout</th></tr>
<tr><th>Summary</th><td>Log output for VCE application</td></tr>
<tr><th>Category</th><td>core</td></tr>
<tr><th>Compatibility</th><td>linux,win32,other,darwin</td></tr>
<tr><th>Prototype</th><td><b>int vce_verrout( const char *format, va_list arg )</b></td>
<tr><th>arg 1</Th><td>char *format</td></tr>
<tr><th></th><td>Format string. Same as "printf" libc function.
</td></tr>
<tr><th>arg 2</Th><td>va_list arg</td></tr>
<tr><th></th><td>Argument list. from va_list.
</td></tr>
<tr><th>Return value</th><td>None
</td></tr>
<tr><th>Description</th><td>This outputs string to standard error output.
However, when the log output directory is designated by
vce_errout_config function,
it also outputs to such directory and log file is automatically rotated.
In some environment where the standard error output is not existing,
it outputs to standard output.
</td></tr>
<tr><th>See also</th><td>
<a href="#vce_errout_config">vce_errout_config</a>
<a href="#vce_errout_v">vce_errout_v</a>
</td></tr>
</table><br><br>
<!-- make_funcdef end -->
<BR><BR>
<p><a href="index.html">return to index</a><br></p>
<div id="footer">
Copyright 2000-2005 Community Engine Inc. All rights reserved.
</div>
</body>
</html>
