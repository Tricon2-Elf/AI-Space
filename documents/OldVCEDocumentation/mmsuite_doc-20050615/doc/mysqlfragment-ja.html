<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>mm-suite official document (Japanese)</title>
<style type="text/css">
P {
  TEXT-INDENT: 1em
}
</style>
</head>

<body>
<h3>MySQL データフラグメント問題</h3>

<p>
  ここでは ゲームサーバのバックエンドとして MySQL を使った場合に，
データのフラグメント化(断片化)が，
パフォーマンスに根本的な悪影響を与える問題に関して説明を加える．
これは MySQL に限らず，DBMS を使う限り普遍的に発生する問題のひとつだが，
mm-suite ではこの問題をどのように解決しようとしているかも説明する．
</p>


<h3>データフラグメント問題とは</h3>

<p>
  データフラグメント問題とは，データベースのテーブル内で
可変長フィールドを使う場合は，そのデータフィールドを伸ばす処理に関連して，
データファイル内でレコードが分断されてしまい，
1個のフィールドを取りだすためにファイル中の複数の個所をアクセスする必要が
生じるためにパフォーマンスが低下してしまう問題である．
</p>

<p>
  データフラグメント問題は，以下の SQL で再現できる．
</p>

<pre>
mysql&gt; create table testtbl ( id int, data blob );
mysql&gt; 
mysql&gt; insert into testtbl values ( 1 , "abcd" );
mysql&gt; insert into testtbl values ( 2 , "cdef" );
mysql&gt; 
mysql&gt; update testtbl set data = "abcd--expanded1--" where id=1;
mysql&gt; update testtbl set data = "cdef--expanded2--" where id=2;
mysql&gt; ...
</pre>

<p>
  上図ではまず create table し，整数 idと，可変長フィールドである
blob を用いた data を定義している．
2レコードを insert したとき，データファイル(.MYD)内の論理構造は，
以下のようになっている．
</p>
<pre>
[1][abcd][2][cdef]
</pre>
<p>
，次に1回目のupdate をすると，
[abcd]の後ろにはほかのデータが入っているので，
ファイルの末尾に場所を確保して
</p>
<pre>
[1][abcd][2][cdef][--expanded1--]
</pre>
<p>
 という感じで伸びた分を保存する．さらに2回目の update では，
</p>
<pre>
[1][abcd][2][cdef][--expanded1--][--expanded2--]
</pre>
<p>
 という感じで，末尾にさらに領域を確保して伸びた分が保存される．
もちろん，バラバラになってもフィールドを正しく取りだすことができるように，
.MYI ファイルの中に，どういう感じでデータが保管されているのかが記述されている．
この事からわかるように，データが伸びることがよくあるような環境では，
可変長フィールドを使うと，データがどんどんバラバラに格納されてしまい，
パフォーマンスが劇的に悪化(数百倍とか)してしまう．
これが，データのフラグメント(断片化)問題である．
MySQL では，これを回避するために optimize という SQL 構文を使うことができる．
</p>



<pre>
mysql&gt; optimize table charinfo;
</pre>
<p>
  この SQL を発行することで，バラバラになった表を組みかえて，
ちゃんとつながった状態に戻すことが可能である．
</p>

<h3>optimize は遅い</h3>
<p>
  想像の通り， optimize はとても遅い．たとえば，
かなりフラグメントした500MB程度のMYDファイルを戻す場合は，
高速なディスクを使っても最低 2～5分程度はかかる．
商用ゲームサイトでは，
保存データはキャラクターだけでも数GBにのぼる場合があるため，
数十分分間，データベースを停止させる必要が生じる．
また，optimize 処理は中断するとデータがとても壊れやすいため，
人間の監視をつけず自動的に行なうのは，できるだけ避けたほうがよい．
人間が optimize を手動で実施するのがよいが，
それにはメンテナンスの手間がかかる．
さらに，アクセスが激しいサイトでは，たった1週間の間でも
テーブル全体にわたるフラグメントが起こる可能性もある．
もし optimize が不要になれば，バックエンドDB のメンテナンス性は，
大幅に向上するだろう．
</p>

<p>
  optimize を不要にするには，単純に，
可変長フィールドを使わないようにすればよい．
しかし，固定長フィールドは 255文字しか入らず，
それは実用的でないので，
可変長フィールドを使って最初に insert するときにあとで伸ばさなくていい
ように大きめに保存しておいて，その中で使いまわすという風にする．
そのサイズは，今後の仕様変更にも対応できるぐらい大きく取っておく必要がある．
これはディスクの容量をいたずらに大きくし，
データファイルのサイズも必然的に，2ギガバイトを越え，
OSが許せばもっと大きくなってしまう．
このように容量とパフォーマンス，
メンテナンス性はトレードオフの関係になっている．
このトレードオフをどのあたりで落ちつかせるのかには，いくつも方法がある．
</p>
<p>
  sqllib にあたらしく追加された機能として，データの本体だけ UNIX ファイルに
格納し，そのファイルを見つけるための情報を固定長で MySQL テーブルに持つ
機能がある．この方法は，MySQL リファレンスマニュアルでも言及されている通り，
DB のパフォーマンス向上にかなり貢献する．
ただし I/O が atomic でなくなる，今度はハードディスクがフラグメントする，
といった副作用が発生する．ハードディスクのフラグメントは，
可変長エントリのフラグメントよりも粒がかなり粗いので，
通常は，はるかにパフォーマンス悪化が少ない．
また，保存されているデータ全体ではなく，部分のデフラグが可能なので，
メンテナンス性は高い．
</p>

<p>
  これまでの経験をもとに簡単に結論を出すならば，
データフィールドの，あり得る最大の長さが十分に小さく(数KB以内など)
かつ総データ量が 2GB を越えないような，小規模のサービス以外は，
sqllib の UNIX ファイルに保存するモードを使うほうがよいだろう．
</p>

<BR><BR>
<a href="index-ja.html">index に戻る</a>


<br>
<hr>
<font size=-1>
Copyright 2000-2005 CommunityEngine Inc. All rights reserved.<BR>

</body> </html>

